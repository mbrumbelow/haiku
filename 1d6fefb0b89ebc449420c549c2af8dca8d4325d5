{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2653620c_6d782940",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-05-21T00:27:57Z",
      "side": 1,
      "message": "I do not know much about how `VMCache` works, but:\n- I have tested this patch and it does not seem to break anything.\n- It seems safe to unlock the cache at that point since `unmap_address_range` does not modify any of `cache`\u0027s attributes. If it does, it seems to acquire its own locks.\n- `cache` is also protected from being deleted since `map_backing_store`\u0027s callers all own a reference to `cache`. After the call to `unmap_address_range`, `cache` is only kept to add the current area to the cache; no properties are needed at that point, so temporarily releasing the lock should not cause any unwanted effects.",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3b221c8_b66ee5cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2023-05-30T13:04:29Z",
      "side": 1,
      "message": "I don\u0027t really have objections. Can it be checked whether releasing the lock is necessary?",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1bdbc1b0_d678ddcf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-05-31T01:02:21Z",
      "side": 1,
      "message": "In #18422 there is a sample code that will crash kernels built in Debug mode if this patch is not applied because of a double mutex lock.\n\nDuring runtime it might be possible to avoid releasing the lock in some cases by throwing the `cache` variable around and comparing it with the other caches returned by the iterator, but that seems like a complicated solution.",
      "parentUuid": "b3b221c8_b66ee5cb",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04b8fac3_0630abbb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-05-31T01:28:23Z",
      "side": 1,
      "message": "Thinking about this more, I think the problem should really be solved at a higher level.\n\nThat is, map_backing_store shouldn\u0027t be called with DELETE_ADDRESS_RANGE while trying to map something with the exact same cache as is in the range to delete: it doesn\u0027t make logical sense. The caller should instead be responsible for realizing that map_backing_store actually does not need to be called at all, or perhaps, map_backing_store can realize it has nothing to do, and return without making changes.",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d0b9a0b_9b669e4e",
        "filename": "src/system/kernel/vm/vm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1011,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-05-21T03:28:32Z",
      "side": 1,
      "message": "Do we actually hold a reference to the cache in all cases, so it can\u0027t be deleted out from under us?\n\nThere are also some other cases where I\u0027m not sure this would be the correct thing to do, but I will have to think about this more. Maybe the VM experts will be able to have some commentary on the right fix here.",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f98f6e02_c6eb812b",
        "filename": "src/system/kernel/vm/vm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1011,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-05-21T03:57:28Z",
      "side": 1,
      "message": "We actually do, because of this:\nhttps://github.com/haiku/haiku/blob/74d2e61ee2f658a0611610c7628dd5f3955c5079/src/system/kernel/vm/vm.cpp#L936\n\nAnd also this:\n\nhttps://github.com/haiku/haiku/blob/74d2e61ee2f658a0611610c7628dd5f3955c5079/src/system/kernel/vm/vm.cpp#LL982C1-L989C20\n\nThe initial cache is always locked. In the codepath where a new cache needs to be created, that cache is also locked right after creation and before being assigned to `cache`.",
      "parentUuid": "0d0b9a0b_9b669e4e",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c56feb16_3edd1cbb",
        "filename": "src/system/kernel/vm/vm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1011,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-05-21T03:58:06Z",
      "side": 1,
      "message": "Oh, I misread, you said \"reference\" not lock.",
      "parentUuid": "f98f6e02_c6eb812b",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a4636e8_a7e5a738",
        "filename": "src/system/kernel/vm/vm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1011,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-05-21T04:00:52Z",
      "side": 1,
      "message": "But even for that, I checked all references to `map_backing_store`, and the passed cache is either a newly created one (`VMCacheFactory`), or something acquired by `vm_area_get_locked_cache`, which does call `AcquireRefLocked()`.",
      "parentUuid": "c56feb16_3edd1cbb",
      "revId": "1d6fefb0b89ebc449420c549c2af8dca8d4325d5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}