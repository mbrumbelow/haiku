SubDir HAIKU_TOP src apps haikudepot ;

UsePrivateHeaders interface kernel net package shared storage support ;

# source directories
local sourceDirs =
	edits_generic
	model
	textview
	ui
	ui_generic
	server
	tar
	util
;

local sourceDir ;
for sourceDir in $(sourceDirs) {
	SEARCH_SOURCE += [ FDirName $(HAIKU_TOP) src apps haikudepot $(sourceDir) ] ;
}

SEARCH_SOURCE += [ FDirName $(HAIKU_TOP) src servers package ] ;

local textDocumentSources =
	# edits_generic
	CompoundEdit.cpp
	EditContext.cpp
	EditManager.cpp
	EditStack.cpp
	UndoableEdit.cpp
	# textview
	Bullet.cpp
	BulletData.cpp
	CharacterStyle.cpp
	CharacterStyleData.cpp
	MarkupParser.cpp
	Paragraph.cpp
	ParagraphLayout.cpp
	ParagraphStyle.cpp
	ParagraphStyleData.cpp
	TextDocument.cpp
	TextDocumentLayout.cpp
	TextDocumentView.cpp
	TextEditor.cpp
	TextListener.cpp
	TextSelection.cpp
	TextSpan.cpp
	TextView.cpp
	UndoableEditListener.cpp
;

Application HaikuDepot :
	App.cpp
	BarberPole.cpp
	BitmapButton.cpp
	BitmapView.cpp
	DecisionProvider.cpp
	FeaturedPackagesView.cpp
	FilterView.cpp
	LocalIconStore.cpp
	JobStateListener.cpp
	LinkView.cpp
	LinkedBitmapView.cpp
	Logger.cpp
	main.cpp
	MainWindow.cpp
	MarkupTextView.cpp
	MessagePackageListener.cpp
	Model.cpp
	PackageAction.cpp
	PackageActionHandler.cpp
	PackageContentsView.cpp
	PackageInfo.cpp
	PackageInfoListener.cpp
	PackageInfoView.cpp
	PackageListView.cpp
	PackageManager.cpp
	RatePackageWindow.cpp
	RatingView.cpp
	support.cpp
	ScreenshotWindow.cpp
	ScrollableGroupView.cpp
	SharedBitmap.cpp
	UserLoginWindow.cpp
	WorkStatusView.cpp

	# network + server - model
	DumpExportPkg.cpp
	DumpExportPkgCategory.cpp
	DumpExportPkgScreenshot.cpp
	DumpExportPkgVersion.cpp
	DumpExportRepository.cpp
	DumpExportRepositorySource.cpp
	DumpExportRepositorySourceMirror.cpp

	# network + server - parser
	DumpExportPkgJsonListener.cpp
	DumpExportRepositoryJsonListener.cpp

	# network + server / local processes
	AbstractProcess.cpp
	AbstractServerProcess.cpp
	AbstractSingleFileServerProcess.cpp
	LocalPkgDataLoadProcess.cpp
	LocalRepositoryUpdateProcess.cpp
	ProcessCoordinator.cpp
	ProcessCoordinatorFactory.cpp
	ProcessNode.cpp
	ServerHelper.cpp
	ServerSettings.cpp
	ServerPkgDataUpdateProcess.cpp
	ServerRepositoryDataUpdateProcess.cpp
	ServerIconExportUpdateProcess.cpp
	StandardMetaDataJsonEventListener.cpp
	StandardMetaData.cpp
	WebAppInterface.cpp

	# tar
	TarArchiveHeader.cpp
	TarArchiveService.cpp

	#util
	AppUtils.cpp
	DataIOUtils.cpp
	RepositoryUrlUtils.cpp
	StorageUtils.cpp
	ToFileUrlProtocolListener.cpp

	# package_daemon
	ProblemWindow.cpp
	ResultWindow.cpp

	# text view stuff
	$(textDocumentSources)

	: be package bnetapi translation libcolumnlistview.a shared
		[ TargetLibstdc++ ] [ TargetLibsupc++ ] localestub
	: HaikuDepot.rdef
;

DoCatalogs HaikuDepot :
	x-vnd.Haiku-HaikuDepot
	:
	App.cpp
	FeaturedPackagesView.cpp
	FilterView.cpp
	MainWindow.cpp
	Model.cpp
	PackageContentsView.cpp
	PackageInfoView.cpp
	PackageListView.cpp
	PackageManager.cpp
	RatePackageWindow.cpp
	ScreenshotWindow.cpp
	UserLoginWindow.cpp
	WorkStatusView.cpp
;

Application TextDocumentTest :
	TextDocumentTest.cpp
	$(textDocumentSources)

	: be translation shared [ TargetLibsupc++ ]
;

# The following rules will produce model- and parse-classes that are generated
# from JSON schema files that are copied from the HaikuDepotServer (HDS)
# application server that HaikuDepot communicates with.  By generating the
# classes in this way, the client can be relatively sure that the structure of
# the data that is being processed correlates with the data that the server is
# sending.  This is because the server is also generating its models from the
# same JSON schema files.  In the following rules, the following positional
# parameters apply;
#
# $(1) => the target .cpp or .h file
# $(2) => the schema that will generate the .cpp / .h files
# $(3) => the python script that will generate the source

# This rule will generate the C++ model objects based on a schema.  This may
# produce a number of header (.h) and implementation (.cpp) files.

rule HdsSchemaModelGen
{
	SEARCH on $(2) = [ FDirName $(SUBDIR) server schema ] ;
	SEARCH on $(3) = [ FDirName $(SUBDIR) server tools ] ;

	Depends $(1) : $(2) $(3) ;
	MakeLocateArch $(<) ;
	HdsSchemaModelGen1 $(1) : $(2) $(3) ;
	LocalClean clean : $(<) ;
}

actions HdsSchemaModelGen1
{
	python $(2[2]) -i $(2[1]) --outputdirectory $(1:D)
}

HdsSchemaModelGen [ FGristFiles DumpExportPkg.cpp ]
	: dumpexportpkg.json : jsonschema2cppmodel.py ;

HdsSchemaModelGen [ FGristFiles DumpExportRepository.cpp ]
	: dumpexportrepository.json : jsonschema2cppmodel.py ;

# This rule will generate a 'parser listener' that works with the Haiku JSON
# parsing classes.  The listener is intended to be used on bulk data.

rule HdsSchemaBulkParserGen
{
	SEARCH on $(2) = [ FDirName $(SUBDIR) server schema ] ;
	SEARCH on $(3) = [ FDirName $(SUBDIR) server tools ] ;

	Depends $(1) : $(2) $(3) ;
	MakeLocateArch $(<) ;
	HdsSchemaBulkParserGen1 $(1) : $(2) $(3) ;
	LocalClean clean : $(<) ;
}

actions HdsSchemaBulkParserGen1
{
	python $(2[2]) -i $(2[1]) --outputdirectory $(1:D) --supportbulkcontainer
}

HdsSchemaBulkParserGen [ FGristFiles DumpExportRepositoryJsonListener.cpp ]
	: dumpexportrepository.json : jsonschema2cppparser.py ;
HdsSchemaBulkParserGen [ FGristFiles DumpExportPkgJsonListener.cpp ]
	: dumpexportpkg.json : jsonschema2cppparser.py ;

# Because a number of .cpp and .h files will be generated from a single python
# script's run, it is necessary to introduce an additional dependency here so
# that one file triggers the python script run and the other consequent output
# files can then depend on that one 'trigger file'.

rule HdsSchemaDummy
{
	Depends $(1) : $(2) ;
	MakeLocateArch $(<) ;
	HdsSchemaDummy1 $(1) : $(2) ;
	LocalClean clean : $(<) ;
}

actions HdsSchemaDummy1
{
}

HdsSchemaDummy [ FGristFiles DumpExportPkgJsonListener.h ]
	: [ FGristFiles DumpExportPkgJsonListener.cpp ] ;
HdsSchemaDummy [ FGristFiles DumpExportRepositoryJsonListener.h ]
	: [ FGristFiles DumpExportRepositoryJsonListener.cpp ] ;

local genDependency ;
local genDependencies ;

genDependencies =
	DumpExportRepository.h
	DumpExportRepositorySource.cpp
	DumpExportRepositorySource.h
	DumpExportRepositorySourceMirror.cpp
	DumpExportRepositorySourceMirror.h
;

for genDependency in $(genDependencies) {
	HdsSchemaDummy [ FGristFiles $(genDependency) ] : [ FGristFiles DumpExportRepository.cpp ] ;
}

genDependencies =
	DumpExportPkg.h
	DumpExportPkgCategory.cpp
	DumpExportPkgCategory.h
	DumpExportPkgScreenshot.cpp
	DumpExportPkgScreenshot.h
	DumpExportPkgVersion.cpp
	DumpExportPkgVersion.h
	DumpExportRepository.cpp
	DumpExportRepository.h
	DumpExportRepositorySource.cpp
	DumpExportRepositorySource.h
	DumpExportRepositorySourceMirror.cpp
	DumpExportRepositorySourceMirror.h
;

for genDependency in $(genDependencies) {
	HdsSchemaDummy [ FGristFiles $(genDependency) ] : [ FGristFiles DumpExportPkg.cpp ] ;
}