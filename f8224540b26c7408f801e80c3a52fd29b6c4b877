{
  "comments": [
    {
      "key": {
        "uuid": "01e93684_72e0efd3",
        "filename": "src/add-ons/kernel/power/cpufreq/intel_pstates/intel_pstates.cpp",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2020-09-12T19:57:58Z",
      "side": 1,
      "message": "what happened to the shift by 8? (I don\u0027t understand why it was there before, but if it\u0027s incorrect, I suspect other places in the code need to be adjusted too?)",
      "revId": "f8224540b26c7408f801e80c3a52fd29b6c4b877",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06e13a4b_8422506f",
        "filename": "src/add-ons/kernel/power/cpufreq/intel_pstates/intel_pstates.cpp",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2020-09-13T08:55:36Z",
      "side": 1,
      "message": "Removing the displacement is the main point of the change.\n\nI cannot assess the correctness of the target state calculation, but this should be enough: right or wrong, the delta is 0..kCPUPerformanceScaleMax, and that makes the target state between the minimum and maximum read from PLATFORM_INFO and TURBO_RATIO_LIMIT.\n\nI added my cpu model to the supported list and some dprintf for tracing and internal info, including the reading of the current performance status from PERF_STATUS. Then changed and abused pstates_set_scheduler_mode to set the values I wanted between the limits.\n\nWith current code, whatever the value I set it didn\u0027t change the reading from PERF_STATUS, even after having set it several times for all cpus. A simple test[0] showed the performance hadn\u0027t changed.\n\nWithout the shift, the reading from PERF_STATUS did in fact change to the new values (after having set the value in both threads sharing core) and the test showed constant pstate * user_time.\n\nSo, if by whatever magic a target of 12 is calculated, PERF_CTL should be set to 0xc, not 0xc00.\n\nThat said, I have only done all that in my Intel(R) Core(TM) i3 CPU M 330, model 06_25H, and I only have a degree in swearing, no PhD in black arts, both of which seem to be a requirement to correctly decipher Intel docs. Maybe this should wait for confirmation from someone with one of the currently listed as supported models?\n\n[0] time for i in $(seq 1000); do factor some_big_number \u003e /dev/null; done",
      "parentUuid": "01e93684_72e0efd3",
      "revId": "f8224540b26c7408f801e80c3a52fd29b6c4b877",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ee9ecc14_33faeb05",
        "filename": "src/add-ons/kernel/power/cpufreq/intel_pstates/intel_pstates.cpp",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2020-09-14T18:28:22Z",
      "side": 1,
      "message": "My reasonably recent copy of the Intel Software Developer\u0027s Manual has the PERF_CTL MSR listed as architectural in table 2-2 of section 2.1 in volume 4 of the SDM. This means that the MSR is in fact not model specific anymore but architecturally guaranteed to be there and work as described, at least since 0F_03H / Pentium 4. It has the mentioned layout with the desired P-STATE value in bits 15:0.\n\nThe original shifted version of the 16 bit pstate argument definitely seems wrong in that case. If the values are calculated so that they never go beyond 8 bits, then the argument type should be changed to reflect that.\n\nThis change, including the masked write, looks more correct to me. If it was tested that the status register actually changes to the requested value, this lends even more credence to it.",
      "parentUuid": "06e13a4b_8422506f",
      "revId": "f8224540b26c7408f801e80c3a52fd29b6c4b877",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    }
  ]
}