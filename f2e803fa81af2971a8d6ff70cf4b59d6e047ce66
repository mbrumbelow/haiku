{
  "comments": [
    {
      "key": {
        "uuid": "1f076fec_49535a1c",
        "filename": "src/system/kernel/debug/font.h",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2021-05-07T10:58:53Z",
      "side": 1,
      "message": "For some reason gcc2 doesn\u0027t like this. A different definition, more verbose initialization seems to work:\n\n struct FramebufferFont {\n \tint glyphWidth;\n \tint glyphHeight;\n \tuint16_t *data;\n };\n \n uint16_t fooFontData[] \u003d { ... };\n FramebufferFont fooFont \u003d { 6, 12, fooFontData };",
      "revId": "f2e803fa81af2971a8d6ff70cf4b59d6e047ce66",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "251b1d88_37a74dab",
        "filename": "src/system/kernel/debug/font.h",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-05-07T11:25:21Z",
      "side": 1,
      "message": "That is not equivalent and results in more pointer indirection.\n\nHave you tried uint16_t data[0]; instead of uint16_t data[]; ? This is the pre-C99 GCC extension to do the same: https://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc_4.html#SEC74",
      "parentUuid": "1f076fec_49535a1c",
      "revId": "f2e803fa81af2971a8d6ff70cf4b59d6e047ce66",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0ac8805_ce43e84b",
        "filename": "src/system/kernel/debug/font.h",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2021-05-07T14:14:10Z",
      "side": 1,
      "message": "I have, same result. Note the struct is accepted in both cases, it\u0027s the initialization that fails, always with \"excess elements in aggregate initializer\". Giving a big enough fixed size to data also works, of course, at the cost of waste for the small font.",
      "parentUuid": "251b1d88_37a74dab",
      "revId": "f2e803fa81af2971a8d6ff70cf4b59d6e047ce66",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c99c22b_8271de5b",
        "filename": "src/system/kernel/debug/font.h",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-05-14T14:26:06Z",
      "side": 1,
      "message": "Now it works in gcc2. I just used two different structure definitions. This also allows to keep the original font in uint8 format, otherwise its size would have doubled and there was no reason to do that.",
      "parentUuid": "b0ac8805_ce43e84b",
      "revId": "f2e803fa81af2971a8d6ff70cf4b59d6e047ce66",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94542fe0_9255a990",
        "filename": "src/system/kernel/debug/font.h",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-05-17T09:12:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0c99c22b_8271de5b",
      "revId": "f2e803fa81af2971a8d6ff70cf4b59d6e047ce66",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": false
    }
  ]
}