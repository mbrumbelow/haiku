{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6acaa0a2_95bf3a93",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2022-01-14T11:50:12Z",
      "side": 1,
      "message": "Maybe timer handling can be moved to BLooper event loop (use read massage with timeout)?",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa255790_584842bc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2024-01-02T21:55:59Z",
      "side": 1,
      "message": "I think we might give it a go instead of speculating. It is very easy to rollback once it has been proven it causes any issues.",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7bca9802_b75534cc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-01-02T22:01:36Z",
      "side": 1,
      "message": "The current limitation at 50ms is too high, we would need, at a minimum, 16ms for smooth animations on a 60Hz display (and of course, even less on higher refresh rate displays). BMessageRunner is already used in that way in some places, so we should fix that.\n\nThen, there is the question of what a \"reasonable\" minimum value should be. 1ms? 250us? why not 1us as suggested here? With current CPU speeds, that is still several thousands of CPU cycles.",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43e14fc2_425ddd48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-01-03T02:13:55Z",
      "side": 1,
      "message": "Every message sent from another process incurs a lot of context switch overhead.\n\nI think it\u0027d be better to move BMessageRunner entirely into libbe, as suggested above. That way the messages would be delivered entirely in-process (and bypass ports altogether.)",
      "parentUuid": "7bca9802_b75534cc",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0c4fe82_f58e2a10",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2024-01-03T02:18:42Z",
      "side": 1,
      "message": "According to my tests, timer with 1us precision implemented in Registrar process works good enough. Implementing timer on libbe side will need significant change of logic and not trivial. It also may cause unfair message processing if there are a lot of timer and non/timer messages in the sane time.\n\nSo lets merge this first.",
      "parentUuid": "43e14fc2_425ddd48",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82f6ee99_f1ded52b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-01-03T02:20:44Z",
      "side": 1,
      "message": "If someone has set up a timer that generates so many messages it causes unfair message processing, that sounds like a problem for them.\n\nI think I looked at BMessageRunner-in-application before and it seemed not hard to do, I could look at it again; only there was some disagreement about it starting another thread which wouldn\u0027t be controlled directly by the programmer? Personally I don\u0027t think there\u0027s much of a problem with that, though...",
      "parentUuid": "f0c4fe82_f58e2a10",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "082e8e13_a7b2d13e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2024-01-03T02:30:05Z",
      "side": 1,
      "message": "There are 2 possible implementations of BMessageRunner in libbe.so:\n\n1. Run separate timer thread. It will cause significant resource waste because each thread consume stack memory etc. Also there are almost no difference between which 2 threads context switch is done: the same team threads or threads from separate thread. So it will work almost the same as current Registrar implementation, but will waste more resources.\n\n2. Use read port message with timeout to implement timer. It will need significant rework of BLooper logic and need to be very careful so both timer and non-timer messages will be fairly processed. Timer messages should be not lost if MessageReceived handler send another message to itself, making a 100% CPU load loop. Also 0 delay timer should not cause non-timer messages to be not processed.\n\nI think that current Registrar timer solution is good enough and no further work is needed, just remove artificial minimal timer delay limit.",
      "parentUuid": "82f6ee99_f1ded52b",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "820ed8bc_0ebd8c03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-01-03T02:40:23Z",
      "side": 1,
      "message": "\u003e It will cause significant resource waste because each thread consume stack memory etc.\n\nApplications which don\u0027t need Pulse won\u0027t have a BMessageRunner thread. (I guess I don\u0027t know how many apps don\u0027t set B_PULSE_NEEDED... perhaps not too many.)\n\n\u003e Also there are almost no difference between which 2 threads context switch is done: the same team threads or threads from separate thread. \n\nI don\u0027t think this is true. Context switch between threads on the same team don\u0027t change address space.\n\n\u003e So it will work almost the same as current Registrar implementation, but will waste more resources.\n\nThere\u0027s one more difference: messages sent within an application do not get sent through ports at all, but stay in virtual memory. That\u0027s an important difference.\n\n\u003e Use read port message with timeout to implement timer. It will need significant rework of BLooper logic \n\nAt least for Pulse, I don\u0027t think so? It\u0027s just one timeout. I think Pulse at least should be implemented that way, while other BMessageRunners can be implemented with the separate thread. How many applications actually use a non-Pulse MessageRunner? (Very few, I\u0027d imagine.)\n\nThat\u0027d then have the maximum efficiency here, as pulse\u0027ing threads would just rely on the regular thread scheduler for timeouts and could generate their own messages, while non-pulse messagerunners did create a new thread, but that\u0027d be rare.",
      "parentUuid": "082e8e13_a7b2d13e",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8c1a81c_25ccef96",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2024-01-03T02:45:20Z",
      "side": 1,
      "message": "Please let this patch to be merged first. I am tired to wait for already 4 years.\n\n\u003e How many applications actually use a non-Pulse MessageRunner? (Very few, I\u0027d imagine.)\n\nHaiku BMessageRunner implementation is broken and it is one of significant reasons why it is not widely used. After this fix, it perfectly fit to various GUI animations and game loops.\n\n\u003e I don\u0027t think this is true. Context switch between threads on the same team don\u0027t change address space.\n\nOkay, let me retest.",
      "parentUuid": "820ed8bc_0ebd8c03",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bf8e520_b0248911",
        "filename": "src/servers/registrar/MessageRunnerManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-01-02T22:01:36Z",
      "side": 1,
      "message": "It should be kMini**m**alTimeInterval while we\u0027re at it.",
      "revId": "bf299944de1f7630bb7bb031159a129e09b4e3ed",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}