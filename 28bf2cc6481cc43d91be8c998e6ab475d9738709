{
  "comments": [
    {
      "key": {
        "uuid": "049237a9_f9546f38",
        "filename": "src/tests/kits/storage/SymLinkTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 561,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2020-04-20T07:14:38Z",
      "side": 1,
      "message": "The idea was to return the length, so that you could do something like this:\n\nlen \u003d link.ReadLink(NULL, 0);\nchar* buffer \u003d malloc(len);\nlink.ReadLink(buffer, len);\n\nB_BUFFER_OVERFLOW does not give this information.",
      "revId": "28bf2cc6481cc43d91be8c998e6ab475d9738709",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93fdb840_20f9da4f",
        "filename": "src/tests/kits/storage/SymLinkTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 561,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2020-04-20T12:06:58Z",
      "side": 1,
      "message": "This indeed hints to a problematic API change of ours. This behavior had not been documented by Be Inc., though. In any case, I think we should fix this in the ReadLink() implementation; in this case, ReadLink() should also fill as many bytes as possible (not sure if ours does that) -- IMO it should not clobber the buffer if it returns an error.",
      "parentUuid": "049237a9_f9546f38",
      "revId": "28bf2cc6481cc43d91be8c998e6ab475d9738709",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc08c0ba_11c9c89a",
        "filename": "src/tests/kits/storage/SymLinkTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 561,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2020-04-20T16:31:40Z",
      "side": 1,
      "message": "Well, the Be Book documents it as \"to be perfectly safe, the buffer should be B_PATH_NAME_LENGTH characters long\", and everyone wants to be perfectly safe, right? So it seems unlikely someone would have used a shorter buffer.\n\nBut, I would go on the side of compatibility with BeOS here, even if it actually contradicts the Be Book (\"The function returns the number of bytes that were copied (or it returns an error).\", but it can return more than the number of bytes actually copied in that case). The behavior is not completely unheard of in other places (snprintf, for example) so it makes some sense.",
      "parentUuid": "93fdb840_20f9da4f",
      "revId": "28bf2cc6481cc43d91be8c998e6ab475d9738709",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "372b3a88_a2782384",
        "filename": "src/tests/kits/storage/SymLinkTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 561,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-04-21T08:10:20Z",
      "side": 1,
      "message": "I sat down tonight to fix this and to do some testing in BeOS to make sure we\u0027re actually matching its behavior. I updated the patch but it isn\u0027t ready to merge because the change to ReadLink breaks MakeLinkedPath. I\u0027m out of time for today but I\u0027ll fix that up and submit an update tomorrow.\n\nI spent some time testing in BeOS. Some notes:\n\nlink.ReadLink(NULL, 0) definitely crashes in R5. Are you sure that is supposed to be possible?\n\nlink.ReadLink() indeed does always return the length of the links contents, so the patch is updated to reflect that.\n\nlink.ReadLink() did not seem to guarantee NULL termination of the string written to the provided buffer. I\u0027ve verified that it does write a \u0027\\0\u0027 byte to the end of the string IFF the link contents is shorter than the provided size. But if the buffer size is \u003c\u003d the link contents length, no \u0027\\0\u0027 byte is written.\n\nIt seems to me that while making the guarantee that the string is always NULL terminated is not the same behavior as BeOS, doing so is way safer so it seems like the right thing to do.",
      "parentUuid": "fc08c0ba_11c9c89a",
      "revId": "28bf2cc6481cc43d91be8c998e6ab475d9738709",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    }
  ]
}