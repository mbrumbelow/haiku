{
  "comments": [
    {
      "key": {
        "uuid": "049237a9_f9546f38",
        "filename": "src/tests/kits/storage/SymLinkTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 561,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2020-04-20T07:14:38Z",
      "side": 1,
      "message": "The idea was to return the length, so that you could do something like this:\n\nlen \u003d link.ReadLink(NULL, 0);\nchar* buffer \u003d malloc(len);\nlink.ReadLink(buffer, len);\n\nB_BUFFER_OVERFLOW does not give this information.",
      "revId": "28bf2cc6481cc43d91be8c998e6ab475d9738709",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93fdb840_20f9da4f",
        "filename": "src/tests/kits/storage/SymLinkTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 561,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2020-04-20T12:06:58Z",
      "side": 1,
      "message": "This indeed hints to a problematic API change of ours. This behavior had not been documented by Be Inc., though. In any case, I think we should fix this in the ReadLink() implementation; in this case, ReadLink() should also fill as many bytes as possible (not sure if ours does that) -- IMO it should not clobber the buffer if it returns an error.",
      "parentUuid": "049237a9_f9546f38",
      "revId": "28bf2cc6481cc43d91be8c998e6ab475d9738709",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc08c0ba_11c9c89a",
        "filename": "src/tests/kits/storage/SymLinkTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 561,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2020-04-20T16:31:40Z",
      "side": 1,
      "message": "Well, the Be Book documents it as \"to be perfectly safe, the buffer should be B_PATH_NAME_LENGTH characters long\", and everyone wants to be perfectly safe, right? So it seems unlikely someone would have used a shorter buffer.\n\nBut, I would go on the side of compatibility with BeOS here, even if it actually contradicts the Be Book (\"The function returns the number of bytes that were copied (or it returns an error).\", but it can return more than the number of bytes actually copied in that case). The behavior is not completely unheard of in other places (snprintf, for example) so it makes some sense.",
      "parentUuid": "93fdb840_20f9da4f",
      "revId": "28bf2cc6481cc43d91be8c998e6ab475d9738709",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    }
  ]
}