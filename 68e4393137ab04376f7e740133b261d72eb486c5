{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1ee3c505_04d7d4b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2023-09-28T17:52:00Z",
      "side": 1,
      "message": "Iterating one time over the CPUSet should be the way to go. No need to minimize the delivery count IMO.",
      "revId": "68e4393137ab04376f7e740133b261d72eb486c5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92503de7_47443ddf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000250
      },
      "writtenOn": "2023-09-29T11:55:57Z",
      "side": 1,
      "message": "Out of interest:\n- Linux groups IPIs by cluster ID\n- NetBSD broadcasts all IPIs to all machines\n- FreeBSD and Illumos send one IPI at a time\n\n..And as wrmsr isn\u0027t serializing here, it\u0027s most probably fine not to cluster them.",
      "parentUuid": "1ee3c505_04d7d4b3",
      "revId": "68e4393137ab04376f7e740133b261d72eb486c5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b489bce_fc2d73c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2023-09-29T17:35:06Z",
      "side": 1,
      "message": "OK. The idea was more to group adjacent apic_id with the same cluster, something like:\n``` c\n for (int i \u003d 0; i \u003c cpuCount; i++) {\n     if (!cpuSet.GetBit(i) || i \u003d\u003d currentCpu)\n        continue;\n     uint32 destination \u003d gCPU[i].arch.logical_apic_id;\n     for (i++; i \u003c count; i++) {\n         if (!cpuSet.GetBit(i) || i \u003d\u003d currentCpu)\n            continue;\n         if ((gCPU[i].arch.logical_apic_id \u0026 0xFFFF0000) !\u003d (destination \u0026 0xFFFF0000)) {\n            i--;\n\t    break;\n\t }\n\t destination |\u003d gCPU[i].arch.logical_apic_id \u0026 0xFFFF;\n     }\n     apic_set_interrupt_command(destination, mode);\n }\n```\nBut I agree, it might not be worth the effort.",
      "parentUuid": "92503de7_47443ddf",
      "revId": "68e4393137ab04376f7e740133b261d72eb486c5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18f1d5e3_d597f892",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000250
      },
      "writtenOn": "2023-09-29T18:28:56Z",
      "side": 1,
      "message": "Oh, fair. I could do that, but it\u0027s likely only a slight optimization; it doesn\u0027t look like this is a bottleneck for other operating systems, so I think it might be better suited for a later commit; maybe involving cleaning up the whole APIC code (I\u0027m a bit unsure how much of this is in fact x2APIC specific, for example.)",
      "parentUuid": "2b489bce_fc2d73c0",
      "revId": "68e4393137ab04376f7e740133b261d72eb486c5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "41ddee88_a211dc16",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2023-09-29T18:50:58Z",
      "side": 1,
      "message": "OK. Let\u0027s wait for the feedback of testers.",
      "parentUuid": "18f1d5e3_d597f892",
      "revId": "68e4393137ab04376f7e740133b261d72eb486c5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}