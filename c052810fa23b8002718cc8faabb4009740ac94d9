{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d2125b69_eeb2ced1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2023-10-26T10:59:31Z",
      "side": 1,
      "message": "Doesn\u0027t that break existing apps?",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6567903d_2bfaad04",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-10-26T11:43:54Z",
      "side": 1,
      "message": "No, thanks to a combination of:\n- this is used only in C APIs, so there is no parameter type mangling,\n- in the x86 calling convention, parameters are passed on the stack, and the stack is always aligned to 4 bytes. So, smaller parameters are actually converted to int\n- in x86_64, the situation is similar, the parameter always fills a 64-bit register",
      "parentUuid": "d2125b69_eeb2ced1",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4c7736b6_ab3fb41a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2023-10-26T12:41:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6567903d_2bfaad04",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1292c38a_19641c1d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-10-26T17:01:56Z",
      "side": 1,
      "message": "There appears to be another possibility here. sizeof(termios) appears to be 32 on both x86 and x86_64, but only 30 bytes are actually used leaving 2 bytes of padding. So there is room for another uint16, perhaps you might be able to add a bit more flexibility using that?\n\nc_ispeed{_divider} is unfortunately at offset 17 so to replace those two with a uint16 without changing the offset of c_cc will require __pack__ing the structure. I don\u0027t suppose we could reorder some things here, if we\u0027re changing the meaning of ispeed/ospeed anyway?\n\nIt looks like Linux does not allow fully custom baudrates but has a list of options to pick from. Maybe we can just use a larger enum rather than having a \"divider\" here which restricts things?\n\nAnother possibility is: it appears all speeds larger than 1000 always have the last 2 digits be 00. That means we could encode custom speeds much larger than 65535 in a uint16 anyway.",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40e55ddc_3ed84485",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-10-26T17:06:12Z",
      "side": 1,
      "message": "Will c_line actually be accessed by applications? It looks like that\u0027s not a standard member of the structure (FreeBSD doesn\u0027t have it.) So then uint16 ispeed can be put after the flags, c_line after it, and uint16 ospeed at the end.",
      "parentUuid": "1292c38a_19641c1d",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}