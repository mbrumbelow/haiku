{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d2125b69_eeb2ced1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2023-10-26T10:59:31Z",
      "side": 1,
      "message": "Doesn\u0027t that break existing apps?",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6567903d_2bfaad04",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-10-26T11:43:54Z",
      "side": 1,
      "message": "No, thanks to a combination of:\n- this is used only in C APIs, so there is no parameter type mangling,\n- in the x86 calling convention, parameters are passed on the stack, and the stack is always aligned to 4 bytes. So, smaller parameters are actually converted to int\n- in x86_64, the situation is similar, the parameter always fills a 64-bit register",
      "parentUuid": "d2125b69_eeb2ced1",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4c7736b6_ab3fb41a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2023-10-26T12:41:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6567903d_2bfaad04",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1292c38a_19641c1d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-10-26T17:01:56Z",
      "side": 1,
      "message": "There appears to be another possibility here. sizeof(termios) appears to be 32 on both x86 and x86_64, but only 30 bytes are actually used leaving 2 bytes of padding. So there is room for another uint16, perhaps you might be able to add a bit more flexibility using that?\n\nc_ispeed{_divider} is unfortunately at offset 17 so to replace those two with a uint16 without changing the offset of c_cc will require __pack__ing the structure. I don\u0027t suppose we could reorder some things here, if we\u0027re changing the meaning of ispeed/ospeed anyway?\n\nIt looks like Linux does not allow fully custom baudrates but has a list of options to pick from. Maybe we can just use a larger enum rather than having a \"divider\" here which restricts things?\n\nAnother possibility is: it appears all speeds larger than 1000 always have the last 2 digits be 00. That means we could encode custom speeds much larger than 65535 in a uint16 anyway.",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40e55ddc_3ed84485",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-10-26T17:06:12Z",
      "side": 1,
      "message": "Will c_line actually be accessed by applications? It looks like that\u0027s not a standard member of the structure (FreeBSD doesn\u0027t have it.) So then uint16 ispeed can be put after the flags, c_line after it, and uint16 ospeed at the end.",
      "parentUuid": "1292c38a_19641c1d",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d64f4622_0ae881c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-10-26T17:06:36Z",
      "side": 1,
      "message": "(And maybe we should add a TODO comment about improving this more during a post-R1 ABI break...)",
      "parentUuid": "40e55ddc_3ed84485",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb110579_b8c0c66c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-10-31T14:27:06Z",
      "side": 1,
      "message": "I see that Linux chose a different solution:\n\n       Setting the baud rate to a value other than those defined by Bnnn\n       constants is possible via the TCSETS2 ioctl; see ioctl_tty(2).\n       \nOn the other hand FreeBSD always uses the baudrate directly: https://man.freebsd.org/cgi/man.cgi?query\u003dcfsetspeed\u0026apropos\u003d0\u0026sektion\u003d0\u0026manpath\u003dFreeBSD+13.2-RELEASE+and+Ports\u0026arch\u003ddefault\u0026format\u003dhtml\n\nI chose to use a divider because this is how the hardware actually works: there is a base clock and then it is divided to generate a lower baudrate. So, this solution is easy to implement for the drivers (just write the divider into the corresponding register), and will not lead to too much rounding errors. And we have some CBAUD constants available in case we need more dividers to reach more frequencies.\n\nAn uint16 is not enough, I considered it, but I need 1.5Mbaud and 3MBaud, so a divide by 100 is still way over what can fit in a 16 bit value. And there would be rounding errors in the driver in most cases. That\u0027s why I went with a divider that matches what is typically done in the hardware, to not introduce extra rounding errors. I think it provides a good compromise. The extra available uint8s could be used for extra precision if needed.\n\nI don\u0027t want to do anything more complicated than this. This solution works and whatever we do, without changing the struct size we\u0027re not going to get fully arbitrary baudrate values this way. If you don\u0027t plan to implement something else, I will either merge this, or just introduce the two baudrates I need in the CBAUD enum.\n\nAnd yes, we should change this post-R1, I will add a note about that in the wiki.",
      "parentUuid": "d64f4622_0ae881c8",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b295c83_789cc837",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-11-01T03:05:05Z",
      "side": 1,
      "message": "OK, fair enough. I guess we aren\u0027t too worried about fully custom serial hardware at the moment.\n\nAnyway, the build apparently failed (see above).",
      "parentUuid": "cb110579_b8c0c66c",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6515a58d_5069e0c4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-11-01T09:06:22Z",
      "side": 1,
      "message": "Yes, and I still need to test this with my serial interface setup (planned to do it last weekend but some other tasks took more work than I expected). I\u0027ll get back to this, just wanted to be sure I wouldn\u0027t get asked to rewrite it all in a completely different way after it\u0027s done.",
      "parentUuid": "0b295c83_789cc837",
      "revId": "c052810fa23b8002718cc8faabb4009740ac94d9",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}