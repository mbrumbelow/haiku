{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a49841c8_53fd465d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2022-09-03T17:25:41Z",
      "side": 1,
      "message": "What will happen when nested interrupts occur?",
      "revId": "8efe6c267ab2b43c792f3b17a1966a8638893b73",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49400c41_21b159d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-09-03T18:05:43Z",
      "side": 1,
      "message": "I guess that\u0027s to be tackled in the exception handler?\nAnyway I\u0027m trying to mimic here what the riscv64 port does (and the x86 port seems to do something similar as well)",
      "parentUuid": "a49841c8_53fd465d",
      "revId": "8efe6c267ab2b43c792f3b17a1966a8638893b73",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b80c4449_69ec0958",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2022-09-03T18:41:54Z",
      "side": 1,
      "message": "riscv64 FPU switching code is functional, but it do not properly handle nested kernel iframes. So in theory it can corrupt kernel FPU state. Unlike Linux, Haiku allows to use FPU in kernel mode.\n\nIt if fine to apply change for now, but it need to be careful and implement complete correct kernel FPU state management in future.",
      "parentUuid": "49400c41_21b159d4",
      "revId": "8efe6c267ab2b43c792f3b17a1966a8638893b73",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}