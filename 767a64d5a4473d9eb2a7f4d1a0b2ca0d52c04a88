{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b155f1bb_69bfe906",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-09-07T02:20:57Z",
      "side": 1,
      "message": "Unless someone has a reason why we should really try to save every last bit of memory, I think it makes more sense to abandon this one.",
      "revId": "767a64d5a4473d9eb2a7f4d1a0b2ca0d52c04a88",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "67be62f0_8c2f7cc6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000062
      },
      "writtenOn": "2024-09-07T06:24:52Z",
      "side": 1,
      "message": "Agreed.",
      "parentUuid": "b155f1bb_69bfe906",
      "revId": "767a64d5a4473d9eb2a7f4d1a0b2ca0d52c04a88",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24778d83_54c41939",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-09-07T08:42:18Z",
      "side": 1,
      "message": "Both of these seem to be the wrong algorithm for the job.\n\nFor lookup by string, a Trie (https://en.wikipedia.org/wiki/Trie) could be a better choice if there are enough nodes for it to be useful.\n\nIf there are not that many nodes and they are in fixed numbers (or at least, they change rarely, for example only when activating or deactivating a package), a binary search in a table sorted alphabetically may work.\n\nLikewise if the keys change rarely, you could build a \"perfect\" hash table once you know all the keys: http://stevehanov.ca/blog/?id\u003d119 You\u0027d have to rebuild the hashtable everytime a package is activated or deactivated, but you could probably cache it (or parts of it) on disk with the activated-package file, so you don\u0027t have to recompute it at every boot. There are various algorithms to compute one such hash, depending if you expect to have only a few entries (example: keywords in a programming language) or a lot of entries (exemple: string search in a large database). HEre, if I understand correctly, the lookup is per directory, so I\u0027d expect around a 1000 entries maximum? So, somewhere in between the two.\n\nThe size of the hash table in tour measurements is about 17 bytes per file, I see one half of that is a pointer in the Node class to handle collisions (that will be 8 bytes on a 64bit system), where are the other 9 bytes coming from? With a perfect hash function, there are no collisions, and so this pointer could be removed.\n\nAm I missing something here? I\u0027m not sure if my assumption that these structure change only on package activation/deactivation or some other sufficiently \"rare\" events is right. If that\u0027s the case, it is certainly something we can take to our advantage to pre-compute things at that time.\n\nLooking at the code, another thing that could possibly save space is removing the reference count in Node, and instead using some garbage collection system to handle deleting nodes. This follows the same idea: I assume that nodes in packagefs are rarely deleted (only when a package is deactivated?), and so it would be OK to optimize the usage, at the cost of slightly slower package uninstall (the gc may need to iterate over a few data structures to see what is or isn\u0027t referenced). I don\u0027t know how much code references these nodes, if there is a lot of places, that could make this difficult to get right.",
      "parentUuid": "67be62f0_8c2f7cc6",
      "revId": "767a64d5a4473d9eb2a7f4d1a0b2ca0d52c04a88",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6bd20679_d5b56847",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-09-07T15:21:53Z",
      "side": 1,
      "message": "\u003e where are the other 9 bytes coming from? \n\nThe hash table has to allocate an array of pointers for the table itself, of course. I think it allocates rounding up to the nearest power of 2, so it\u0027s a little larger than one element per entry in the general case.\n\n\u003e With a perfect hash function, there are no collisions, and so this pointer could be removed.\n\nUnless I\u0027m mistaken, the hash table doesn\u0027t resize immediately when new items are inserted, but only after some threshold is crossed (or at least that\u0027s what would seem to make the most sense for an open hash table.) Before the threshold is crossed, we will have some items with different hashes but which are stored in the same bucket. So we still need the pointer regardless.",
      "parentUuid": "24778d83_54c41939",
      "revId": "767a64d5a4473d9eb2a7f4d1a0b2ca0d52c04a88",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd366d52_42cb56f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-09-07T15:24:28Z",
      "side": 1,
      "message": "Another possible data structure to use here is an IterableSplayTree. That might wind up being faster in the end due to the splaying status. However it has the major disadvantage that we would need a write lock to do lookups into it, so that may be worse in the end.",
      "parentUuid": "6bd20679_d5b56847",
      "revId": "767a64d5a4473d9eb2a7f4d1a0b2ca0d52c04a88",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30f97b58_d5ef1b6f",
        "filename": "src/add-ons/kernel/file_systems/packagefs/nodes/Node.h",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-09-07T02:21:58Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nclass Node : public AVLTreeNode\n{\n```",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 37,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "767a64d5a4473d9eb2a7f4d1a0b2ca0d52c04a88",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Build-Check",
        "description": {
          "value": "Builds OK on all architectures"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "-branch:refs/meta/config"
          }
        },
        "submittabilityExpression": {
          "expressionString": "-label:Verified\u003d-1"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"-branch:refs/meta/config"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["branch:refs/meta/config"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"-label:Verified=-1"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Verified=-1"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "767a64d5a4473d9eb2a7f4d1a0b2ca0d52c04a88",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}