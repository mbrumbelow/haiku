{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6586331d_bd382537",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-16T08:06:39Z",
      "side": 1,
      "message": "Ideally I would put a bit more info there. For example in USB we could have the vendor and device name, or data extracted from USB string descriptors.\n\nBut this can be added later, I\u0027m fine with merging this first version already ðŸ˜Š",
      "revId": "cd9c8c63fb832d3980fbe8c1cb904b2260ba2571",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be9c43a4_22ddadb0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-12-16T08:54:31Z",
      "side": 1,
      "message": "Thanks! Just pointing out coding style issues.",
      "revId": "cd9c8c63fb832d3980fbe8c1cb904b2260ba2571",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89f996c2_4b991780",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000214
      },
      "writtenOn": "2021-12-16T09:23:27Z",
      "side": 1,
      "message": "Yes, I am working on it. At least for i2c/usb we could have some ioctl B_GET_PRODUCT_ID/B_GET_VENDOR_ID. I\u0027ve already have sketched on my notes.\n\nThere are more ioctl\u0027s that come to my mind, dump report descriptor on demand (and not doing always on tmp) or USB name, as you mention. Thing is, they are usb specific, perhaps i2c too.\n\nI also have to implement B_GET_DEVICE_NAME on ps2/at input devices, so InputServer doesn\u0027t need to guess names based on device path.\n\nHave ps2/at some sort of vendor/product id?",
      "parentUuid": "6586331d_bd382537",
      "revId": "cd9c8c63fb832d3980fbe8c1cb904b2260ba2571",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c95adf3c_c8ba50b2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-16T10:23:09Z",
      "side": 1,
      "message": "In the case of PS/2, there isn\u0027t an unified vendor/product ID as is the case for USB. Instead, the device type is detected by sending various commands and checking how the device handles them. Currently we know about:\n- IBM/Lenovo trackpoint for Thinkpad laptops\n- Synaptics touchpad\n- Mouse implementing the extended Microsoft or Logitech (I don\u0027t remember who invented it) to support 3 buttons and a scroll wheel\n- Work in progress for ALPS and ELAN touchpads (but I think the drivers are not complete?)\n- Everything else is used a standard 2 button PS/2 mouse\n\nThe approach is a bit different from HID:\n- The PS2 device just represents the PS/2 mouse port, independant of whatever is connected to it,\n- Then there is a PS2 bus manager, which is responsible for detecting devices\n- The PS2 bus manager detects the device type using \"probe\" functions like https://git.haiku-os.org/haiku/tree/src/add-ons/kernel/bus_managers/ps2/ps2_trackpoint.cpp#n35\n- The device types are hardcoded in the bus manager and the probing functions called in order (https://git.haiku-os.org/haiku/tree/src/add-ons/kernel/bus_managers/ps2/ps2_dev.cpp) - We could modify this to have fully separate drivers for each PS/2 device, but it is probably not worth the effort\n- Eventually each PS2 device node can have a different ioctl hook (for example for synaptics: https://git.haiku-os.org/haiku/tree/src/add-ons/kernel/bus_managers/ps2/ps2_synaptics.cpp#n607) and the hook can simply be hardcoded to handle the ioctl and return a different name for each device type.",
      "parentUuid": "89f996c2_4b991780",
      "revId": "cd9c8c63fb832d3980fbe8c1cb904b2260ba2571",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81bde68f_ee93b7f5",
        "filename": "src/add-ons/kernel/drivers/input/hid_shared/JoystickProtocolHandler.cpp",
        "patchSetId": 1
      },
      "lineNbr": 273,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-12-16T08:54:31Z",
      "side": 1,
      "message": "Space after comma, here and at other places.",
      "revId": "cd9c8c63fb832d3980fbe8c1cb904b2260ba2571",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db70bd0e_fcfdc330",
        "filename": "src/add-ons/kernel/drivers/input/hid_shared/ProtocolHandler.cpp",
        "patchSetId": 1
      },
      "lineNbr": 197,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-12-16T08:54:31Z",
      "side": 1,
      "message": "Superfluous curly braces.",
      "revId": "cd9c8c63fb832d3980fbe8c1cb904b2260ba2571",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52162731_88673100",
        "filename": "src/add-ons/kernel/drivers/input/hid_shared/ProtocolHandler.cpp",
        "patchSetId": 1
      },
      "lineNbr": 203,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-12-16T08:54:31Z",
      "side": 1,
      "message": "Why not directly return B_OK?",
      "revId": "cd9c8c63fb832d3980fbe8c1cb904b2260ba2571",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}