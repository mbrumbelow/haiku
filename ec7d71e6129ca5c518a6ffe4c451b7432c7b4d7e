{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "94e4e60e_95f2eafe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2021-12-19T09:08:31Z",
      "side": 1,
      "message": "Added some responses to previous comments.",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b17ba79_dd8cc736",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000038
      },
      "writtenOn": "2021-12-19T21:49:27Z",
      "side": 1,
      "message": "Nice error classes, but can you make a stack of errors?",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ec57937_87d2eabe",
        "filename": "docs/user/netservices/ErrorsExt.dox",
        "patchSetId": 5
      },
      "lineNbr": 8,
      "author": {
        "id": 1000038
      },
      "writtenOn": "2021-12-19T21:49:27Z",
      "side": 1,
      "message": "Nice classes, but not quite what I was hoping for in a more modern Error capture system.  It\u0027s missing the nesting of errors, or can you put these objects into a stack?\n\nI\u0027d start with a basic kernel C system and build the convenience access classes on that.  The basic system is limited by the bottleneck of having to store the data in a dead thread status record, which is of fixed size (currently holds the final status code and a few other things).  I\u0027d just add a fixed size string (say one or two 4K pages long), which given that a typical Haiku system has around 300 threads, with 8K per string, that\u0027s 2400K, or 2.4 megabytes.\n\nThe kernel level system just sees it as a string associated with a thread.  The error reporting layer on top sees it as lines and fields.  A typical format would be to have the location of the error (program/library and subroutine names, maybe line numbers too, colon separated), a tab character, and a Human readable explanation of the error (possibly including related values, like a web server address in a failed connection), and a line feed at the end.  To keep it stack-like, higher levels append their explanatory line to the existing thread error string.\n\nThe usual kernel functions for retrieving the final status code can be extended to also get the error string.  Same for getting the error string of a running thread, appending to it (truncated with \"...\" when the fixed size limit is reached), and clearing it.\n\nThen you can build your fancy error object system on this, to expand the string into a stack of error objects, display them in a list view, etc.",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}