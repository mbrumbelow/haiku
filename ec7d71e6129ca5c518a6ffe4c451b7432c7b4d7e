{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "94e4e60e_95f2eafe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2021-12-19T09:08:31Z",
      "side": 1,
      "message": "Added some responses to previous comments.",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b17ba79_dd8cc736",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000038
      },
      "writtenOn": "2021-12-19T21:49:27Z",
      "side": 1,
      "message": "Nice error classes, but can you make a stack of errors?",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e63576c9_9475f467",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2021-12-22T08:13:49Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "8b17ba79_dd8cc736",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "219570d3_f4583cca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2021-12-22T08:13:49Z",
      "side": 1,
      "message": "I hope I have answered all considerations in the threads. We will have the opportunity to discuss this more in the future, as this kit is WIP.",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ff65166_1a87dea8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000038
      },
      "writtenOn": "2022-01-04T13:39:39Z",
      "side": 1,
      "message": "More comments about why nested errors are good and arguments for doing an error message stack in the kernel.",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d92049a_930f0dca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2023-06-27T19:10:02Z",
      "side": 1,
      "message": "Resolve the unresolved comments (sorry, Gerrit hygiene)",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b2a316d9_dca4229b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2023-06-27T19:10:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7ff65166_1a87dea8",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ec57937_87d2eabe",
        "filename": "docs/user/netservices/ErrorsExt.dox",
        "patchSetId": 5
      },
      "lineNbr": 8,
      "author": {
        "id": 1000038
      },
      "writtenOn": "2021-12-19T21:49:27Z",
      "side": 1,
      "message": "Nice classes, but not quite what I was hoping for in a more modern Error capture system.  It\u0027s missing the nesting of errors, or can you put these objects into a stack?\n\nI\u0027d start with a basic kernel C system and build the convenience access classes on that.  The basic system is limited by the bottleneck of having to store the data in a dead thread status record, which is of fixed size (currently holds the final status code and a few other things).  I\u0027d just add a fixed size string (say one or two 4K pages long), which given that a typical Haiku system has around 300 threads, with 8K per string, that\u0027s 2400K, or 2.4 megabytes.\n\nThe kernel level system just sees it as a string associated with a thread.  The error reporting layer on top sees it as lines and fields.  A typical format would be to have the location of the error (program/library and subroutine names, maybe line numbers too, colon separated), a tab character, and a Human readable explanation of the error (possibly including related values, like a web server address in a failed connection), and a line feed at the end.  To keep it stack-like, higher levels append their explanatory line to the existing thread error string.\n\nThe usual kernel functions for retrieving the final status code can be extended to also get the error string.  Same for getting the error string of a running thread, appending to it (truncated with \"...\" when the fixed size limit is reached), and clearing it.\n\nThen you can build your fancy error object system on this, to expand the string into a stack of error objects, display them in a list view, etc.",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "482b2173_f3f4ce47",
        "filename": "docs/user/netservices/ErrorsExt.dox",
        "patchSetId": 5
      },
      "lineNbr": 8,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2021-12-20T08:52:42Z",
      "side": 1,
      "message": "I get what you are aiming for, but I am struggling to find the use cases that it would really work for, other than the incidental bug report of weird bugs where it might shine a light on something that was not known before.\n\nI think the general principle of exceptions, namely the fact that they can wind up the stack until they are handled (or until the program terminates) is a feature, not a nuisance. For example, I do not think it is necessary that every call to a function that can throw an exception should be wrapped by a try/catch (...) statement, so that a layer of additional errors can be added. The example I have, is that a complex API like the package kit does not necessarily have to catch and rethrow all file system related errors; they can just be unwinded up the stack.\n\nThere are two exceptions IMO:\n- I think there are cases where unexpected errors are caught and then repackaged as a BRuntimeError. I might be open to the fact that BRuntimeErrors may contain a pointer to a previous exception. For example, the BHttpSession object tries to create threads and semaphores, and those fail. The original failure would be caught as a BSystemError, and this would be wrapped in a BRuntimeError that explains that there was an unexpected failure.\n- A different case is where there is a list of errors in sequential operations, where individual steps may fail, but they do not cancel the execution of the entire chain. For examples in parsers of file types that can recover from errors. We would introduce a BErrorList type for that. But this is distinct for the case you make above.\n\nCould you share your use cases of extending the stacked errors to other situations?",
      "parentUuid": "7ec57937_87d2eabe",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "edb4c670_92808efa",
        "filename": "docs/user/netservices/ErrorsExt.dox",
        "patchSetId": 5
      },
      "lineNbr": 8,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2021-12-22T08:13:49Z",
      "side": 1,
      "message": "I suggest we continue the discussion on stacked errors and error handling as this kit takes shape. As you can see, the BError class currently lives in libnetservices.a so there is time for discussion and testing before it lands in libbe.so.",
      "parentUuid": "482b2173_f3f4ce47",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc3c023b_0b069bf4",
        "filename": "docs/user/netservices/ErrorsExt.dox",
        "patchSetId": 5
      },
      "lineNbr": 8,
      "author": {
        "id": 1000038
      },
      "writtenOn": "2022-01-04T13:39:39Z",
      "side": 1,
      "message": "Inheriting from a nested exception class would let you do the stack of errors using your new BError class.  Something like https://www.cplusplus.com/reference/exception/nested_exception/ would work.  If we\u0027re going to use exceptions, could you make that part of your standard?  Admittedly, your point about not stacking everything is good.  But as a use case, it\u0027s nice to know that something failed because it couldn\u0027t load a library and that failed because it couldn\u0027t download a file and that failed because it couldn\u0027t find a server (server name included in a message that is earlier in the stack, and clues about why it failed - DNS lookup or Server down etc).\n\nI like the OS based one, where it stores the stack of error messages in a concatenated simple string.  The kernel error string also works for non C++ languages!  So you can use C, Python or whatever and still have a standard way of reporting errors.  That\u0027s a big plus.  Also, if some C++ library software layer absorbs exceptions, you can still see a kernel error string.\n\nIt\u0027s also convenient to have an OS provided way of getting the string to display to the user.  Though if you have stock library code for that (a default alert box or print to console), the OS error system won\u0027t be as important.\n\nHow well would exceptions work for threads that die?  How would they get the main application thread to display their exception?  Having the stackish error string in the kernel as part of the tombstone data would avoid that problem.\n\nYou could also mix your BError class with the kernel method, storing just the error code in your class and appending the message string to the kernel\u0027s concatenated error string.   Best of both worlds!",
      "parentUuid": "edb4c670_92808efa",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ee60a873_b2a685d9",
        "filename": "docs/user/netservices/ErrorsExt.dox",
        "patchSetId": 5
      },
      "lineNbr": 8,
      "author": {
        "id": 1000012
      },
      "writtenOn": "2023-06-27T19:10:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fc3c023b_0b069bf4",
      "revId": "ec7d71e6129ca5c518a6ffe4c451b7432c7b4d7e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}