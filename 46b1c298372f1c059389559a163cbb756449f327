{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9b2aba4b_f88772cd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-07-23T19:37:35Z",
      "side": 1,
      "message": "Do we need both? We could switch entirely to gnu_hash and remove the older DT_HASH section completely. This should solve the size increase issue.",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28362699_1720febe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2024-07-23T19:43:29Z",
      "side": 1,
      "message": "This makes impossible to run software built for new Haiku versions on older Haiku versions.\n\nAlso it is impossible to get dynamic symbol table size without DT_HASH entry. GNU hash have no symbol count. Some software need this.",
      "parentUuid": "9b2aba4b_f88772cd",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd195545_d8a49b37",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-07-23T19:45:33Z",
      "side": 1,
      "message": "The gnu_hash sections are larger no matter what, it appears. And it sounds like the size of the DT_HASH is the only reliable way to detect how many symbols are in a file without iterating over all of them...? Or at least I did see that said.",
      "parentUuid": "9b2aba4b_f88772cd",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f41f1ce_aac75018",
        "filename": "headers/os/kernel/elf.h",
        "patchSetId": 2
      },
      "lineNbr": 547,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-18T16:11:07Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define DT_GNU_HASH 0x6ffffef5 /* GNU-style hash table */\n```",
      "range": {
        "startLine": 547,
        "startChar": 0,
        "endLine": 547,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5246802_0237cca9",
        "filename": "headers/private/runtime_loader/runtime_loader.h",
        "patchSetId": 2
      },
      "lineNbr": 112,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-18T16:11:07Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tuint32 num_needed;\n\tstruct image_t** needed;\n```",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 112,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b691f3f_ba92baa6",
        "filename": "headers/private/runtime_loader/runtime_loader.h",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-18T16:11:07Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tuint32* gnuhash;\n```",
      "range": {
        "startLine": 118,
        "startChar": 0,
        "endLine": 118,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e98ef89_8903f544",
        "filename": "headers/private/runtime_loader/runtime_loader.h",
        "patchSetId": 2
      },
      "lineNbr": 146,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-18T16:11:07Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tunsigned dso_tls_id;\n```",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 146,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a3a64295_b61e003f",
        "filename": "src/system/runtime_loader/elf_load_image.cpp",
        "patchSetId": 2
      },
      "lineNbr": 326,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-18T16:11:07Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t\t\timage-\u003egnuhash \u003d (uint32*)(d[i].d_un.d_ptr + image-\u003eregions[0].delta);\n```",
      "range": {
        "startLine": 325,
        "startChar": 0,
        "endLine": 326,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9a47c7a_87c777f2",
        "filename": "src/system/runtime_loader/elf_symbol_lookup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 221,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-07-23T19:37:35Z",
      "side": 1,
      "message": "rather than storing the \"raw\" gnuhash section, could the image_t structure instead store the already decoded members? (maskWordsCount, shift2, ...). This would make this function a bit simpler and maybe help the optimizer improve it?\n\nIn particular, it may be interesting to convert the bucketCount to a mask if it is a power of 2, to avoid a modulo operation. But also the pointers to buckets and chain0 can be precomputed once per image, instead of once per symbol lookup.",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75c7fbc1_98f98637",
        "filename": "src/system/runtime_loader/elf_symbol_lookup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 273,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2024-07-19T15:49:08Z",
      "side": 1,
      "message": "Are there any guarantees that has can never be zero? If not, some flag would be needed instead.",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ac09b4d_5cba3cf4",
        "filename": "src/system/runtime_loader/elf_symbol_lookup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 273,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-07-23T19:37:35Z",
      "side": 1,
      "message": "I see nothing that prevents the hash function from generating a 0 (or any other value). So this would cause any symbol with a hash of 0 (still quite unlikely) to be recomputed each time find_symbol is called?\n\nAlso, I\u0027m not sure this wins us a lot, computing the hash is a one-time operation for each symbol and the strings are not that long. And it will end up being computed as soon as we hit a library with that type of hash anyways.\n\nSo, maybe always precompute the gnu_hash at init of SymbolLookup, and only compute the old hash if we find a library that doesn\u0027t yet have a gnu_hash section?",
      "parentUuid": "75c7fbc1_98f98637",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2057aa7_4d4c7d06",
        "filename": "src/system/runtime_loader/elf_symbol_lookup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 273,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-07-23T19:45:33Z",
      "side": 1,
      "message": "Avoiding computing hashes when unnecessary made a noticeable difference in my testing (not a large one but still noticeable.) I didn\u0027t record what the numers were however.\n\nWe can probably use some other value or flag if it\u0027s indeed possible to get a hash of 0, but I don\u0027t see how that\u0027d be possible if symbol names are ASCII?",
      "parentUuid": "6ac09b4d_5cba3cf4",
      "revId": "46b1c298372f1c059389559a163cbb756449f327",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}