{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8c5af182_576b8ca0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-12T09:08:24Z",
      "side": 1,
      "message": "FindInt64 gives us alignment issues on arm because BMessage is packed.\n\nAs AddData uses memcpy to store fields in the BMessage structure, probably we can use memcpy also in FindXYZ functions for fetching data.",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b3eac59_9181524e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-03-12T10:28:10Z",
      "side": 1,
      "message": "Can you update conmit message with this info?\nSomeone looking at code later could benefit from this.",
      "parentUuid": "8c5af182_576b8ca0",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5b84d54f_2ea267f5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-03-12T10:28:10Z",
      "side": 1,
      "message": "(In the long run removing memcpy would be good, but not part of this PR..)",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05eab8a6_2bc5e3c9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-03-12T10:35:39Z",
      "side": 1,
      "message": "Why not part of this PR?\n\nYou can reuse the \u0027Unaligned\u0027 struct template that is currently in src/add-ons/kernel/file_systems/bfs/BPlusTree.h\n\nThis declares an unaligned integer and lets the compiler generate appropriate code. It\u0027s better than using memcpy, because on architectures where unaligned accesses are allowed, there will be no performance cost.\n\nWhere should we move this template, probably somewhere in headers/private?\n\nThe change would then be quite simple, replace:\n\n\n    type* ptr;\n    \n    \nWith:\n\n    Unaligned\u003ctype\u003e* ptr;\n\nand let the compiler figure out how to perform the copy.",
      "parentUuid": "5b84d54f_2ea267f5",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3394854_4fd2c429",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-03-12T10:51:59Z",
      "side": 1,
      "message": "I meant the AddData case. Sorry for the confusion.",
      "parentUuid": "05eab8a6_2bc5e3c9",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d8c4635_6b3e9813",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-12T11:01:52Z",
      "side": 1,
      "message": "Ah yes that\u0027s a good suggestion, I\u0027ll use the Unaligned template then.",
      "parentUuid": "f3394854_4fd2c429",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c4ae2fb9_168e7a9f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-12T11:33:08Z",
      "side": 1,
      "message": "well this needs some more investigation, I\u0027m getting warnings/error like this:\n\n error: ignoring packed attribute because of unpacked non-POD field \u0027BPoint Unaligned\u003cBPoint\u003e::value\u0027",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3b15931_38d4f0df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-03-12T12:55:29Z",
      "side": 1,
      "message": "ah, yes, Unaligned will only work for primitive types. But then, memcpy isn\u0027t really safe either in that case (at least in theory, but I think in practise using it on a BPoint should be fine?)",
      "parentUuid": "c4ae2fb9_168e7a9f",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16b725f2_9c091d37",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-12T20:00:02Z",
      "side": 1,
      "message": "the problematic types are BPoint, BRect, BSize, rgb_color because they have user-defined assignment operator (as we can also see it in the CI output)\n\nEven though they really behave like POD so there should not be a problem from memcpy\u0027ing them. (as they are copied with memcpy in AddData already but there gcc doesn\u0027t complain because the type info is discarded)",
      "parentUuid": "d3b15931_38d4f0df",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "36da289f_0e5fd3c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-03-16T19:20:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4b3eac59_9181524e",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bef414b2_7f86de6f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-03-18T07:02:36Z",
      "side": 1,
      "message": "The issue with using memcpy is that it makes the code slower on architectures where it is not needed. This is what led to the development of the Unaligned class in BFS, it lets the compiler know that the data is not aligned, and then the compiler can decide if that matters for the current architecture.\n\nOn x86 it will still use a 32 or 64bit memory access, on ARM it will go byte by byte. On the other hand, memcpy will always copy byte by byte and/or cost an extra function call. Especially in this case, the \"bytes\" count is retrieved from FindData, and so there will be no optimization of the memcpy to a fixed size copy since the size will not be known at compile time.\n\nI think the best solution here is to have two variants of DEFINE_FUNCTIONS for primitive types (using Unaligned\u003ctype\u003e* ptr) and for non-primitive ones (possibly using memcpy, or ideally manually declaring packed-misaligned versions of the involved structures for this usage).\n\nOr, if memcpy is the correct way to go, we should check that the generated code is identical to what it was before, or that it is faster.",
      "parentUuid": "16b725f2_9c091d37",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b01727eb_cac749dd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-21T20:51:34Z",
      "side": 1,
      "message": "Looking at the commit history it turns out that this code was converted from memcpy to assignment operator in hrev53160.\n\nWe can use Unaligned\u003ctype\u003e for the primitive types but I\u0027m still not entirely sure about the structs.\n\nPerhaps we can use a template specialization like this?\n\n template \u003ctypename Type, bool Enable \u003d std::is_trivial\u003cType\u003e::value\u003e\n struct MaybeUnaligned : public Type {\n };\n template \u003ctypename Type\u003e\n struct MaybeUnaligned\u003cType, true\u003e : public Unaligned\u003cType\u003e {\n };",
      "parentUuid": "bef414b2_7f86de6f",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f89fec0_ff3ca986",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-03-21T21:19:39Z",
      "side": 1,
      "message": "That would require C++11 (for std::is_trivial) and this code is still built with gcc2.\n\nAnd (if I understand what you try to do with it), it would also not solve the problem: it removes the compilation error, but the code generated to copy these structures will still fail if the structure in the BMessage data is not aligned as expected by the compiler.\n\nWe really need to tell the compiler \"there are two (possibly) unaligned floats here, copy them to this BPoint class in the x and y fields\". Then the compiler can do the right thing.\n\nI see no way of doing this in a fully generic way for use in a macro as we have now? So we may need to manually write the function for each case if we don\u0027t have any other solution.\n\nWhat we would need is a way to declare something like:\n\n    struct UnalignedBPoint {\n        Unaligned\u003cfloat\u003e x;\n        Unaligned\u003cfloat\u003e y;\n    };\n    \n(or maybe an even simpler \"float[2]\")\n \nAnd then define an operator\u003d that allows to assign a BPoint from that structure. And I\u0027m not even sure anymore this is going to be faster than a memcpy then?\n\nI think at a minimum the memcpy() should have a constant parameter (sizeof(type)) instead of using \"bytes\", at least it would let the compiler decide that this is a small memcpy and inline it. Maybe that\u0027s good enough?\n\nIt seems like we should set up some tests in compiler explorer to see how it generates different cases. And also check with gcc2 if it optimizes that reasonably as well.",
      "parentUuid": "b01727eb_cac749dd",
      "revId": "898beeb068b71a2d589e1e80f16fb51fdfe6272b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}