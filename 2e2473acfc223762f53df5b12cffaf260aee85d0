{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9807b520_fc4a1a37",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-11-27T17:02:46Z",
      "side": 1,
      "message": "Mm, if there are odd cases like NFS, or actually NTFS with case-sensitivity turned on per-directory, then is there really value to this? I think the check in Tracker could just be adjusted to check the case of the existing file and whether it\u0027s different from the one that tried to be copied, and show the warning message in that case (saying \"target directory\" instead of \"target filesystem\".)",
      "revId": "2e2473acfc223762f53df5b12cffaf260aee85d0",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11465971_f10cf418",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000366
      },
      "writtenOn": "2024-11-29T16:46:10Z",
      "side": 1,
      "message": "Please see patch set 2.  The reason for manually iterating through entry_refs is that in testing I found that other options e.g. BDirectory::FindEntry did not reliably find the existing file.  When creation of two files is attempted at almost the same time, the vnode of the first file might not have been published yet when CopyFile is handling the second file.",
      "parentUuid": "9807b520_fc4a1a37",
      "revId": "2e2473acfc223762f53df5b12cffaf260aee85d0",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad5fbc2a_83c037f9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-11-29T21:30:47Z",
      "side": 1,
      "message": "That doesn\u0027t make sense. The vnode doesn\u0027t need to be published in order to find it, because if it doesn\u0027t exist the VFS will just call lookup() on the filesystem; and if the filesystem already created a node with that name, lookup() should return its ID. There shouldn\u0027t be any races here, because the FS lookup() call should of course lock the directory it\u0027s doing the lookup in. Doing a double-iteration sounds very expensive, a single stat() on the path should suffice.",
      "parentUuid": "11465971_f10cf418",
      "revId": "2e2473acfc223762f53df5b12cffaf260aee85d0",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "39ec5f9a_92fb8016",
        "filename": "headers/os/kernel/fs_info.h",
        "patchSetId": 1
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-11-27T15:46:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define B_FS_IS_READONLY 0x00000001\n#define B_FS_IS_REMOVABLE 0x00000002\n#define B_FS_IS_PERSISTENT 0x00000004\n#define B_FS_IS_SHARED 0x00000008\n#define B_FS_IS_CASE_INSENSITIVE 0x00000010\n```",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "2e2473acfc223762f53df5b12cffaf260aee85d0",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cb08d464_b8297653",
        "filename": "headers/os/kernel/fs_info.h",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-11-27T15:46:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define B_FS_HAS_MIME 0x00010000\n#define B_FS_HAS_ATTR 0x00020000\n#define B_FS_HAS_QUERY 0x00040000\n```",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 20,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "2e2473acfc223762f53df5b12cffaf260aee85d0",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81651d5a_9951fbf9",
        "filename": "headers/private/fs_shell/fssh_fs_info.h",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-11-27T15:46:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define B_FS_IS_CASE_INSENSITIVE 0x00000010\n```",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 17,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "2e2473acfc223762f53df5b12cffaf260aee85d0",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d322fc2d_5f79beff",
        "filename": "src/kits/tracker/FSUtils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1323,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-11-27T15:46:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t\tif ((destInfo.flags \u0026 B_FS_IS_CASE_INSENSITIVE) !\u003d 0) {\n```",
      "range": {
        "startLine": 1323,
        "startChar": 0,
        "endLine": 1323,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "2e2473acfc223762f53df5b12cffaf260aee85d0",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}