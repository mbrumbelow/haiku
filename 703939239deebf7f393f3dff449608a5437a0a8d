{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "743fc8d4_5a8fe092",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-07-16T16:04:01Z",
      "side": 1,
      "message": "This looks like a very inefficient way to do this.\n\nInstead of adding a new filtering mechanism to PoseView, I think that BRefFilter should suffice here.\n\nAnd then instead of a list that\u0027s iterated over with string comparisons, a HashSet containing all the directory inodes should be used, and then the entry_ref\u0027s parent directory can just be tested against the HashSet of used directories.\n\nThe logic around adding/removing/saving/loading directory filters also looks like it could be consolidated/trimmed, but I didn\u0027t look at it too closely, nor the UI related changes.",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c56a9cae_e406a723",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000644
      },
      "writtenOn": "2024-07-16T16:27:20Z",
      "side": 1,
      "message": "It completely skipped my mind that I could use a hash table for this. Will definitely fix that. Keeping with that line of thought, should I instead use an unordered_set since it also offers an average lookup of O(1), since we just need to do an existence check?\n\nI\u0027ll also replace the filter part of QueryPoseView with a BRefFilter instead.",
      "parentUuid": "743fc8d4_5a8fe092",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28bbcddf_51d70cf6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-07-16T16:29:35Z",
      "side": 1,
      "message": "Tracker still is compiled with GCC2 on 32-bit x86 so we can\u0027t use unordered_set here. The home-grown HashSet\u003c\u003e is what I\u0027d suggest you use, it should have similar behavior.",
      "parentUuid": "c56a9cae_e406a723",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1372dead_ea34c1e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000644
      },
      "writtenOn": "2024-07-17T12:44:26Z",
      "side": 1,
      "message": "I switched out the QueryPoseView.cpp code to use the HashSet with they HashKey64 for the ino_t wrapper. Since the same kind of functionality is also present on the FindPanel.cpp level, I will switch it there as well. I will definitely keep it in mind to try and apply Data Structures and Algorithms a bit more carefully. I haven\u0027t delved too much into that section of my CS prep :awkward_smile ðŸ˜Š but will definitely try.",
      "parentUuid": "28bbcddf_51d70cf6",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f464a0cc_c3c90c03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000644
      },
      "writtenOn": "2024-07-17T14:07:54Z",
      "side": 1,
      "message": "I also wanted to ask about recursive searches. It seems that using HashSet lookups might not be the best method for recursive searches. I reviewed both my previous method and the current HashSet implementation, and also examined the source code for creating a BPath from an entry_ref. Hereâ€™s what I discovered:\n\nIn the BPath constructor, it constructs a BPath object from an entry_ref by utilizing the SetTo function. Initially, SetTo unsets the current instance of the BPath object before calling _kern_entry_ref_to_path, which then invokes the get_path function.\n\nThe get_path function creates a node_ref using the entry_ref\u0027s device and directory values. It then calls another overloaded get_path function, passing the node_ref, the leaf name, and a reference to the return string. This function searches for the node_ref in a HashMap, retrieves the corresponding directory path, and copies it into the return string.\n\nSince these steps involve a set number of operations, and paths are usually not very long, we can consider the entire process of creating a BPath from an entry_ref as an O(1) operation.\n\nConsidering the HashSet implementation, it only supports immediate directory content searches. For subdirectory searches, we would need to either include all subdirectory inodes in the HashSet or loop through each parent directory recursively up to the filesystem root. This means the HashSet method can only search one level deep. However, with the BPath method, we can create the BPath, get the character array, and perform direct comparisons, allowing for efficient checks for both immediate results and recursive searches. This is my understanding, but I wanted to confirm if it\u0027s correct.\n\nSo in this case which method should I go for? In most cases (i\u0027d say a very high %), queries wouldn\u0027t be having more than a few filters. Even if, say we take, 20 folder filters, it would still be more efficient than recursively searching up from the file level to the directory levels. Adding all subdirectories into the HashSet could also be inefficient right?\n\nAlso I\u0027ll try and fix the build-failure on the gcc build.",
      "parentUuid": "1372dead_ea34c1e9",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0f796d6_8526fdd9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-07-17T14:46:22Z",
      "side": 1,
      "message": "The operation is certainly not O(1).\n\nI think it makes the most sense to just add all directories to the HashSet\u003c\u003e recursively. (Note that if querying across multiple volumes we\u0027ll need to also add the volume_id too.)\n\nThanks for switching to HashSet\u003c\u003e in the first place; what about using BRefFilter instead of adding this new filtering mechanism though?",
      "parentUuid": "f464a0cc_c3c90c03",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "584f03dd_6115bd77",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000644
      },
      "writtenOn": "2024-07-17T14:48:29Z",
      "side": 1,
      "message": "Yup I will change that to the BRefFilter as well. I was just wanting to check whether I implemented the HashSet version of this fine. I will bundle both the BRefFilter change and the Recursive search filter in the next commit.\n\nThanks for letting me know about the O() thing. I\u0027m still relatively new to that so I guess I did it wrong :)",
      "parentUuid": "f0f796d6_8526fdd9",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ab32ba3_8b8b807a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-07-17T14:49:43Z",
      "side": 1,
      "message": "The operation may be fast, but since it has to behave differently for different paths, it\u0027s definitely not constant-time.",
      "parentUuid": "584f03dd_6115bd77",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38e3029b_0e856530",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000644
      },
      "writtenOn": "2024-07-17T14:56:55Z",
      "side": 1,
      "message": "Oh right! The copying of the BPath depends on the length of the path string and that itself wouldn\u0027t be constant time. Anyways, I\u0027ll be recursively adding everything to",
      "parentUuid": "0ab32ba3_8b8b807a",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21083c5d_2ebbeaaa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000644
      },
      "writtenOn": "2024-07-17T14:57:59Z",
      "side": 1,
      "message": "Everything to the list and doing the lookups. Thanks for the heads up waddlesplash. On that note, I will also spend some of my free time learning my DSA fundamentals a bit more clearly :)",
      "parentUuid": "38e3029b_0e856530",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c7a729a1_6148cd23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000644
      },
      "writtenOn": "2024-07-26T23:05:26Z",
      "side": 1,
      "message": "Followed all the suggestions mentioned in this review.",
      "parentUuid": "21083c5d_2ebbeaaa",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7c0a5829_2a69f059",
        "filename": "src/kits/tracker/FindPanel.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1098,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-16T15:54:57Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 1098,
        "startChar": 0,
        "endLine": 1098,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "251fd132_94312adb",
        "filename": "src/kits/tracker/FindPanel.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1109,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-16T15:54:57Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// we must manage the memory of entry_refs stored in fDirectoryFilters manually!\n```",
      "range": {
        "startLine": 1109,
        "startChar": 0,
        "endLine": 1109,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aebc4f11_cd56dcd3",
        "filename": "src/kits/tracker/FindPanel.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-16T15:54:57Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \u003cView.h\u003e\n```",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 40,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "991f3f05_5e37edc8",
        "filename": "src/kits/tracker/FindPanel.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-16T15:54:57Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "348b5ad7_a5f9e663",
        "filename": "src/kits/tracker/QueryPoseView.cpp",
        "patchSetId": 4
      },
      "lineNbr": 87,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-07-16T15:54:57Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// we are managing memory manually!\n```",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 87,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "703939239deebf7f393f3dff449608a5437a0a8d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}