{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "aa161bf3_5d1eb04c",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 281,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-06T19:39:35Z",
      "side": 1,
      "message": "This may not always be long enough, characters near the end of the UCS2 range (close to FFFF) might need 3 bytes).",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de45b4b8_d733d6df",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 281,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2022-01-08T03:25:07Z",
      "side": 1,
      "message": "Do we really not have any APIs for \"allocate me a buffer and convert this string to a specified encoding\"? I looked around and couldn\u0027t see a way to do this.\n\nHow should I deal with this? Actually check during the byteswap whether the characters are out of 2-byte range?",
      "parentUuid": "aa161bf3_5d1eb04c",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0eaa83e_dfad2a6a",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 281,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-01-12T12:40:59Z",
      "side": 1,
      "message": "We don\u0027t have one yet.\n\nICU has ucnv_convert, which we could use directly here, or wrap into a BeAPI style thing: https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/ucnv_8h.html#ab281edb8941c4f19786c786f0d1e6d10\n\nIt returns the needed output size.\n\nSo this would be (omitting error checking):\n\nUErrorCode errorCode \u003d 0;\nsize_t neededSize \u003d ucnv_convert(\"utf-8\", \"utf-16\", NULL, 0, input, inputLength, errorCode);\nvoid* output \u003d malloc(neededSize);\nucnv_convert(\"utf-8\", \"utf-16\", output, neededSize, input, inputLength, errorCode);\n\nBy using the proper encoding names you can maybe get this function to do the endian-swapping for you.\n\nThis is not very efficient because each call to ucnv_convert creates two converters (from input to utf16, then from utf16 to output) and closes them at the end. By calling lower level functions directly (ucnv_open, ucnv_toUnicode, ucnv_fromUnicode) it may be possible to open and close the converters only once.\n\nThis API should also be used to implement libtextencoding, that would remove our dependency on libiconv (the ucnv and iconv APIs are quite similar).",
      "parentUuid": "de45b4b8_d733d6df",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e70c8471_a95b37d4",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 285,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-06T19:39:35Z",
      "side": 1,
      "message": "Is it UCS-2, or UTF-16? The latter would allow characters to be decomposed as two 16-bit words (working similar to UTF8), while UCS-2 can only encode unicode chars 0000 to FFFF.\n\nWhich one is used in USB?",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82312218_a8756275",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 285,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2021-12-06T19:50:38Z",
      "side": 1,
      "message": "The things I found seemed to indicate UCS-2.",
      "parentUuid": "e70c8471_a95b37d4",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7aca39db_49b848bf",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 285,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-06T20:02:28Z",
      "side": 1,
      "message": "Ok. No emoji in usb descriptors then ðŸ˜ž",
      "parentUuid": "82312218_a8756275",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dc7648c_d4a9905c",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-06T19:39:35Z",
      "side": 1,
      "message": "convert_to_utf8 is known to leak memory and this is not fixable without breaking the API. It should be deprecated and not used in new code (see #976).\n\nIt should be possible to use BUnicodeChar::ToUTF8 (not very convenient here) or BTextEncoding::Decode (https://git.haiku-os.org/haiku/tree/headers/os/locale/TextEncoding.h#n34) and BTextEncoding::Flush instead.",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05b59f1f_308b45b2",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2021-12-06T19:50:38Z",
      "side": 1,
      "message": "I think that\u0027s only convert_*from*, not to? And furthermore it isn\u0027t apparent to me that it actually does leak memory.",
      "parentUuid": "0dc7648c_d4a9905c",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5858b099_671223db",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-06T20:02:28Z",
      "side": 1,
      "message": "Right, currently it doesn\u0027t (iconv_close is called at the end). You can get into problem if calling it with an odd number of bytes (the last byte won\u0027t be used).\n\nIn any case I\u0027d prefer we generally move to BTextEncoding which is usable in more cases (you can do a stream conversion, adding bytes as you receive them), and uses ICU. Currently convert_to/from_utf8 is implemented on top of iconv and that\u0027s one dependency we should get rid of.\n\nBut this can probably be solved by rewriting the functions to use BTextEncoding. It probably means moving a few things around from libbe to libtextencoding, however.",
      "parentUuid": "05b59f1f_308b45b2",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1856652f_55baf8c2",
        "filename": "src/kits/device/USBDevice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-12-11T14:17:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5858b099_671223db",
      "revId": "9085b743afad99ae8655ec46e8b8dc050f64fbb7",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}