{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f166ce84_50dcecf0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-02-12T23:07:32Z",
      "side": 1,
      "message": "Reserved memory after boot, hoard2: ~300MB, openbsd: ~330MB, mimalloc: ~1GB.\n\nHowever, pages used is the same or lower, and pages used is much lower with applications like web browsers that use a lot of memory. So this does seem worth looking into, I suppose. Some of my glue code from the OpenBSD malloc may be helpful here.",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "daad067e_8cc9f769",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-02-12T23:07:43Z",
      "side": 1,
      "message": "I will see about looking into this.",
      "parentUuid": "f166ce84_50dcecf0",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4131f0d7_fdd812ce",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-aligned.c",
        "patchSetId": 7
      },
      "lineNbr": 12,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \"mimalloc/prim.h\" // mi_prim_get_default_heap\n\n#include \u003cstring.h\u003e // memset\n```",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d48d4568_d440ccf9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-aligned.c",
        "patchSetId": 7
      },
      "lineNbr": 89,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_noinline void*\nmi_heap_malloc_zero_aligned_at_fallback(mi_heap_t* const heap, const size_t size,\n\tconst size_t alignment, const size_t offset, const bool zero) mi_attr_noexcept\n{\n\tmi_assert_internal(size \u003c\u003d PTRDIFF_MAX);\n\tmi_assert_internal(alignment !\u003d 0 \u0026\u0026 _mi_is_power_of_two(alignment));\n\n\tconst uintptr_t align_mask \u003d alignment - 1; // for any x, `(x \u0026 align_mask) \u003d\u003d (x % alignment)`\n\tconst size_t padsize \u003d size + MI_PADDING_SIZE;\n\n\t// use regular allocation if it is guaranteed to fit the alignment constraints\n\tif (offset \u003d\u003d 0 \u0026\u0026 alignment \u003c\u003d padsize \u0026\u0026 padsize \u003c\u003d MI_MAX_ALIGN_GUARANTEE\n\t\t\u0026\u0026 (padsize \u0026 align_mask) \u003d\u003d 0) {\n\t\tvoid* p \u003d _mi_heap_malloc_zero(heap, size, zero);\n\t\tmi_assert_internal(p \u003d\u003d NULL || ((uintptr_t)p % alignment) \u003d\u003d 0);\n\t\treturn p;\n\t}\n\n\tvoid* p;\n\tsize_t oversize;\n\tif mi_unlikely (alignment \u003e MI_ALIGNMENT_MAX) {\n\t\t// use OS allocation for very large alignment and allocate inside a huge page (dedicated\n\t\t// segment with 1 page) This can support alignments \u003e\u003d MI_SEGMENT_SIZE by ensuring the\n\t\t// object can be aligned at a point in the first (and single) page such that the segment\n\t\t// info is `MI_SEGMENT_SIZE` bytes before it (so it can be found by aligning the pointer\n\t\t// down)\n\t\tif mi_unlikely (offset !\u003d 0) {\n// todo: cannot support offset alignment for very large alignments yet\n#if MI_DEBUG \u003e 0\n\t\t\t_mi_error_message(EOVERFLOW,\n\t\t\t\t\"aligned allocation with a very large alignment cannot be used with an alignment \"\n\t\t\t\t\"offset (size %zu, alignment %zu, offset %zu)\\n\",\n\t\t\t\tsize, alignment, offset);\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\toversize \u003d (size \u003c\u003d MI_SMALL_SIZE_MAX\n\t\t\t\t? MI_SMALL_SIZE_MAX + 1 /* ensure we use generic malloc path */\n\t\t\t\t: size);\n\t\tp \u003d _mi_heap_malloc_zero_ex(heap, oversize, false,\n\t\t\talignment); // the page block size should be large enough to align in the single huge\n\t\t\t\t\t\t// page block\n\t\t// zero afterwards as only the area from the aligned_p may be committed!\n\t\tif (p \u003d\u003d NULL)\n\t\t\treturn NULL;\n\t} else {\n\t\t// otherwise over-allocate\n\t\toversize \u003d size + alignment - 1;\n\t\tp \u003d _mi_heap_malloc_zero(heap, oversize, zero);\n\t\tif (p \u003d\u003d NULL)\n\t\t\treturn NULL;\n\t}\n\n\t// .. and align within the allocation\n\tconst uintptr_t poffset \u003d ((uintptr_t)p + offset) \u0026 align_mask;\n\tconst uintptr_t adjust \u003d (poffset \u003d\u003d 0 ? 0 : alignment - poffset);\n\tmi_assert_internal(adjust \u003c alignment);\n\tvoid* aligned_p \u003d (void*)((uintptr_t)p + adjust);\n\tif (aligned_p !\u003d p) {\n\t\tmi_page_t* page \u003d _mi_ptr_page(p);\n\t\tmi_page_set_has_aligned(page, true);\n\t\t_mi_padding_shrink(page, (mi_block_t*)p, adjust + size);\n\t}\n\t// todo: expand padding if overallocated ?\n\n\tmi_assert_internal(mi_page_usable_block_size(_mi_ptr_page(p)) \u003e\u003d adjust + size);\n\tmi_assert_internal(\n\t\tp \u003d\u003d _mi_page_ptr_unalign(_mi_ptr_segment(aligned_p), _mi_ptr_page(aligned_p), aligned_p));\n\tmi_assert_internal(((uintptr_t)aligned_p + offset) % alignment \u003d\u003d 0);\n\tmi_assert_internal(mi_usable_size(aligned_p) \u003e\u003d size);\n\tmi_assert_internal(mi_usable_size(p) \u003d\u003d mi_usable_size(aligned_p) + adjust);\n\n\t// now zero the block if needed\n\tif (alignment \u003e MI_ALIGNMENT_MAX) {\n\t\t// for the tracker, on huge aligned allocations only from the start of the large block is\n\t\t// defined\n\t\tmi_track_mem_undefined(aligned_p, size);\n\t\tif (zero)\n\t\t\t_mi_memzero_aligned(aligned_p, mi_usable_size(aligned_p));\n\t}\n\n\tif (p !\u003d aligned_p)\n\t\tmi_track_align(p, aligned_p, adjust, mi_usable_size(aligned_p));\n\treturn aligned_p;\n```",
      "range": {
        "startLine": 19,
        "startChar": 0,
        "endLine": 89,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9837662c_179320a5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-aligned.c",
        "patchSetId": 7
      },
      "lineNbr": 129,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void*\nmi_heap_malloc_zero_aligned_at(mi_heap_t* const heap, const size_t size, const size_t alignment,\n\tconst size_t offset, const bool zero) mi_attr_noexcept\n{\n\t// note: we don\u0027t require `size \u003e offset`, we just guarantee that the address at offset is\n\t// aligned regardless of the allocated size.\n\tif mi_unlikely (alignment \u003d\u003d 0\n\t\t|| !_mi_is_power_of_two(\n\t\t\talignment)) { // require power-of-two (see\n\t\t\t\t\t\t  // \u003chttps://en.cppreference.com/w/c/memory/aligned_alloc\u003e)\n#if MI_DEBUG \u003e 0\n\t\t_mi_error_message(EOVERFLOW,\n\t\t\t\"aligned allocation requires the alignment to be a power-of-two (size %zu, alignment \"\n\t\t\t\"%zu)\\n\",\n\t\t\tsize, alignment);\n#endif\n\t\treturn NULL;\n\t}\n\n\tif mi_unlikely (size\n\t\t\u003e PTRDIFF_MAX) { // we don\u0027t allocate more than PTRDIFF_MAX (see\n\t\t\t\t\t\t // \u003chttps://sourceware.org/ml/libc-announce/2019/msg00001.html\u003e)\n#if MI_DEBUG \u003e 0\n\t\t_mi_error_message(EOVERFLOW,\n\t\t\t\"aligned allocation request is too large (size %zu, alignment %zu)\\n\", size, alignment);\n#endif\n\t\treturn NULL;\n\t}\n\tconst uintptr_t align_mask \u003d alignment - 1; // for any x, `(x \u0026 align_mask) \u003d\u003d (x % alignment)`\n\tconst size_t padsize\n\t\t\u003d size + MI_PADDING_SIZE; // note: cannot overflow due to earlier size \u003e PTRDIFF_MAX check\n\n\t// try first if there happens to be a small block available with just the right alignment\n\tif mi_likely (padsize \u003c\u003d MI_SMALL_SIZE_MAX \u0026\u0026 alignment \u003c\u003d padsize) {\n\t\tmi_page_t* page \u003d _mi_heap_get_free_small_page(heap, padsize);\n\t\tconst bool is_aligned \u003d (((uintptr_t)page-\u003efree + offset) \u0026 align_mask) \u003d\u003d 0;\n\t\tif mi_likely (page-\u003efree !\u003d NULL \u0026\u0026 is_aligned) {\n#if MI_STAT \u003e 1\n\t\t\tmi_heap_stat_increase(heap, malloc, size);\n#endif\n\t\t\tvoid* p \u003d _mi_page_malloc(heap, page, padsize, zero); // TODO: inline _mi_page_malloc\n\t\t\tmi_assert_internal(p !\u003d NULL);\n\t\t\tmi_assert_internal(((uintptr_t)p + offset) % alignment \u003d\u003d 0);\n\t\t\tmi_track_malloc(p, size, zero);\n\t\t\treturn p;\n\t\t}\n\t}\n\t// fallback\n\treturn mi_heap_malloc_zero_aligned_at_fallback(heap, size, alignment, offset, zero);\n```",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12c89ceb_23b9b148",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-aligned.c",
        "patchSetId": 7
      },
      "lineNbr": 157,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_malloc_aligned_at(mi_heap_t* heap, size_t size, size_t alignment,\n\tsize_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_malloc_zero_aligned_at(heap, size, alignment, offset, false);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_malloc_aligned(mi_heap_t* heap, size_t size, size_t alignment) mi_attr_noexcept\n{\n\tif mi_unlikely (alignment \u003d\u003d 0 || !_mi_is_power_of_two(alignment))\n\t\treturn NULL;\n#if !MI_PADDING\n\t// without padding, any small sized allocation is naturally aligned (see also\n\t// `_mi_segment_page_start`)\n\tif mi_likely (_mi_is_power_of_two(size) \u0026\u0026 size \u003e\u003d alignment \u0026\u0026 size \u003c\u003d MI_SMALL_SIZE_MAX)\n#else\n\t// with padding, we can only guarantee this for fixed alignments\n\tif mi_likely ((alignment \u003d\u003d sizeof(void*)\n\t\t\t\t\t  || (alignment \u003d\u003d MI_MAX_ALIGN_SIZE \u0026\u0026 size \u003e (MI_MAX_ALIGN_SIZE / 2)))\n\t\t\u0026\u0026 size \u003c\u003d MI_SMALL_SIZE_MAX)\n#endif\n\t{\n\t\t// fast path for common alignment and size\n\t\treturn mi_heap_malloc_small(heap, size);\n\t} else {\n\t\treturn mi_heap_malloc_aligned_at(heap, size, alignment, 0);\n\t}\n```",
      "range": {
        "startLine": 137,
        "startChar": 0,
        "endLine": 157,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9fc62f1_2cc020ce",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-aligned.c",
        "patchSetId": 7
      },
      "lineNbr": 208,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_zalloc_aligned_at(mi_heap_t* heap, size_t size, size_t alignment,\n\tsize_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_malloc_zero_aligned_at(heap, size, alignment, offset, true);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_zalloc_aligned(mi_heap_t* heap, size_t size, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_zalloc_aligned_at(heap, size, alignment, 0);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_calloc_aligned_at(mi_heap_t* heap, size_t count, size_t size, size_t alignment,\n\tsize_t offset) mi_attr_noexcept\n{\n\tsize_t total;\n\tif (mi_count_size_overflow(count, size, \u0026total))\n\t\treturn NULL;\n\treturn mi_heap_zalloc_aligned_at(heap, total, alignment, offset);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_calloc_aligned(mi_heap_t* heap, size_t count, size_t size,\n\tsize_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_calloc_aligned_at(heap, count, size, alignment, 0);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_malloc_aligned_at(size_t size, size_t alignment, size_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_malloc_aligned_at(mi_prim_get_default_heap(), size, alignment, offset);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_malloc_aligned(size_t size, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_malloc_aligned(mi_prim_get_default_heap(), size, alignment);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_zalloc_aligned_at(size_t size, size_t alignment, size_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_zalloc_aligned_at(mi_prim_get_default_heap(), size, alignment, offset);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_zalloc_aligned(size_t size, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_zalloc_aligned(mi_prim_get_default_heap(), size, alignment);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_calloc_aligned_at(size_t count, size_t size, size_t alignment, size_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_calloc_aligned_at(mi_prim_get_default_heap(), count, size, alignment, offset);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_calloc_aligned(size_t count, size_t size, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_calloc_aligned(mi_prim_get_default_heap(), count, size, alignment);\n```",
      "range": {
        "startLine": 169,
        "startChar": 0,
        "endLine": 208,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7357d29_a7e40330",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-aligned.c",
        "patchSetId": 7
      },
      "lineNbr": 298,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void*\nmi_heap_realloc_zero_aligned_at(mi_heap_t* heap, void* p, size_t newsize, size_t alignment,\n\tsize_t offset, bool zero) mi_attr_noexcept\n{\n\tmi_assert(alignment \u003e 0);\n\tif (alignment \u003c\u003d sizeof(uintptr_t))\n\t\treturn _mi_heap_realloc_zero(heap, p, newsize, zero);\n\tif (p \u003d\u003d NULL)\n\t\treturn mi_heap_malloc_zero_aligned_at(heap, newsize, alignment, offset, zero);\n\tsize_t size \u003d mi_usable_size(p);\n\tif (newsize \u003c\u003d size \u0026\u0026 newsize \u003e\u003d (size - (size / 2))\n\t\t\u0026\u0026 (((uintptr_t)p + offset) % alignment) \u003d\u003d 0) {\n\t\treturn p; // reallocation still fits, is aligned and not more than 50% waste\n\t} else {\n\t\t// note: we don\u0027t zero allocate upfront so we only zero initialize the expanded part\n\t\tvoid* newp \u003d mi_heap_malloc_aligned_at(heap, newsize, alignment, offset);\n\t\tif (newp !\u003d NULL) {\n\t\t\tif (zero \u0026\u0026 newsize \u003e size) {\n\t\t\t\t// also set last word in the previous allocation to zero to ensure any padding is\n\t\t\t\t// zero-initialized\n\t\t\t\tsize_t start \u003d (size \u003e\u003d sizeof(intptr_t) ? size - sizeof(intptr_t) : 0);\n\t\t\t\t_mi_memzero((uint8_t*)newp + start, newsize - start);\n\t\t\t}\n\t\t\t_mi_memcpy_aligned(newp, p, (newsize \u003e size ? size : newsize));\n\t\t\tmi_free(p); // only free if successful\n\t\t}\n\t\treturn newp;\n\t}\n}\n\n\nstatic void*\nmi_heap_realloc_zero_aligned(mi_heap_t* heap, void* p, size_t newsize, size_t alignment,\n\tbool zero) mi_attr_noexcept\n{\n\tmi_assert(alignment \u003e 0);\n\tif (alignment \u003c\u003d sizeof(uintptr_t))\n\t\treturn _mi_heap_realloc_zero(heap, p, newsize, zero);\n\tsize_t offset \u003d ((uintptr_t)p % alignment); // use offset of previous allocation (p can be NULL)\n\treturn mi_heap_realloc_zero_aligned_at(heap, p, newsize, alignment, offset, zero);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_realloc_aligned_at(mi_heap_t* heap, void* p, size_t newsize, size_t alignment,\n\tsize_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_realloc_zero_aligned_at(heap, p, newsize, alignment, offset, false);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_realloc_aligned(mi_heap_t* heap, void* p, size_t newsize, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_realloc_zero_aligned(heap, p, newsize, alignment, false);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_rezalloc_aligned_at(mi_heap_t* heap, void* p, size_t newsize, size_t alignment,\n\tsize_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_realloc_zero_aligned_at(heap, p, newsize, alignment, offset, true);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_rezalloc_aligned(mi_heap_t* heap, void* p, size_t newsize,\n\tsize_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_realloc_zero_aligned(heap, p, newsize, alignment, true);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_recalloc_aligned_at(mi_heap_t* heap, void* p, size_t newcount, size_t size,\n\tsize_t alignment, size_t offset) mi_attr_noexcept\n{\n\tsize_t total;\n\tif (mi_count_size_overflow(newcount, size, \u0026total))\n\t\treturn NULL;\n\treturn mi_heap_rezalloc_aligned_at(heap, p, total, alignment, offset);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_recalloc_aligned(mi_heap_t* heap, void* p, size_t newcount, size_t size,\n\tsize_t alignment) mi_attr_noexcept\n{\n\tsize_t total;\n\tif (mi_count_size_overflow(newcount, size, \u0026total))\n\t\treturn NULL;\n\treturn mi_heap_rezalloc_aligned(heap, p, total, alignment);\n}\n\n\nmi_decl_nodiscard void*\nmi_realloc_aligned_at(void* p, size_t newsize, size_t alignment, size_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_realloc_aligned_at(mi_prim_get_default_heap(), p, newsize, alignment, offset);\n}\n\n\nmi_decl_nodiscard void*\nmi_realloc_aligned(void* p, size_t newsize, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_realloc_aligned(mi_prim_get_default_heap(), p, newsize, alignment);\n}\n\n\nmi_decl_nodiscard void*\nmi_rezalloc_aligned_at(void* p, size_t newsize, size_t alignment, size_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_rezalloc_aligned_at(mi_prim_get_default_heap(), p, newsize, alignment, offset);\n}\n\n\nmi_decl_nodiscard void*\nmi_rezalloc_aligned(void* p, size_t newsize, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_rezalloc_aligned(mi_prim_get_default_heap(), p, newsize, alignment);\n}\n\n\nmi_decl_nodiscard void*\nmi_recalloc_aligned_at(void* p, size_t newcount, size_t size, size_t alignment,\n\tsize_t offset) mi_attr_noexcept\n{\n\treturn mi_heap_recalloc_aligned_at(mi_prim_get_default_heap(), p, newcount, size, alignment,\n\t\toffset);\n}\n\n\nmi_decl_nodiscard void*\nmi_recalloc_aligned(void* p, size_t newcount, size_t size, size_t alignment) mi_attr_noexcept\n{\n\treturn mi_heap_recalloc_aligned(mi_prim_get_default_heap(), p, newcount, size, alignment);\n}\n```",
      "range": {
        "startLine": 216,
        "startChar": 0,
        "endLine": 298,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b06804ee_512568ed",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_externc void vfree(void* p);\n```",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 20,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26d1433a_69ff13fe",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 26,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef struct mi_nothrow_s {\n\tint _tag;\n} mi_nothrow_t;\n```",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 26,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "78196a19_74604931",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// gcc, clang: use aliasing to alias the exported function to one of our `mi_` functions\n#if (defined(__GNUC__) \u0026\u0026 __GNUC__ \u003e\u003d 9)\n#pragma GCC diagnostic ignored \\\n\t\"-Wattributes\" // or we get warnings that nodiscard is ignored on a forward\n#define MI_FORWARD(fun) __attribute__((alias(#fun), used, visibility(\"default\"), copy(fun)));\n```",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 44,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9915c9bf_61616bcc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 51,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_FORWARD(fun) __attribute__((alias(#fun), used, visibility(\"default\")));\n#endif\n#define MI_FORWARD1(fun, x) MI_FORWARD(fun)\n#define MI_FORWARD2(fun, x, y) MI_FORWARD(fun)\n#define MI_FORWARD3(fun, x, y, z) MI_FORWARD(fun)\n#define MI_FORWARD0(fun, x) MI_FORWARD(fun)\n#define MI_FORWARD02(fun, x, y) MI_FORWARD(fun)\n#else\n// otherwise use forwarding by calling our `mi_` function\n#define MI_FORWARD1(fun, x) \\\n\t{ \\\n\t\treturn fun(x); \\\n\t}\n#define MI_FORWARD2(fun, x, y) \\\n\t{ \\\n\t\treturn fun(x, y); \\\n\t}\n#define MI_FORWARD3(fun, x, y, z) \\\n\t{ \\\n\t\treturn fun(x, y, z); \\\n\t}\n#define MI_FORWARD0(fun, x) \\\n\t{ \\\n\t\tfun(x); \\\n\t}\n#define MI_FORWARD02(fun, x, y) \\\n\t{ \\\n\t\tfun(x, y); \\\n\t}\n```",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 51,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c32822de_4cdc2657",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 125,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// define MI_OSX_IS_INTERPOSED as we should not provide forwarding definitions for\n// functions that are interposed (or the interposing does not work)\n#define MI_OSX_IS_INTERPOSED\n\n\nmi_decl_externc size_t\nmi_malloc_size_checked(void* p)\n{\n\tif (!mi_is_in_heap_region(p))\n\t\treturn 0;\n\treturn mi_usable_size(p);\n}\n\n// use interposing so `DYLD_INSERT_LIBRARIES` works without `DYLD_FORCE_FLAT_NAMESPACE\u003d1`\n// See: \u003chttps://books.google.com/books?id\u003dK8vUkpOXhN4C\u0026pg\u003dPA73\u003e\nstruct mi_interpose_s {\n\tconst void* replacement;\n\tconst void* target;\n};\n#define MI_INTERPOSE_FUN(oldfun, newfun) \\\n\t{ \\\n\t\t(const void*)\u0026newfun, (const void*)\u0026oldfun \\\n\t}\n#define MI_INTERPOSE_MI(fun) MI_INTERPOSE_FUN(fun, mi_##fun)\n\n__attribute__((used)) static struct mi_interpose_s _mi_interposes[]\n\t__attribute__((section(\"__DATA, __interpose\")))\n\t\u003d {\n\t\tMI_INTERPOSE_MI(malloc),\n\t\tMI_INTERPOSE_MI(calloc),\n\t\tMI_INTERPOSE_MI(realloc),\n\t\tMI_INTERPOSE_MI(strdup),\n\t\tMI_INTERPOSE_MI(strndup),\n\t\tMI_INTERPOSE_MI(realpath),\n\t\tMI_INTERPOSE_MI(posix_memalign),\n\t\tMI_INTERPOSE_MI(reallocf),\n\t\tMI_INTERPOSE_MI(valloc),\n\t\tMI_INTERPOSE_FUN(malloc_size, mi_malloc_size_checked),\n\t\tMI_INTERPOSE_MI(malloc_good_size),\n#if defined(MAC_OS_X_VERSION_10_15) \u0026\u0026 MAC_OS_X_VERSION_MAX_ALLOWED \u003e\u003d MAC_OS_X_VERSION_10_15\n\t\tMI_INTERPOSE_MI(aligned_alloc),\n#endif\n#ifdef MI_OSX_ZONE\n\t\t// we interpose malloc_default_zone in alloc-override-osx.c so we can use mi_free safely\n\t\tMI_INTERPOSE_MI(free),\n\t\tMI_INTERPOSE_FUN(vfree, mi_free),\n#else\n\t\t// sometimes code allocates from default zone but deallocates using plain free :-( (like\n\t\t// NxHashResizeToCapacity\n\t\t// \u003chttps://github.com/nneonneo/osx-10.9-opensource/blob/master/objc4-551.1/runtime/hashtable2.mm\u003e)\n\t\tMI_INTERPOSE_FUN(free, mi_cfree), // use safe free that checks if pointers are from us\n\t\tMI_INTERPOSE_FUN(vfree, mi_cfree),\n#endif\n};\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\tvoid _ZdlPv(void* p); // delete\n\tvoid _ZdaPv(void* p); // delete[]\n\tvoid _ZdlPvm(void* p, size_t n); // delete\n\tvoid _ZdaPvm(void* p, size_t n); // delete[]\n\tvoid* _Znwm(size_t n); // new\n\tvoid* _Znam(size_t n); // new[]\n\tvoid* _ZnwmRKSt9nothrow_t(size_t n, mi_nothrow_t tag); // new nothrow\n\tvoid* _ZnamRKSt9nothrow_t(size_t n, mi_nothrow_t tag); // new[] nothrow\n#ifdef __cplusplus\n}\n#endif\n__attribute__((used)) static struct mi_interpose_s _mi_cxx_interposes[]\n\t__attribute__((section(\"__DATA, __interpose\")))\n\t\u003d {\n\t\tMI_INTERPOSE_FUN(_ZdlPv, mi_free),\n\t\tMI_INTERPOSE_FUN(_ZdaPv, mi_free),\n\t\tMI_INTERPOSE_FUN(_ZdlPvm, mi_free_size),\n\t\tMI_INTERPOSE_FUN(_ZdaPvm, mi_free_size),\n\t\tMI_INTERPOSE_FUN(_Znwm, mi_new),\n\t\tMI_INTERPOSE_FUN(_Znam, mi_new),\n\t\tMI_INTERPOSE_FUN(_ZnwmRKSt9nothrow_t, mi_new_nothrow),\n\t\tMI_INTERPOSE_FUN(_ZnamRKSt9nothrow_t, mi_new_nothrow),\n};\n```",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 125,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3cda7e02_6f51831b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 129,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// cannot override malloc unless using a dll.\n// we just override new/delete which does work in a static library.\n```",
      "range": {
        "startLine": 128,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3dd62d34_4a6e9b12",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 132,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// On all other systems forward to our API\nmi_decl_export void* malloc(size_t size)              MI_FORWARD1(mi_malloc, size)\n```",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 132,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "895eb81b_2f646343",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 182,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// ------------------------------------------------------\n// With a C++ compiler we override the new/delete operators.\n// see \u003chttps://en.cppreference.com/w/cpp/memory/new/operator_new\u003e\n// ------------------------------------------------------\n#include \u003cnew\u003e\n\n#ifndef MI_OSX_IS_INTERPOSED\n\n\nvoid\noperator delete(void* p) noexcept MI_FORWARD0(mi_free, p) void\noperator delete[](void* p) noexcept MI_FORWARD0(mi_free, p)\n\n\tvoid*\n\toperator new(std::size_t n) noexcept(false) MI_FORWARD1(mi_new, n) void*\n\toperator new[](std::size_t n) noexcept(false) MI_FORWARD1(mi_new, n)\n\n\t\tvoid*\n\t\toperator new(std::size_t n, const std::nothrow_t\u0026 tag) noexcept\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_nothrow(n);\n}\n\n\nvoid*\noperator new[](std::size_t n, const std::nothrow_t\u0026 tag) noexcept\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_nothrow(n);\n}\n\n#if (__cplusplus \u003e\u003d 201402L || _MSC_VER \u003e\u003d 1916)\n\n\nvoid\noperator delete(void* p, std::size_t n) noexcept MI_FORWARD02(mi_free_size, p, n) void\noperator delete[](void* p, std::size_t n) noexcept MI_FORWARD02(mi_free_size, p, n)\n#endif\n#endif\n\n#if (__cplusplus \u003e 201402L \u0026\u0026 defined(__cpp_aligned_new)) \u0026\u0026 (!defined(__GNUC__) || (__GNUC__ \u003e 5))\n\tvoid\n\toperator delete(void* p, std::align_val_t al) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid\noperator delete[](void* p, std::align_val_t al) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid\noperator delete(void* p, std::size_t n, std::align_val_t al) noexcept\n{\n\tmi_free_size_aligned(p, n, static_cast\u003csize_t\u003e(al));\n};\n\n\nvoid\noperator delete[](void* p, std::size_t n, std::align_val_t al) noexcept\n{\n\tmi_free_size_aligned(p, n, static_cast\u003csize_t\u003e(al));\n};\n\n\nvoid\noperator delete(void* p, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid\noperator delete[](void* p, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new(std::size_t n, std::align_val_t al) noexcept(false)\n{\n\treturn mi_new_aligned(n, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new[](std::size_t n, std::align_val_t al) noexcept(false)\n{\n\treturn mi_new_aligned(n, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new(std::size_t n, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\treturn mi_new_aligned_nothrow(n, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new[](std::size_t n, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\treturn mi_new_aligned_nothrow(n, static_cast\u003csize_t\u003e(al));\n}\n#endif\n```",
      "range": {
        "startLine": 148,
        "startChar": 0,
        "endLine": 182,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63d7ed7c_5658091f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 220,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// ------------------------------------------------------\n// Override by defining the mangled C++ names of the operators (as\n// used by GCC and CLang).\n// See \u003chttps://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling\u003e\n// ------------------------------------------------------\n\nvoid\n_ZdlPv(void* p) MI_FORWARD0(mi_free, p) // delete\n\tvoid _ZdaPv(void* p) MI_FORWARD0(mi_free, p) // delete[]\n\tvoid _ZdlPvm(void* p, size_t n) MI_FORWARD02(mi_free_size, p, n) void _ZdaPvm(void* p, size_t n)\n\t\tMI_FORWARD02(mi_free_size, p, n) void _ZdlPvSt11align_val_t(void* p, size_t al)\n{\n\tmi_free_aligned(p, al);\n}\n\n\nvoid\n_ZdaPvSt11align_val_t(void* p, size_t al)\n{\n\tmi_free_aligned(p, al);\n}\n\n\nvoid\n_ZdlPvmSt11align_val_t(void* p, size_t n, size_t al)\n{\n\tmi_free_size_aligned(p, n, al);\n}\n\n\nvoid\n_ZdaPvmSt11align_val_t(void* p, size_t n, size_t al)\n{\n\tmi_free_size_aligned(p, n, al);\n}\n\n#if (MI_INTPTR_SIZE \u003d\u003d 8)\n\n\nvoid*\n_Znwm(size_t n) MI_FORWARD1(mi_new, n) // new 64-bit\n\tvoid* _Znam(size_t n) MI_FORWARD1(mi_new, n) // new[] 64-bit\n\tvoid* _ZnwmRKSt9nothrow_t(size_t n, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_nothrow(n);\n}\n\n\nvoid*\n_ZnamRKSt9nothrow_t(size_t n, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_nothrow(n);\n}\n\n\nvoid*\n_ZnwmSt11align_val_t(size_t n, size_t al)\n\tMI_FORWARD2(mi_new_aligned, n, al) void* _ZnamSt11align_val_t(size_t n, size_t al)\n\t\tMI_FORWARD2(mi_new_aligned, n, al) void* _ZnwmSt11align_val_tRKSt9nothrow_t(size_t n,\n\t\t\tsize_t al, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_aligned_nothrow(n, al);\n}\n\n\nvoid*\n_ZnamSt11align_val_tRKSt9nothrow_t(size_t n, size_t al, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_aligned_nothrow(n, al);\n}\n#elif (MI_INTPTR_SIZE \u003d\u003d 4)\n\n\nvoid*\n_Znwj(size_t n) MI_FORWARD1(mi_new, n) // new 64-bit\n\tvoid* _Znaj(size_t n) MI_FORWARD1(mi_new, n) // new[] 64-bit\n\tvoid* _ZnwjRKSt9nothrow_t(size_t n, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_nothrow(n);\n}\n\n\nvoid*\n_ZnajRKSt9nothrow_t(size_t n, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_nothrow(n);\n}\n\n\nvoid*\n_ZnwjSt11align_val_t(size_t n, size_t al)\n\tMI_FORWARD2(mi_new_aligned, n, al) void* _ZnajSt11align_val_t(size_t n, size_t al)\n\t\tMI_FORWARD2(mi_new_aligned, n, al) void* _ZnwjSt11align_val_tRKSt9nothrow_t(size_t n,\n\t\t\tsize_t al, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_aligned_nothrow(n, al);\n}\n\n\nvoid*\n_ZnajSt11align_val_tRKSt9nothrow_t(size_t n, size_t al, mi_nothrow_t tag)\n{\n\tMI_UNUSED(tag);\n\treturn mi_new_aligned_nothrow(n, al);\n}\n#else\n#error \"define overloads for new/delete for this platform (just for performance, can be skipped)\"\n#endif\n```",
      "range": {
        "startLine": 185,
        "startChar": 0,
        "endLine": 220,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ba20672d_9be61a37",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 228,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\"\n{\n```",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 228,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df05529b_1564ad01",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 265,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// Forward Posix/Unix calls as well\n\tvoid* reallocf(void* p, size_t newsize) MI_FORWARD2(mi_reallocf, p, newsize) size_t\n\t\tmalloc_size(const void* p) MI_FORWARD1(mi_usable_size, p)\n#if !defined(__ANDROID__) \u0026\u0026 !defined(__FreeBSD__)\n\t\t\tsize_t malloc_usable_size(void* p) MI_FORWARD1(mi_usable_size, p)\n#else\n\t\t\tsize_t malloc_usable_size(const void* p) MI_FORWARD1(mi_usable_size, p)\n#endif\n\n\t\t// No forwarding here due to aliasing/name mangling issues\n\t\tvoid* valloc(size_t size)\n\t{\n\t\treturn mi_valloc(size);\n\t}\n\tvoid vfree(void* p)\n\t{\n\t\tmi_free(p);\n\t}\n\tsize_t malloc_good_size(size_t size)\n\t{\n\t\treturn mi_malloc_good_size(size);\n\t}\n\tint posix_memalign(void** p, size_t alignment, size_t size)\n\t{\n\t\treturn mi_posix_memalign(p, alignment, size);\n\t}\n\n// `aligned_alloc` is only available when __USE_ISOC11 is defined.\n// Note: it seems __USE_ISOC11 is not defined in musl (and perhaps other libc\u0027s) so we only check\n// for it if using glibc.\n// Note: Conda has a custom glibc where `aligned_alloc` is declared `static inline` and we cannot\n// override it, but both _ISOC11_SOURCE and __USE_ISOC11 are undefined in Conda GCC7 or GCC9.\n// Fortunately, in the case where `aligned_alloc` is declared as `static inline` it\n// uses internally `memalign`, `posix_memalign`, or `_aligned_malloc` so we  can avoid overriding it\n// ourselves.\n#if !defined(__GLIBC__) || __USE_ISOC11\n\tvoid* aligned_alloc(size_t alignment, size_t size)\n\t{\n\t\treturn mi_aligned_alloc(alignment, size);\n\t}\n#endif\n#endif\n\n\t// no forwarding here due to aliasing/name mangling issues\n\tvoid cfree(void* p)\n\t{\n\t\tmi_free(p);\n\t}\n\tvoid* pvalloc(size_t size)\n\t{\n\t\treturn mi_pvalloc(size);\n\t}\n\tvoid* reallocarray(void* p, size_t count, size_t size)\n\t{\n\t\treturn mi_reallocarray(p, count, size);\n\t}\n\tint reallocarr(void* p, size_t count, size_t size)\n\t{\n\t\treturn mi_reallocarr(p, count, size);\n\t}\n\tvoid* memalign(size_t alignment, size_t size)\n\t{\n\t\treturn mi_memalign(alignment, size);\n\t}\n\tvoid* _aligned_malloc(size_t alignment, size_t size)\n\t{\n\t\treturn mi_aligned_alloc(alignment, size);\n\t}\n```",
      "range": {
        "startLine": 232,
        "startChar": 0,
        "endLine": 265,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52bd74ee_22118d1c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 273,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// forward __libc interface (see PR #667)\n\tvoid* __libc_malloc(size_t size)\n\t\tMI_FORWARD1(mi_malloc, size) void* __libc_calloc(size_t count, size_t size)\n\t\t\tMI_FORWARD2(mi_calloc, count, size) void* __libc_realloc(void* p, size_t size)\n\t\t\t\tMI_FORWARD2(mi_realloc, p, size) void __libc_free(void* p)\n\t\t\t\t\tMI_FORWARD0(mi_free, p) void* __libc_memalign(size_t alignment, size_t size)\n\t{\n\t\treturn mi_memalign(alignment, size);\n\t}\n```",
      "range": {
        "startLine": 268,
        "startChar": 0,
        "endLine": 273,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8549c60_76de95bb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-override.c",
        "patchSetId": 7
      },
      "lineNbr": 286,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// forward __libc interface (needed for glibc-based Linux distributions)\nvoid*\n__libc_malloc(size_t size)\n\tMI_FORWARD1(mi_malloc, size) void* __libc_calloc(size_t count, size_t size)\n\t\tMI_FORWARD2(mi_calloc, count, size) void* __libc_realloc(void* p, size_t size)\n\t\t\tMI_FORWARD2(mi_realloc, p, size) void __libc_free(void* p)\n\t\t\t\tMI_FORWARD0(mi_free, p) void __libc_cfree(void* p) MI_FORWARD0(mi_free, p)\n\n\t\t\t\t\tvoid* __libc_valloc(size_t size)\n{\n\treturn mi_valloc(size);\n}\n\n\nvoid*\n__libc_pvalloc(size_t size)\n{\n\treturn mi_pvalloc(size);\n}\n\n\nvoid*\n__libc_memalign(size_t alignment, size_t size)\n{\n\treturn mi_memalign(alignment, size);\n}\n\n\nint\n__posix_memalign(void** p, size_t alignment, size_t size)\n{\n\treturn mi_posix_memalign(p, alignment, size);\n}\n```",
      "range": {
        "startLine": 276,
        "startChar": 0,
        "endLine": 286,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f094cb1f_7bfa5921",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-posix.c",
        "patchSetId": 7
      },
      "lineNbr": 21,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cstdlib.h\u003e // getenv\n#include \u003cstring.h\u003e // memset\n```",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 21,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c7f2912_c150b763",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-posix.c",
        "patchSetId": 7
      },
      "lineNbr": 24,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#pragma warning(disable : 4996) // getenv _wgetenv\n```",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 24,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af078791_cf6802b6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-posix.c",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard size_t\nmi_malloc_size(const void* p) mi_attr_noexcept\n{\n\t// if (!mi_is_in_heap_region(p)) return 0;\n\treturn mi_usable_size(p);\n}\n\n\nmi_decl_nodiscard size_t\nmi_malloc_usable_size(const void* p) mi_attr_noexcept\n{\n\t// if (!mi_is_in_heap_region(p)) return 0;\n\treturn mi_usable_size(p);\n}\n\n\nmi_decl_nodiscard size_t\nmi_malloc_good_size(size_t size) mi_attr_noexcept\n{\n\treturn mi_good_size(size);\n}\n\n\nvoid\nmi_cfree(void* p) mi_attr_noexcept\n{\n\tif (mi_is_in_heap_region(p))\n\t\tmi_free(p);\n}\n\n\nint\nmi_posix_memalign(void** p, size_t alignment, size_t size) mi_attr_noexcept\n{\n\t// Note: The spec dictates we should not modify `*p` on an error. (issue#27)\n\t// \u003chttp://man7.org/linux/man-pages/man3/posix_memalign.3.html\u003e\n\tif (p \u003d\u003d NULL)\n\t\treturn EINVAL;\n\tif ((alignment % sizeof(void*)) !\u003d 0)\n\t\treturn EINVAL; // natural alignment\n\t// it is also required that alignment is a power of 2 and \u003e 0; this is checked in\n\t// `mi_malloc_aligned`\n\tif (alignment \u003d\u003d 0 || !_mi_is_power_of_two(alignment))\n\t\treturn EINVAL; // not a power of 2\n\tvoid* q \u003d mi_malloc_aligned(size, alignment);\n\tif (q \u003d\u003d NULL \u0026\u0026 size !\u003d 0)\n\t\treturn ENOMEM;\n\tmi_assert_internal(((uintptr_t)q % alignment) \u003d\u003d 0);\n\t*p \u003d q;\n\treturn 0;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_memalign(size_t alignment, size_t size) mi_attr_noexcept\n{\n\tvoid* p \u003d mi_malloc_aligned(size, alignment);\n\tmi_assert_internal(((uintptr_t)p % alignment) \u003d\u003d 0);\n\treturn p;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_valloc(size_t size) mi_attr_noexcept\n{\n\treturn mi_memalign(_mi_os_page_size(), size);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_pvalloc(size_t size) mi_attr_noexcept\n{\n\tsize_t psize \u003d _mi_os_page_size();\n\tif (size \u003e\u003d SIZE_MAX - psize)\n\t\treturn NULL; // overflow\n\tsize_t asize \u003d _mi_align_up(size, psize);\n\treturn mi_malloc_aligned(asize, psize);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_aligned_alloc(size_t alignment, size_t size) mi_attr_noexcept\n{\n\t// C11 requires the size to be an integral multiple of the alignment, see\n\t// \u003chttps://en.cppreference.com/w/c/memory/aligned_alloc\u003e. unfortunately, it turns out quite\n\t// some programs pass a size that is not an integral multiple so skip this check..\n\t/* if mi_unlikely((size \u0026 (alignment - 1)) !\u003d 0) { // C11 requires alignment\u003e0 \u0026\u0026 integral\n\t  multiple, see \u003chttps://en.cppreference.com/w/c/memory/aligned_alloc\u003e #if MI_DEBUG \u003e 0\n\t\t_mi_error_message(EOVERFLOW, \"(mi_)aligned_alloc requires the size to be an integral\n\t  multiple of the alignment (size %zu, alignment %zu)\\n\", size, alignment); #endif return NULL;\n\t  }\n\t*/\n\t// C11 also requires alignment to be a power-of-two (and \u003e 0) which is checked in\n\t// mi_malloc_aligned\n\tvoid* p \u003d mi_malloc_aligned(size, alignment);\n\tmi_assert_internal(((uintptr_t)p % alignment) \u003d\u003d 0);\n\treturn p;\n}\n\n\nmi_decl_nodiscard void*\nmi_reallocarray(void* p, size_t count, size_t size) mi_attr_noexcept\n{ // BSD\n\tvoid* newp \u003d mi_reallocn(p, count, size);\n\tif (newp \u003d\u003d NULL)\n\t\terrno \u003d ENOMEM;\n\treturn newp;\n}\n\n\nmi_decl_nodiscard int\nmi_reallocarr(void* p, size_t count, size_t size) mi_attr_noexcept\n{ // NetBSD\n\tmi_assert(p !\u003d NULL);\n\tif (p \u003d\u003d NULL) {\n\t\terrno \u003d EINVAL;\n\t\treturn EINVAL;\n\t}\n\tvoid** op \u003d (void**)p;\n\tvoid* newp \u003d mi_reallocarray(*op, count, size);\n\tif mi_unlikely (newp \u003d\u003d NULL)\n\t\treturn errno;\n\t*op \u003d newp;\n\treturn 0;\n}\n\n\nvoid*\nmi__expand(void* p, size_t newsize) mi_attr_noexcept\n{ // Microsoft\n\tvoid* res \u003d mi_expand(p, newsize);\n\tif (res \u003d\u003d NULL)\n\t\terrno \u003d ENOMEM;\n\treturn res;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict unsigned short*\nmi_wcsdup(const unsigned short* s) mi_attr_noexcept\n{\n\tif (s \u003d\u003d NULL)\n\t\treturn NULL;\n\tsize_t len;\n\tfor (len \u003d 0; s[len] !\u003d 0; len++) {\n\t}\n\tsize_t size \u003d (len + 1) * sizeof(unsigned short);\n\tunsigned short* p \u003d (unsigned short*)mi_malloc(size);\n\tif (p !\u003d NULL)\n\t\t_mi_memcpy(p, s, size);\n\treturn p;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict unsigned char*\nmi_mbsdup(const unsigned char* s) mi_attr_noexcept\n{\n\treturn (unsigned char*)mi_strdup((const char*)s);\n}\n\n\nint\nmi_dupenv_s(char** buf, size_t* size, const char* name) mi_attr_noexcept\n{\n\tif (buf \u003d\u003d NULL || name \u003d\u003d NULL)\n\t\treturn EINVAL;\n\tif (size !\u003d NULL)\n\t\t*size \u003d 0;\n\tchar* p \u003d getenv(name); // mscver warning 4996\n\tif (p \u003d\u003d NULL) {\n\t\t*buf \u003d NULL;\n\t} else {\n\t\t*buf \u003d mi_strdup(p);\n\t\tif (*buf \u003d\u003d NULL)\n\t\t\treturn ENOMEM;\n\t\tif (size !\u003d NULL)\n\t\t\t*size \u003d _mi_strlen(p);\n\t}\n\treturn 0;\n}\n\n\nint\nmi_wdupenv_s(unsigned short** buf, size_t* size, const unsigned short* name) mi_attr_noexcept\n{\n\tif (buf \u003d\u003d NULL || name \u003d\u003d NULL)\n\t\treturn EINVAL;\n\tif (size !\u003d NULL)\n\t\t*size \u003d 0;\n```",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 160,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "153e87b4_1db809f9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-posix.c",
        "patchSetId": 7
      },
      "lineNbr": 164,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// not supported\n\t*buf \u003d NULL;\n\treturn EINVAL;\n```",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 164,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d0abab34_45ba9852",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc-posix.c",
        "patchSetId": 7
      },
      "lineNbr": 185,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tunsigned short* p \u003d (unsigned short*)_wgetenv((const wchar_t*)name); // msvc warning 4996\n\tif (p \u003d\u003d NULL) {\n\t\t*buf \u003d NULL;\n\t} else {\n\t\t*buf \u003d mi_wcsdup(p);\n\t\tif (*buf \u003d\u003d NULL)\n\t\t\treturn ENOMEM;\n\t\tif (size !\u003d NULL)\n\t\t\t*size \u003d wcslen((const wchar_t*)p);\n\t}\n\treturn 0;\n#endif\n}\n\n\nmi_decl_nodiscard void*\nmi_aligned_offset_recalloc(void* p, size_t newcount, size_t size, size_t alignment,\n\tsize_t offset) mi_attr_noexcept\n{ // Microsoft\n\treturn mi_recalloc_aligned_at(p, newcount, size, alignment, offset);\n}\n\n\nmi_decl_nodiscard void*\nmi_aligned_recalloc(void* p, size_t newcount, size_t size, size_t alignment) mi_attr_noexcept\n{ // Microsoft\n\treturn mi_recalloc_aligned(p, newcount, size, alignment);\n}\n```",
      "range": {
        "startLine": 166,
        "startChar": 0,
        "endLine": 185,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "804310b1_c0774375",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 8,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _DEFAULT_SOURCE // for realpath() on Linux\n```",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 8,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5e2159ef_562a3201",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 11,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 11,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2204b6d6_35f63c22",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 17,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \"mimalloc/prim.h\" // _mi_prim_thread_id()\n\n#include \u003cstdlib.h\u003e // malloc, abort\n#include \u003cstring.h\u003e // memset, strlen (for mi_strdup)\n```",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 17,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04456ec0_5cff6313",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 81,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern inline void*\n_mi_page_malloc(mi_heap_t* heap, mi_page_t* page, size_t size, bool zero) mi_attr_noexcept\n{\n\tmi_assert_internal(page-\u003exblock_size \u003d\u003d 0 || mi_page_block_size(page) \u003e\u003d size);\n\tmi_block_t* const block \u003d page-\u003efree;\n\tif mi_unlikely (block \u003d\u003d NULL)\n\t\treturn _mi_malloc_generic(heap, size, zero, 0);\n\tmi_assert_internal(block !\u003d NULL \u0026\u0026 _mi_ptr_page(block) \u003d\u003d page);\n\t// pop from the free list\n\tpage-\u003eused++;\n\tpage-\u003efree \u003d mi_block_next(page, block);\n\tmi_assert_internal(page-\u003efree \u003d\u003d NULL || _mi_ptr_page(page-\u003efree) \u003d\u003d page);\n#if MI_DEBUG \u003e 3\n\tif (page-\u003efree_is_zero)\n\t\tmi_assert_expensive(mi_mem_is_zero(block + 1, size - sizeof(*block)));\n#endif\n\n\t// allow use of the block internally\n\t// note: when tracking we need to avoid ever touching the MI_PADDING since\n\t// that is tracked by valgrind etc. as non-accessible (through the red-zone, see\n\t// `mimalloc/track.h`)\n\tmi_track_mem_undefined(block, mi_page_usable_block_size(page));\n\n\t// zero the block? note: we need to zero the full block size (issue #63)\n\tif mi_unlikely (zero) {\n\t\tmi_assert_internal(page-\u003exblock_size\n\t\t\t!\u003d 0); // do not call with zero\u0027ing for huge blocks (see _mi_malloc_generic)\n\t\tmi_assert_internal(page-\u003exblock_size \u003e\u003d MI_PADDING_SIZE);\n\t\tif (page-\u003efree_is_zero) {\n\t\t\tblock-\u003enext \u003d 0;\n\t\t\tmi_track_mem_defined(block, page-\u003exblock_size - MI_PADDING_SIZE);\n\t\t} else {\n\t\t\t_mi_memzero_aligned(block, page-\u003exblock_size - MI_PADDING_SIZE);\n\t\t}\n\t}\n\n#if (MI_DEBUG \u003e 0) \u0026\u0026 !MI_TRACK_ENABLED \u0026\u0026 !MI_TSAN\n\tif (!zero \u0026\u0026 !mi_page_is_huge(page))\n\t\tmemset(block, MI_DEBUG_UNINIT, mi_page_usable_block_size(page));\n#elif (MI_SECURE !\u003d 0)\n\tif (!zero) {\n\t\tblock-\u003enext \u003d 0;\n\t} // don\u0027t leak internal data\n#endif\n\n#if (MI_STAT \u003e 0)\n\tconst size_t bsize \u003d mi_page_usable_block_size(page);\n\tif (bsize \u003c\u003d MI_MEDIUM_OBJ_SIZE_MAX) {\n\t\tmi_heap_stat_increase(heap, normal, bsize);\n\t\tmi_heap_stat_counter_increase(heap, normal_count, 1);\n#if (MI_STAT \u003e 1)\n\t\tconst size_t bin \u003d _mi_bin(bsize);\n\t\tmi_heap_stat_increase(heap, normal_bins[bin], 1);\n#endif\n\t}\n```",
      "range": {
        "startLine": 29,
        "startChar": 0,
        "endLine": 81,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f90263a1_f114efc4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 129,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_padding_t* const padding\n\t\t\u003d (mi_padding_t*)((uint8_t*)block + mi_page_usable_block_size(page));\n\tptrdiff_t delta \u003d ((uint8_t*)padding - (uint8_t*)block - (size - MI_PADDING_SIZE));\n#if (MI_DEBUG \u003e\u003d 2)\n\tmi_assert_internal(\n\t\tdelta \u003e\u003d 0 \u0026\u0026 mi_page_usable_block_size(page) \u003e\u003d (size - MI_PADDING_SIZE + delta));\n#endif\n\tmi_track_mem_defined(padding,\n\t\tsizeof(mi_padding_t)); // note: re-enable since mi_page_usable_block_size may set noaccess\n\tpadding-\u003ecanary \u003d (uint32_t)(mi_ptr_encode(page, block, page-\u003ekeys));\n\tpadding-\u003edelta \u003d (uint32_t)(delta);\n#if MI_PADDING_CHECK\n\tif (!mi_page_is_huge(page)) {\n\t\tuint8_t* fill \u003d (uint8_t*)padding - delta;\n\t\tconst size_t maxpad\n\t\t\t\u003d (delta \u003e MI_MAX_ALIGN_SIZE ? MI_MAX_ALIGN_SIZE\n\t\t\t\t\t\t\t\t\t\t : delta); // set at most N initial padding bytes\n\t\tfor (size_t i \u003d 0; i \u003c maxpad; i++)\n\t\t\tfill[i] \u003d MI_DEBUG_PADDING;\n\t}\n#endif\n#endif\n\n\treturn block;\n}\n\n\nstatic inline mi_decl_restrict void*\nmi_heap_malloc_small_zero(mi_heap_t* heap, size_t size, bool zero) mi_attr_noexcept\n{\n\tmi_assert(heap !\u003d NULL);\n#if MI_DEBUG\n\tconst uintptr_t tid \u003d _mi_thread_id();\n\tmi_assert(heap-\u003ethread_id \u003d\u003d 0 || heap-\u003ethread_id \u003d\u003d tid); // heaps are thread local\n#endif\n\tmi_assert(size \u003c\u003d MI_SMALL_SIZE_MAX);\n#if (MI_PADDING)\n\tif (size \u003d\u003d 0)\n\t\tsize \u003d sizeof(void*);\n#endif\n\tmi_page_t* page \u003d _mi_heap_get_free_small_page(heap, size + MI_PADDING_SIZE);\n\tvoid* const p \u003d _mi_page_malloc(heap, page, size + MI_PADDING_SIZE, zero);\n\tmi_track_malloc(p, size, zero);\n#if MI_STAT \u003e 1\n\tif (p !\u003d NULL) {\n\t\tif (!mi_heap_is_initialized(heap))\n\t\t\theap \u003d mi_prim_get_default_heap();\n\t\tmi_heap_stat_increase(heap, malloc, mi_usable_size(p));\n\t}\n#endif\n#if MI_DEBUG \u003e 3\n\tif (p !\u003d NULL \u0026\u0026 zero)\n\t\tmi_assert_expensive(mi_mem_is_zero(p, size));\n#endif\n\treturn p;\n```",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c5b8c3a5_c91e31d6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 138,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard extern inline mi_decl_restrict void*\nmi_heap_malloc_small(mi_heap_t* heap, size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_malloc_small_zero(heap, size, false);\n}\n\n\nmi_decl_nodiscard extern inline mi_decl_restrict void*\nmi_malloc_small(size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_malloc_small(mi_prim_get_default_heap(), size);\n```",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 138,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17fd53d2_fed98ab0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 176,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern inline void*\n_mi_heap_malloc_zero_ex(mi_heap_t* heap, size_t size, bool zero,\n\tsize_t huge_alignment) mi_attr_noexcept\n{\n\tif mi_likely (size \u003c\u003d MI_SMALL_SIZE_MAX) {\n\t\tmi_assert_internal(huge_alignment \u003d\u003d 0);\n\t\treturn mi_heap_malloc_small_zero(heap, size, zero);\n\t} else {\n\t\tmi_assert(heap !\u003d NULL);\n\t\tmi_assert(\n\t\t\theap-\u003ethread_id \u003d\u003d 0 || heap-\u003ethread_id \u003d\u003d _mi_thread_id()); // heaps are thread local\n\t\tvoid* const p \u003d _mi_malloc_generic(heap, size + MI_PADDING_SIZE, zero,\n\t\t\thuge_alignment); // note: size can overflow but it is detected in malloc_generic\n\t\tmi_track_malloc(p, size, zero);\n#if MI_STAT \u003e 1\n\t\tif (p !\u003d NULL) {\n\t\t\tif (!mi_heap_is_initialized(heap))\n\t\t\t\theap \u003d mi_prim_get_default_heap();\n\t\t\tmi_heap_stat_increase(heap, malloc, mi_usable_size(p));\n\t\t}\n#endif\n#if MI_DEBUG \u003e 3\n\t\tif (p !\u003d NULL \u0026\u0026 zero)\n\t\t\tmi_assert_expensive(mi_mem_is_zero(p, size));\n#endif\n\t\treturn p;\n\t}\n}\n\n\nextern inline void*\n_mi_heap_malloc_zero(mi_heap_t* heap, size_t size, bool zero) mi_attr_noexcept\n{\n\treturn _mi_heap_malloc_zero_ex(heap, size, zero, 0);\n}\n\n\nmi_decl_nodiscard extern inline mi_decl_restrict void*\nmi_heap_malloc(mi_heap_t* heap, size_t size) mi_attr_noexcept\n{\n\treturn _mi_heap_malloc_zero(heap, size, false);\n}\n\n\nmi_decl_nodiscard extern inline mi_decl_restrict void*\nmi_malloc(size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_malloc(mi_prim_get_default_heap(), size);\n```",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 176,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5435bc38_6fc8efc3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 189,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard mi_decl_restrict void*\nmi_zalloc_small(size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_malloc_small_zero(mi_prim_get_default_heap(), size, true);\n}\n\n\nmi_decl_nodiscard extern inline mi_decl_restrict void*\nmi_heap_zalloc(mi_heap_t* heap, size_t size) mi_attr_noexcept\n{\n\treturn _mi_heap_malloc_zero(heap, size, true);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_zalloc(size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_zalloc(mi_prim_get_default_heap(), size);\n```",
      "range": {
        "startLine": 180,
        "startChar": 0,
        "endLine": 189,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac92d82b_4daf94ac",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 198,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_ENCODE_FREELIST \u0026\u0026 (MI_SECURE \u003e\u003d 4 || MI_DEBUG !\u003d 0))\n```",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 198,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dcb7b3ef_85890ae7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 233,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_list_contains(const mi_page_t* page, const mi_block_t* list, const mi_block_t* elem)\n{\n\twhile (list !\u003d NULL) {\n\t\tif (elem \u003d\u003d list)\n\t\t\treturn true;\n\t\tlist \u003d mi_block_next(page, list);\n\t}\n\treturn false;\n}\n\n\nstatic mi_decl_noinline bool\nmi_check_is_double_freex(const mi_page_t* page, const mi_block_t* block)\n{\n\t// The decoded value is in the same page (or NULL).\n\t// Walk the free lists to verify positively if it is already freed\n\tif (mi_list_contains(page, page-\u003efree, block) || mi_list_contains(page, page-\u003elocal_free, block)\n\t\t|| mi_list_contains(page, mi_page_thread_free(page), block)) {\n\t\t_mi_error_message(EAGAIN, \"double free detected of block %p with size %zu\\n\", block,\n\t\t\tmi_page_block_size(page));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#define mi_track_page(page, access) \\\n\t{ \\\n\t\tsize_t psize; \\\n\t\tvoid* pstart \u003d _mi_page_start(_mi_page_segment(page), page, \u0026psize); \\\n\t\tmi_track_mem_##access(pstart, psize); \\\n\t}\n\n\nstatic inline bool\nmi_check_is_double_free(const mi_page_t* page, const mi_block_t* block)\n{\n\tbool is_double_free \u003d false;\n\tmi_block_t* n \u003d mi_block_nextx(page, block,\n\t\tpage-\u003ekeys); // pretend it is freed, and get the decoded first field\n\tif (((uintptr_t)n \u0026 (MI_INTPTR_SIZE - 1)) \u003d\u003d 0 \u0026\u0026 // quick check: aligned pointer?\n\t\t(n \u003d\u003d NULL || mi_is_in_same_page(block, n))) // quick check: in same page or NULL?\n\t{\n\t\t// Suspicous: decoded value a in block is in the same page (or NULL) -- maybe a double free?\n\t\t// (continue in separate function to improve code generation)\n\t\tis_double_free \u003d mi_check_is_double_freex(page, block);\n\t}\n\treturn is_double_free;\n```",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 233,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a83ab02a_44fddf8a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 239,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline bool\nmi_check_is_double_free(const mi_page_t* page, const mi_block_t* block)\n{\n\tMI_UNUSED(page);\n\tMI_UNUSED(block);\n\treturn false;\n```",
      "range": {
        "startLine": 236,
        "startChar": 0,
        "endLine": 239,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "94bc1048_dc306dbb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 259,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic bool\nmi_page_decode_padding(const mi_page_t* page, const mi_block_t* block, size_t* delta, size_t* bsize)\n{\n\t*bsize \u003d mi_page_usable_block_size(page);\n\tconst mi_padding_t* const padding \u003d (mi_padding_t*)((uint8_t*)block + *bsize);\n\tmi_track_mem_defined(padding, sizeof(mi_padding_t));\n\t*delta \u003d padding-\u003edelta;\n\tuint32_t canary \u003d padding-\u003ecanary;\n\tuintptr_t keys[2];\n\tkeys[0] \u003d page-\u003ekeys[0];\n\tkeys[1] \u003d page-\u003ekeys[1];\n\tbool ok \u003d ((uint32_t)mi_ptr_encode(page, block, keys) \u003d\u003d canary \u0026\u0026 *delta \u003c\u003d *bsize);\n\tmi_track_mem_noaccess(padding, sizeof(mi_padding_t));\n\treturn ok;\n```",
      "range": {
        "startLine": 248,
        "startChar": 0,
        "endLine": 259,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16cea012_c3d3d963",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 268,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic size_t\nmi_page_usable_size_of(const mi_page_t* page, const mi_block_t* block)\n{\n\tsize_t bsize;\n\tsize_t delta;\n\tbool ok \u003d mi_page_decode_padding(page, block, \u0026delta, \u0026bsize);\n\tmi_assert_internal(ok);\n\tmi_assert_internal(delta \u003c\u003d bsize);\n\treturn ok ? bsize - delta : 0;\n```",
      "range": {
        "startLine": 263,
        "startChar": 0,
        "endLine": 268,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24780fa8_33f39d39",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 288,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_padding_shrink(const mi_page_t* page, const mi_block_t* block, const size_t min_size)\n{\n\tsize_t bsize;\n\tsize_t delta;\n\tbool ok \u003d mi_page_decode_padding(page, block, \u0026delta, \u0026bsize);\n\tmi_assert_internal(ok);\n\tif (!ok || (bsize - delta) \u003e\u003d min_size)\n\t\treturn; // usually already enough space\n\tmi_assert_internal(bsize \u003e\u003d min_size);\n\tif (bsize \u003c min_size)\n\t\treturn; // should never happen\n\tsize_t new_delta \u003d (bsize - min_size);\n\tmi_assert_internal(new_delta \u003c bsize);\n\tmi_padding_t* padding \u003d (mi_padding_t*)((uint8_t*)block + bsize);\n\tmi_track_mem_defined(padding, sizeof(mi_padding_t));\n\tpadding-\u003edelta \u003d (uint32_t)new_delta;\n\tmi_track_mem_noaccess(padding, sizeof(mi_padding_t));\n```",
      "range": {
        "startLine": 275,
        "startChar": 0,
        "endLine": 288,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d4276635_909fcd59",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 299,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic size_t\nmi_page_usable_size_of(const mi_page_t* page, const mi_block_t* block)\n{\n\tMI_UNUSED(block);\n\treturn mi_page_usable_block_size(page);\n}\n\n\nvoid\n_mi_padding_shrink(const mi_page_t* page, const mi_block_t* block, const size_t min_size)\n{\n\tMI_UNUSED(page);\n\tMI_UNUSED(block);\n\tMI_UNUSED(min_size);\n```",
      "range": {
        "startLine": 291,
        "startChar": 0,
        "endLine": 299,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "83596546_706d4fb0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 334,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic bool\nmi_verify_padding(const mi_page_t* page, const mi_block_t* block, size_t* size, size_t* wrong)\n{\n\tsize_t bsize;\n\tsize_t delta;\n\tbool ok \u003d mi_page_decode_padding(page, block, \u0026delta, \u0026bsize);\n\t*size \u003d *wrong \u003d bsize;\n\tif (!ok)\n\t\treturn false;\n\tmi_assert_internal(bsize \u003e\u003d delta);\n\t*size \u003d bsize - delta;\n\tif (!mi_page_is_huge(page)) {\n\t\tuint8_t* fill \u003d (uint8_t*)block + bsize - delta;\n\t\tconst size_t maxpad\n\t\t\t\u003d (delta \u003e MI_MAX_ALIGN_SIZE ? MI_MAX_ALIGN_SIZE\n\t\t\t\t\t\t\t\t\t\t : delta); // check at most the first N padding bytes\n\t\tmi_track_mem_defined(fill, maxpad);\n\t\tfor (size_t i \u003d 0; i \u003c maxpad; i++) {\n\t\t\tif (fill[i] !\u003d MI_DEBUG_PADDING) {\n\t\t\t\t*wrong \u003d bsize - delta + i;\n\t\t\t\tok \u003d false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmi_track_mem_noaccess(fill, maxpad);\n\t}\n\treturn ok;\n}\n\n\nstatic void\nmi_check_padding(const mi_page_t* page, const mi_block_t* block)\n{\n\tsize_t size;\n\tsize_t wrong;\n\tif (!mi_verify_padding(page, block, \u0026size, \u0026wrong)) {\n\t\t_mi_error_message(EFAULT,\n\t\t\t\"buffer overflow in heap block %p of size %zu: write after %zu bytes\\n\", block, size,\n\t\t\twrong);\n\t}\n```",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 334,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c96813e2_632264a8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 341,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void\nmi_check_padding(const mi_page_t* page, const mi_block_t* block)\n{\n\tMI_UNUSED(page);\n\tMI_UNUSED(block);\n```",
      "range": {
        "startLine": 339,
        "startChar": 0,
        "endLine": 341,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7260f90e_eb6f2c4a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 369,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_STAT \u003e 0)\n\n\nstatic void\nmi_stat_free(const mi_page_t* page, const mi_block_t* block)\n{\n#if (MI_STAT \u003c 2)\n\tMI_UNUSED(block);\n#endif\n\tmi_heap_t* const heap \u003d mi_heap_get_default();\n\tconst size_t bsize \u003d mi_page_usable_block_size(page);\n#if (MI_STAT \u003e 1)\n\tconst size_t usize \u003d mi_page_usable_size_of(page, block);\n\tmi_heap_stat_decrease(heap, malloc, usize);\n#endif\n\tif (bsize \u003c\u003d MI_MEDIUM_OBJ_SIZE_MAX) {\n\t\tmi_heap_stat_decrease(heap, normal, bsize);\n#if (MI_STAT \u003e 1)\n\t\tmi_heap_stat_decrease(heap, normal_bins[_mi_bin(bsize)], 1);\n#endif\n\t} else if (bsize \u003c\u003d MI_LARGE_OBJ_SIZE_MAX) {\n\t\tmi_heap_stat_decrease(heap, large, bsize);\n\t} else {\n\t\tmi_heap_stat_decrease(heap, huge, bsize);\n\t}\n```",
      "range": {
        "startLine": 347,
        "startChar": 0,
        "endLine": 369,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18c3cf73_564ba8a3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 373,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic void\nmi_stat_free(const mi_page_t* page, const mi_block_t* block)\n{\n\tMI_UNUSED(page);\n\tMI_UNUSED(block);\n```",
      "range": {
        "startLine": 372,
        "startChar": 0,
        "endLine": 373,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2cd8c28a_614a9cf1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 378,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_STAT \u003e 0)\n```",
      "range": {
        "startLine": 378,
        "startChar": 0,
        "endLine": 378,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b8d8d98_28c07a26",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 388,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_stat_huge_free(const mi_page_t* page)\n{\n\tmi_heap_t* const heap \u003d mi_heap_get_default();\n\tconst size_t bsize \u003d mi_page_block_size(page); // to match stats in `page.c:mi_page_huge_alloc`\n\tif (bsize \u003c\u003d MI_LARGE_OBJ_SIZE_MAX)\n\t\tmi_heap_stat_decrease(heap, large, bsize);\n\telse\n\t\tmi_heap_stat_decrease(heap, huge, bsize);\n```",
      "range": {
        "startLine": 380,
        "startChar": 0,
        "endLine": 388,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e874429_7337955b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 392,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic void\nmi_stat_huge_free(const mi_page_t* page)\n{\n\tMI_UNUSED(page);\n```",
      "range": {
        "startLine": 391,
        "startChar": 0,
        "endLine": 392,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95a127e4_781fe941",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 467,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_noinline void\n_mi_free_block_mt(mi_page_t* page, mi_block_t* block)\n{\n\t// The padding check may access the non-thread-owned page for the key values.\n\t// that is safe as these are constant and the page won\u0027t be freed (as the block is not freed\n\t// yet).\n\tmi_check_padding(page, block);\n\t_mi_padding_shrink(page, block,\n\t\tsizeof(mi_block_t)); // for small size, ensure we can fit the delayed thread pointers\n\t\t\t\t\t\t\t // without triggering overflow detection\n\n\t// huge page segments are always abandoned and can be freed immediately\n\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\tif (segment-\u003ekind \u003d\u003d MI_SEGMENT_HUGE) {\n#if MI_HUGE_PAGE_ABANDON\n\t\t// huge page segments are always abandoned and can be freed immediately\n\t\tmi_stat_huge_free(page);\n\t\t_mi_segment_huge_page_free(segment, page, block);\n\t\treturn;\n#else\n\t\t// huge pages are special as they occupy the entire segment\n\t\t// as these are large we reset the memory occupied by the page so it is available to other\n\t\t// threads (as the owning thread needs to actually free the memory later).\n\t\t_mi_segment_huge_page_reset(segment, page, block);\n#endif\n\t}\n\n#if (MI_DEBUG \u003e 0) \u0026\u0026 !MI_TRACK_ENABLED \\\n\t\u0026\u0026 !MI_TSAN // note: when tracking, cannot use mi_usable_size with multi-threading\n\tif (segment-\u003ekind !\u003d MI_SEGMENT_HUGE) // not for huge segments as we just reset the content\n\t\tmemset(block, MI_DEBUG_FREED, mi_usable_size(block));\n#endif\n\n\t// Try to put the block on either the page-local thread free list, or the heap delayed free\n\t// list.\n\tmi_thread_free_t tfreex;\n\tbool use_delayed;\n\tmi_thread_free_t tfree \u003d mi_atomic_load_relaxed(\u0026page-\u003exthread_free);\n\tdo {\n\t\tuse_delayed \u003d (mi_tf_delayed(tfree) \u003d\u003d MI_USE_DELAYED_FREE);\n\t\tif mi_unlikely (use_delayed) {\n\t\t\t// unlikely: this only happens on the first concurrent free in a page that is in the\n\t\t\t// full list\n\t\t\ttfreex \u003d mi_tf_set_delayed(tfree, MI_DELAYED_FREEING);\n\t\t} else {\n\t\t\t// usual: directly add to page thread_free list\n\t\t\tmi_block_set_next(page, block, mi_tf_block(tfree));\n\t\t\ttfreex \u003d mi_tf_set_block(tfree, block);\n\t\t}\n\t} while (!mi_atomic_cas_weak_release(\u0026page-\u003exthread_free, \u0026tfree, tfreex));\n\n\tif mi_unlikely (use_delayed) {\n\t\t// racy read on `heap`, but ok because MI_DELAYED_FREEING is set (see `mi_heap_delete` and\n\t\t// `mi_heap_collect_abandon`)\n\t\tmi_heap_t* const heap\n\t\t\t\u003d (mi_heap_t*)(mi_atomic_load_acquire(\u0026page-\u003exheap)); // mi_page_heap(page);\n\t\tmi_assert_internal(heap !\u003d NULL);\n\t\tif (heap !\u003d NULL) {\n\t\t\t// add to the delayed free list of this heap. (do this atomically as the lock only\n\t\t\t// protects heap memory validity)\n\t\t\tmi_block_t* dfree \u003d mi_atomic_load_ptr_relaxed(mi_block_t, \u0026heap-\u003ethread_delayed_free);\n\t\t\tdo {\n\t\t\t\tmi_block_set_nextx(heap, block, dfree, heap-\u003ekeys);\n\t\t\t} while (!mi_atomic_cas_ptr_weak_release(mi_block_t, \u0026heap-\u003ethread_delayed_free, \u0026dfree,\n\t\t\t\tblock));\n\t\t}\n\n\t\t// and reset the MI_DELAYED_FREEING flag\n\t\ttfree \u003d mi_atomic_load_relaxed(\u0026page-\u003exthread_free);\n\t\tdo {\n\t\t\ttfreex \u003d tfree;\n\t\t\tmi_assert_internal(mi_tf_delayed(tfree) \u003d\u003d MI_DELAYED_FREEING);\n\t\t\ttfreex \u003d mi_tf_set_delayed(tfree, MI_NO_DELAYED_FREE);\n\t\t} while (!mi_atomic_cas_weak_release(\u0026page-\u003exthread_free, \u0026tfree, tfreex));\n\t}\n```",
      "range": {
        "startLine": 402,
        "startChar": 0,
        "endLine": 467,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e6c51922_951abe42",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 496,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline void\n_mi_free_block(mi_page_t* page, bool local, mi_block_t* block)\n{\n\t// and push it on the free list\n\t// const size_t bsize \u003d mi_page_block_size(page);\n\tif mi_likely (local) {\n\t\t// owning thread can free a block directly\n\t\tif mi_unlikely (mi_check_is_double_free(page, block))\n\t\t\treturn;\n\t\tmi_check_padding(page, block);\n#if (MI_DEBUG \u003e 0) \u0026\u0026 !MI_TRACK_ENABLED \u0026\u0026 !MI_TSAN\n\t\tif (!mi_page_is_huge(page)) // huge page content may be already decommitted\n\t\t\tmemset(block, MI_DEBUG_FREED, mi_page_block_size(page));\n#endif\n\t\tmi_block_set_next(page, block, page-\u003elocal_free);\n\t\tpage-\u003elocal_free \u003d block;\n\t\tpage-\u003eused--;\n\t\tif mi_unlikely (mi_page_all_free(page))\n\t\t\t_mi_page_retire(page);\n\t\telse if mi_unlikely (mi_page_is_in_full(page))\n\t\t\t_mi_page_unfull(page);\n\t} else {\n\t\t_mi_free_block_mt(page, block);\n\t}\n```",
      "range": {
        "startLine": 471,
        "startChar": 0,
        "endLine": 496,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0278c69_96017380",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 513,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_block_t*\n_mi_page_ptr_unalign(const mi_segment_t* segment, const mi_page_t* page, const void* p)\n{\n\tmi_assert_internal(page !\u003d NULL \u0026\u0026 p !\u003d NULL);\n\tconst size_t diff \u003d (uint8_t*)p - _mi_page_start(segment, page, NULL);\n\tconst size_t adjust \u003d (diff % mi_page_block_size(page));\n\treturn (mi_block_t*)((uintptr_t)p - adjust);\n}\n\n\nvoid mi_decl_noinline\n_mi_free_generic(const mi_segment_t* segment, mi_page_t* page, bool is_local,\n\tvoid* p) mi_attr_noexcept\n{\n\tmi_block_t* const block\n\t\t\u003d (mi_page_has_aligned(page) ? _mi_page_ptr_unalign(segment, page, p) : (mi_block_t*)p);\n\tmi_stat_free(page, block); // stat_free may access the padding\n\tmi_track_free_size(block, mi_page_usable_size_of(page, block));\n\t_mi_free_block(page, is_local, block);\n```",
      "range": {
        "startLine": 501,
        "startChar": 0,
        "endLine": 513,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "10f7fb8f_f55ac42d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 556,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_segment_t*\nmi_checked_ptr_segment(const void* p, const char* msg)\n{\n\tMI_UNUSED(msg);\n\tmi_assert(p !\u003d NULL);\n\n#if (MI_DEBUG \u003e 0)\n\tif mi_unlikely (((uintptr_t)p \u0026 (MI_INTPTR_SIZE - 1)) !\u003d 0) {\n\t\t_mi_error_message(EINVAL, \"%s: invalid (unaligned) pointer: %p\\n\", msg, p);\n\t\treturn NULL;\n\t}\n#endif\n\n\tmi_segment_t* const segment \u003d _mi_ptr_segment(p);\n\tmi_assert_internal(segment !\u003d NULL);\n\n#if (MI_DEBUG \u003e 0)\n\tif mi_unlikely (!mi_is_in_heap_region(p)) {\n#if (MI_INTPTR_SIZE \u003d\u003d 8 \u0026\u0026 defined(__linux__))\n\t\tif (((uintptr_t)p \u003e\u003e 40)\n\t\t\t!\u003d 0x7F) { // linux tends to align large blocks above 0x7F000000000 (issue #640)\n#else\n\t\t{\n#endif\n\t\t\t_mi_warning_message(\"%s: pointer might not point to a valid heap region: %p\\n\"\n\t\t\t\t\t\t\t\t\"(this may still be a valid very large allocation (over 64MiB))\\n\",\n\t\t\t\tmsg, p);\n\t\t\tif mi_likely (_mi_ptr_cookie(segment) \u003d\u003d segment-\u003ecookie)\n\t\t\t\t_mi_warning_message(\"(yes, the previous pointer %p was valid after all)\\n\", p);\n\t\t}\n\t}\n#endif\n#if (MI_DEBUG \u003e 0 || MI_SECURE \u003e\u003d 4)\n\tif mi_unlikely (_mi_ptr_cookie(segment) !\u003d segment-\u003ecookie) {\n\t\t_mi_error_message(EINVAL, \"%s: pointer does not point to a valid heap space: %p\\n\", msg, p);\n\t\treturn NULL;\n\t}\n#endif\n\n\treturn segment;\n```",
      "range": {
        "startLine": 519,
        "startChar": 0,
        "endLine": 556,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be39250f_0b8ca05e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 593,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\nmi_free(void* p) mi_attr_noexcept\n{\n\tif mi_unlikely (p \u003d\u003d NULL)\n\t\treturn;\n\tmi_segment_t* const segment \u003d mi_checked_ptr_segment(p, \"mi_free\");\n\tconst bool is_local \u003d (_mi_prim_thread_id() \u003d\u003d mi_atomic_load_relaxed(\u0026segment-\u003ethread_id));\n\tmi_page_t* const page \u003d _mi_segment_page_of(segment, p);\n\n\tif mi_likely (is_local) { // thread-local free?\n\t\tif mi_likely (page-\u003eflags.full_aligned\n\t\t\t\u003d\u003d 0) // and it is not a full page (full pages need to move from the full bin), nor has\n\t\t\t\t  // aligned blocks (aligned blocks need to be unaligned)\n\t\t{\n\t\t\tmi_block_t* const block \u003d (mi_block_t*)p;\n\t\t\tif mi_unlikely (mi_check_is_double_free(page, block))\n\t\t\t\treturn;\n\t\t\tmi_check_padding(page, block);\n\t\t\tmi_stat_free(page, block);\n#if (MI_DEBUG \u003e 0) \u0026\u0026 !MI_TRACK_ENABLED \u0026\u0026 !MI_TSAN\n\t\t\tmemset(block, MI_DEBUG_FREED, mi_page_block_size(page));\n#endif\n\t\t\tmi_track_free_size(p,\n\t\t\t\tmi_page_usable_size_of(page, block)); // faster then mi_usable_size as we already\n\t\t\t\t\t\t\t\t\t\t\t\t\t  // know the page and that p is unaligned\n\t\t\tmi_block_set_next(page, block, page-\u003elocal_free);\n\t\t\tpage-\u003elocal_free \u003d block;\n\t\t\tif mi_unlikely (--page-\u003eused \u003d\u003d 0) { // using this expression generates better code\n\t\t\t\t\t\t\t\t\t\t\t\t // than: page-\u003eused--; if (mi_page_all_free(page))\n\t\t\t\t_mi_page_retire(page);\n\t\t\t}\n\t\t} else {\n\t\t\t// page is full or contains (inner) aligned blocks; use generic path\n\t\t\t_mi_free_generic(segment, page, true, p);\n\t\t}\n\t} else {\n\t\t// not thread-local; use generic path\n\t\t_mi_free_generic(segment, page, false, p);\n\t}\n```",
      "range": {
        "startLine": 561,
        "startChar": 0,
        "endLine": 593,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96f7d7eb_46077395",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 618,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_free_delayed_block(mi_block_t* block)\n{\n\t// get segment and page\n\tconst mi_segment_t* const segment \u003d _mi_ptr_segment(block);\n\tmi_assert_internal(_mi_ptr_cookie(segment) \u003d\u003d segment-\u003ecookie);\n\tmi_assert_internal(_mi_thread_id() \u003d\u003d segment-\u003ethread_id);\n\tmi_page_t* const page \u003d _mi_segment_page_of(segment, block);\n\n\t// Clear the no-delayed flag so delayed freeing is used again for this page.\n\t// This must be done before collecting the free lists on this page -- otherwise\n\t// some blocks may end up in the page `thread_free` list with no blocks in the\n\t// heap `thread_delayed_free` list which may cause the page to be never freed!\n\t// (it would only be freed if we happen to scan it in `mi_page_queue_find_free_ex`)\n\tif (!_mi_page_try_use_delayed_free(page, MI_USE_DELAYED_FREE,\n\t\t\tfalse /* dont overwrite never delayed */)) {\n\t\treturn false;\n\t}\n\n\t// collect all other non-local frees to ensure up-to-date `used` count\n\t_mi_page_free_collect(page, false);\n\n\t// and free the block (possibly freeing the page as well since used is updated)\n\t_mi_free_block(page, true, block);\n\treturn true;\n```",
      "range": {
        "startLine": 597,
        "startChar": 0,
        "endLine": 618,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1c9c8cd4_171d41e6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 645,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_noinline static size_t\nmi_page_usable_aligned_size_of(const mi_segment_t* segment, const mi_page_t* page,\n\tconst void* p) mi_attr_noexcept\n{\n\tconst mi_block_t* block \u003d _mi_page_ptr_unalign(segment, page, p);\n\tconst size_t size \u003d mi_page_usable_size_of(page, block);\n\tconst ptrdiff_t adjust \u003d (uint8_t*)p - (uint8_t*)block;\n\tmi_assert_internal(adjust \u003e\u003d 0 \u0026\u0026 (size_t)adjust \u003c\u003d size);\n\treturn size - adjust;\n}\n\n\nstatic inline size_t\n_mi_usable_size(const void* p, const char* msg) mi_attr_noexcept\n{\n\tif (p \u003d\u003d NULL)\n\t\treturn 0;\n\tconst mi_segment_t* const segment \u003d mi_checked_ptr_segment(p, msg);\n\tconst mi_page_t* const page \u003d _mi_segment_page_of(segment, p);\n\tif mi_likely (!mi_page_has_aligned(page)) {\n\t\tconst mi_block_t* block \u003d (const mi_block_t*)p;\n\t\treturn mi_page_usable_size_of(page, block);\n\t} else {\n\t\t// split out to separate routine for improved code generation\n\t\treturn mi_page_usable_aligned_size_of(segment, page, p);\n\t}\n}\n\n\nmi_decl_nodiscard size_t\nmi_usable_size(const void* p) mi_attr_noexcept\n{\n\treturn _mi_usable_size(p, \"mi_usable_size\");\n```",
      "range": {
        "startLine": 622,
        "startChar": 0,
        "endLine": 645,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2a126d0c_4b43ebf4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 678,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\nmi_free_size(void* p, size_t size) mi_attr_noexcept\n{\n\tMI_UNUSED_RELEASE(size);\n\tmi_assert(p \u003d\u003d NULL || size \u003c\u003d _mi_usable_size(p, \"mi_free_size\"));\n\tmi_free(p);\n}\n\n\nvoid\nmi_free_size_aligned(void* p, size_t size, size_t alignment) mi_attr_noexcept\n{\n\tMI_UNUSED_RELEASE(alignment);\n\tmi_assert(((uintptr_t)p % alignment) \u003d\u003d 0);\n\tmi_free_size(p, size);\n}\n\n\nvoid\nmi_free_aligned(void* p, size_t alignment) mi_attr_noexcept\n{\n\tMI_UNUSED_RELEASE(alignment);\n\tmi_assert(((uintptr_t)p % alignment) \u003d\u003d 0);\n\tmi_free(p);\n}\n\n\nmi_decl_nodiscard extern inline mi_decl_restrict void*\nmi_heap_calloc(mi_heap_t* heap, size_t count, size_t size) mi_attr_noexcept\n{\n\tsize_t total;\n\tif (mi_count_size_overflow(count, size, \u0026total))\n\t\treturn NULL;\n\treturn mi_heap_zalloc(heap, total);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_calloc(size_t count, size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_calloc(mi_prim_get_default_heap(), count, size);\n```",
      "range": {
        "startLine": 653,
        "startChar": 0,
        "endLine": 678,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4850a402_975d1a20",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 689,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard extern mi_decl_restrict void*\nmi_heap_mallocn(mi_heap_t* heap, size_t count, size_t size) mi_attr_noexcept\n{\n\tsize_t total;\n\tif (mi_count_size_overflow(count, size, \u0026total))\n\t\treturn NULL;\n\treturn mi_heap_malloc(heap, total);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_mallocn(size_t count, size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_mallocn(mi_prim_get_default_heap(), count, size);\n```",
      "range": {
        "startLine": 682,
        "startChar": 0,
        "endLine": 689,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1b67dffa_c97fece9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 745,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid*\nmi_expand(void* p, size_t newsize) mi_attr_noexcept\n{\n#if MI_PADDING\n\t// we do not shrink/expand with padding enabled\n\tMI_UNUSED(p);\n\tMI_UNUSED(newsize);\n\treturn NULL;\n#else\n\tif (p \u003d\u003d NULL)\n\t\treturn NULL;\n\tconst size_t size \u003d _mi_usable_size(p, \"mi_expand\");\n\tif (newsize \u003e size)\n\t\treturn NULL;\n\treturn p; // it fits\n#endif\n}\n\n\nvoid*\n_mi_heap_realloc_zero(mi_heap_t* heap, void* p, size_t newsize, bool zero) mi_attr_noexcept\n{\n\t// if p \u003d\u003d NULL then behave as malloc.\n\t// else if size \u003d\u003d 0 then reallocate to a zero-sized block (and don\u0027t return NULL, just as\n\t// mi_malloc(0)). (this means that returning NULL always indicates an error, and `p` will not\n\t// have been freed in that case.)\n\tconst size_t size \u003d _mi_usable_size(p, \"mi_realloc\"); // also works if p \u003d\u003d NULL (with size 0)\n\tif mi_unlikely (newsize \u003c\u003d size \u0026\u0026 newsize \u003e\u003d (size / 2)\n\t\t\u0026\u0026 newsize\n\t\t\t\u003e 0) { // note: newsize must be \u003e 0 or otherwise we return NULL for realloc(NULL,0)\n\t\tmi_assert_internal(p !\u003d NULL);\n\t\t// todo: do not track as the usable size is still the same in the free; adjust potential\n\t\t// padding? mi_track_resize(p,size,newsize) if (newsize \u003c size) {\n\t\t// mi_track_mem_noaccess((uint8_t*)p + newsize, size - newsize); }\n\t\treturn p; // reallocation still fits and not more than 50% waste\n\t}\n\tvoid* newp \u003d mi_heap_malloc(heap, newsize);\n\tif mi_likely (newp !\u003d NULL) {\n\t\tif (zero \u0026\u0026 newsize \u003e size) {\n\t\t\t// also set last word in the previous allocation to zero to ensure any padding is\n\t\t\t// zero-initialized\n\t\t\tconst size_t start \u003d (size \u003e\u003d sizeof(intptr_t) ? size - sizeof(intptr_t) : 0);\n\t\t\t_mi_memzero((uint8_t*)newp + start, newsize - start);\n\t\t} else if (newsize \u003d\u003d 0) {\n\t\t\t((uint8_t*)newp)[0] \u003d 0; // work around for applications that expect zero-reallocation\n\t\t\t\t\t\t\t\t\t // to be zero initialized (issue #725)\n\t\t}\n\t\tif mi_likely (p !\u003d NULL) {\n\t\t\tconst size_t copysize \u003d (newsize \u003e size ? size : newsize);\n\t\t\tmi_track_mem_defined(p,\n\t\t\t\tcopysize); // _mi_useable_size may be too large for byte precise memory tracking..\n\t\t\t_mi_memcpy(newp, p, copysize);\n\t\t\tmi_free(p); // only free the original pointer if successful\n\t\t}\n\t}\n\treturn newp;\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_realloc(mi_heap_t* heap, void* p, size_t newsize) mi_attr_noexcept\n{\n\treturn _mi_heap_realloc_zero(heap, p, newsize, false);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_reallocn(mi_heap_t* heap, void* p, size_t count, size_t size) mi_attr_noexcept\n{\n\tsize_t total;\n\tif (mi_count_size_overflow(count, size, \u0026total))\n\t\treturn NULL;\n\treturn mi_heap_realloc(heap, p, total);\n```",
      "range": {
        "startLine": 693,
        "startChar": 0,
        "endLine": 745,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45d5d081_da69fc8a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 772,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard void*\nmi_heap_reallocf(mi_heap_t* heap, void* p, size_t newsize) mi_attr_noexcept\n{\n\tvoid* newp \u003d mi_heap_realloc(heap, p, newsize);\n\tif (newp \u003d\u003d NULL \u0026\u0026 p !\u003d NULL)\n\t\tmi_free(p);\n\treturn newp;\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_rezalloc(mi_heap_t* heap, void* p, size_t newsize) mi_attr_noexcept\n{\n\treturn _mi_heap_realloc_zero(heap, p, newsize, true);\n}\n\n\nmi_decl_nodiscard void*\nmi_heap_recalloc(mi_heap_t* heap, void* p, size_t count, size_t size) mi_attr_noexcept\n{\n\tsize_t total;\n\tif (mi_count_size_overflow(count, size, \u0026total))\n\t\treturn NULL;\n\treturn mi_heap_rezalloc(heap, p, total);\n}\n\n\nmi_decl_nodiscard void*\nmi_realloc(void* p, size_t newsize) mi_attr_noexcept\n{\n\treturn mi_heap_realloc(mi_prim_get_default_heap(), p, newsize);\n}\n\n\nmi_decl_nodiscard void*\nmi_reallocn(void* p, size_t count, size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_reallocn(mi_prim_get_default_heap(), p, count, size);\n```",
      "range": {
        "startLine": 750,
        "startChar": 0,
        "endLine": 772,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8a3db51_b8e28266",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 787,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard void*\nmi_reallocf(void* p, size_t newsize) mi_attr_noexcept\n{\n\treturn mi_heap_reallocf(mi_prim_get_default_heap(), p, newsize);\n}\n\n\nmi_decl_nodiscard void*\nmi_rezalloc(void* p, size_t newsize) mi_attr_noexcept\n{\n\treturn mi_heap_rezalloc(mi_prim_get_default_heap(), p, newsize);\n}\n\n\nmi_decl_nodiscard void*\nmi_recalloc(void* p, size_t count, size_t size) mi_attr_noexcept\n{\n\treturn mi_heap_recalloc(mi_prim_get_default_heap(), p, count, size);\n}\n```",
      "range": {
        "startLine": 776,
        "startChar": 0,
        "endLine": 787,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "79a6f894_bc3cdf73",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 806,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard mi_decl_restrict char*\nmi_heap_strdup(mi_heap_t* heap, const char* s) mi_attr_noexcept\n{\n\tif (s \u003d\u003d NULL)\n\t\treturn NULL;\n\tsize_t n \u003d strlen(s);\n\tchar* t \u003d (char*)mi_heap_malloc(heap, n + 1);\n\tif (t \u003d\u003d NULL)\n\t\treturn NULL;\n\t_mi_memcpy(t, s, n);\n\tt[n] \u003d 0;\n\treturn t;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict char*\nmi_strdup(const char* s) mi_attr_noexcept\n{\n\treturn mi_heap_strdup(mi_prim_get_default_heap(), s);\n```",
      "range": {
        "startLine": 795,
        "startChar": 0,
        "endLine": 806,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3fa8c57_a262c367",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 823,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_nodiscard mi_decl_restrict char*\nmi_heap_strndup(mi_heap_t* heap, const char* s, size_t n) mi_attr_noexcept\n{\n\tif (s \u003d\u003d NULL)\n\t\treturn NULL;\n\tconst char* end \u003d (const char*)memchr(s, 0,\n\t\tn); // find end of string in the first `n` characters (returns NULL if not found)\n\tconst size_t m\n\t\t\u003d (end !\u003d NULL ? (size_t)(end - s) : n); // `m` is the minimum of `n` or the end-of-string\n\tmi_assert_internal(m \u003c\u003d n);\n\tchar* t \u003d (char*)mi_heap_malloc(heap, m + 1);\n\tif (t \u003d\u003d NULL)\n\t\treturn NULL;\n\t_mi_memcpy(t, s, m);\n\tt[m] \u003d 0;\n\treturn t;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict char*\nmi_strndup(const char* s, size_t n) mi_attr_noexcept\n{\n\treturn mi_heap_strndup(mi_prim_get_default_heap(), s, n);\n```",
      "range": {
        "startLine": 810,
        "startChar": 0,
        "endLine": 823,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "805762ba_6838b54b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 848,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nmi_decl_nodiscard mi_decl_restrict char*\nmi_heap_realpath(mi_heap_t* heap, const char* fname, char* resolved_name) mi_attr_noexcept\n{\n\t// todo: use GetFullPathNameW to allow longer file names\n\tchar buf[PATH_MAX];\n\tDWORD res\n\t\t\u003d GetFullPathNameA(fname, PATH_MAX, (resolved_name \u003d\u003d NULL ? buf : resolved_name), NULL);\n\tif (res \u003d\u003d 0) {\n\t\terrno \u003d GetLastError();\n\t\treturn NULL;\n\t} else if (res \u003e PATH_MAX) {\n\t\terrno \u003d EINVAL;\n\t\treturn NULL;\n\t} else if (resolved_name !\u003d NULL) {\n\t\treturn resolved_name;\n\t} else {\n\t\treturn mi_heap_strndup(heap, buf, PATH_MAX);\n\t}\n```",
      "range": {
        "startLine": 833,
        "startChar": 0,
        "endLine": 848,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93b9cb5a_c16d4b7d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 859,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tlong m \u003d pathconf(\"/\",_PC_PATH_MAX);\n\tif (m \u003c\u003d 0) path_max \u003d 4096;      // guess\n\telse if (m \u003c 256) path_max \u003d 256; // at least 256\n\telse path_max \u003d m;\n```",
      "range": {
        "startLine": 856,
        "startChar": 0,
        "endLine": 859,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "199e3fc7_ba11d907",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 892,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nchar*\nmi_heap_realpath(mi_heap_t* heap, const char* fname, char* resolved_name) mi_attr_noexcept\n{\n\tif (resolved_name !\u003d NULL) {\n\t\treturn realpath(fname, resolved_name);\n\t} else {\n\t\tchar* rname \u003d realpath(fname, NULL);\n\t\tif (rname \u003d\u003d NULL)\n\t\t\treturn NULL;\n\t\tchar* result \u003d mi_heap_strdup(heap, rname);\n\t\tfree(rname); // use regular free! (which may be redirected to our free but that\u0027s ok)\n\t\treturn result;\n\t}\n\t/*\n\t  const size_t n  \u003d mi_path_max();\n\t  char* buf \u003d (char*)mi_malloc(n+1);\n\t  if (buf \u003d\u003d NULL) {\n\t\terrno \u003d ENOMEM;\n\t\treturn NULL;\n\t  }\n\t  char* rname  \u003d realpath(fname,buf);\n\t  char* result \u003d mi_heap_strndup(heap,rname,n); // ok if `rname\u003d\u003dNULL`\n\t  mi_free(buf);\n\t  return result;\n\t}\n\t*/\n}\n#endif\n\n\nmi_decl_nodiscard mi_decl_restrict char*\nmi_realpath(const char* fname, char* resolved_name) mi_attr_noexcept\n{\n\treturn mi_heap_realpath(mi_prim_get_default_heap(), fname, resolved_name);\n```",
      "range": {
        "startLine": 864,
        "startChar": 0,
        "endLine": 892,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2fe2e30e_14e4d246",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 924,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic bool\nmi_try_new_handler(bool nothrow)\n{\n#if defined(_MSC_VER) || (__cplusplus \u003e\u003d 201103L)\n\tstd::new_handler h \u003d std::get_new_handler();\n#else\n\tstd::new_handler h \u003d std::set_new_handler();\n\tstd::set_new_handler(h);\n#endif\n\tif (h \u003d\u003d NULL) {\n\t\t_mi_error_message(ENOMEM, \"out of memory in \u0027new\u0027\");\n\t\tif (!nothrow)\n\t\t\tthrow std::bad_alloc();\n\t\treturn false;\n\t} else {\n\t\th();\n\t\treturn true;\n\t}\n```",
      "range": {
        "startLine": 907,
        "startChar": 0,
        "endLine": 924,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac1b2762_b01f5618",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 934,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (defined(__GNUC__) \\\n\t|| (defined(__clang__) \u0026\u0026 !defined(_MSC_VER))) // exclude clang-cl, see issue #631\n\n\nstd_new_handler_t __attribute__((weak)) _ZSt15get_new_handlerv(void)\n{\n\treturn NULL;\n}\n\n\nstatic std_new_handler_t\nmi_get_new_handler(void)\n{\n\treturn _ZSt15get_new_handlerv();\n```",
      "range": {
        "startLine": 929,
        "startChar": 0,
        "endLine": 934,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a3d973e_0ffa453c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 1039,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic std_new_handler_t\nmi_get_new_handler()\n{\n\treturn NULL;\n}\n#endif\n\n\nstatic bool\nmi_try_new_handler(bool nothrow)\n{\n\tstd_new_handler_t h \u003d mi_get_new_handler();\n\tif (h \u003d\u003d NULL) {\n\t\t_mi_error_message(ENOMEM, \"out of memory in \u0027new\u0027\");\n\t\tif (!nothrow)\n\t\t\tabort(); // cannot throw in plain C, use abort\n\t\treturn false;\n\t} else {\n\t\th();\n\t\treturn true;\n\t}\n}\n#endif\n\n\nmi_decl_export mi_decl_noinline void*\nmi_heap_try_new(mi_heap_t* heap, size_t size, bool nothrow)\n{\n\tvoid* p \u003d NULL;\n\twhile (p \u003d\u003d NULL \u0026\u0026 mi_try_new_handler(nothrow))\n\t\tp \u003d mi_heap_malloc(heap, size);\n\treturn p;\n}\n\n\nstatic mi_decl_noinline void*\nmi_try_new(size_t size, bool nothrow)\n{\n\treturn mi_heap_try_new(mi_prim_get_default_heap(), size, nothrow);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_alloc_new(mi_heap_t* heap, size_t size)\n{\n\tvoid* p \u003d mi_heap_malloc(heap, size);\n\tif mi_unlikely (p \u003d\u003d NULL)\n\t\treturn mi_heap_try_new(heap, size, false);\n\treturn p;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_new(size_t size)\n{\n\treturn mi_heap_alloc_new(mi_prim_get_default_heap(), size);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_heap_alloc_new_n(mi_heap_t* heap, size_t count, size_t size)\n{\n\tsize_t total;\n\tif mi_unlikely (mi_count_size_overflow(count, size, \u0026total)) {\n\t\tmi_try_new_handler(false); // on overflow we invoke the try_new_handler once to potentially\n\t\t\t\t\t\t\t\t   // throw std::bad_alloc\n\t\treturn NULL;\n\t} else {\n\t\treturn mi_heap_alloc_new(heap, total);\n\t}\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_new_n(size_t count, size_t size)\n{\n\treturn mi_heap_alloc_new_n(mi_prim_get_default_heap(), size, count);\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_new_nothrow(size_t size) mi_attr_noexcept\n{\n\tvoid* p \u003d mi_malloc(size);\n\tif mi_unlikely (p \u003d\u003d NULL)\n\t\treturn mi_try_new(size, true);\n\treturn p;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_new_aligned(size_t size, size_t alignment)\n{\n\tvoid* p;\n\tdo {\n\t\tp \u003d mi_malloc_aligned(size, alignment);\n\t} while (p \u003d\u003d NULL \u0026\u0026 mi_try_new_handler(false));\n\treturn p;\n}\n\n\nmi_decl_nodiscard mi_decl_restrict void*\nmi_new_aligned_nothrow(size_t size, size_t alignment) mi_attr_noexcept\n{\n\tvoid* p;\n\tdo {\n\t\tp \u003d mi_malloc_aligned(size, alignment);\n\t} while (p \u003d\u003d NULL \u0026\u0026 mi_try_new_handler(true));\n\treturn p;\n}\n\n\nmi_decl_nodiscard void*\nmi_new_realloc(void* p, size_t newsize)\n{\n\tvoid* q;\n\tdo {\n\t\tq \u003d mi_realloc(p, newsize);\n\t} while (q \u003d\u003d NULL \u0026\u0026 mi_try_new_handler(false));\n\treturn q;\n}\n\n\nmi_decl_nodiscard void*\nmi_new_reallocn(void* p, size_t newcount, size_t size)\n{\n\tsize_t total;\n\tif mi_unlikely (mi_count_size_overflow(newcount, size, \u0026total)) {\n\t\tmi_try_new_handler(false); // on overflow we invoke the try_new_handler once to potentially\n\t\t\t\t\t\t\t\t   // throw std::bad_alloc\n\t\treturn NULL;\n\t} else {\n\t\treturn mi_new_realloc(p, total);\n\t}\n```",
      "range": {
        "startLine": 938,
        "startChar": 0,
        "endLine": 1039,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43816d2a_d6853937",
        "filename": "src/system/libroot/posix/malloc/mimalloc/alloc.c",
        "patchSetId": 7
      },
      "lineNbr": 1058,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t(void*)\u0026_mi_page_malloc, (void*)\u0026_mi_heap_malloc_zero, (void*)\u0026_mi_heap_malloc_zero_ex,\n\t(void*)\u0026mi_malloc, (void*)\u0026mi_malloc_small, (void*)\u0026mi_zalloc_small, (void*)\u0026mi_heap_malloc,\n\t(void*)\u0026mi_heap_zalloc, (void*)\u0026mi_heap_malloc_small,\n\t// (void*)\u0026mi_heap_alloc_new,\n\t// (void*)\u0026mi_heap_alloc_new_n\n```",
      "range": {
        "startLine": 1048,
        "startChar": 0,
        "endLine": 1058,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b745e730_f22daa9d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\non embedded devices. We can also employ this with WASI or `sbrk` systems\n```",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b5448adb_8eccb493",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 21,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cb4ffd2c_703f7335",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 28,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n#include \u003cerrno.h\u003e // ENOMEM\n#include \u003cstring.h\u003e // memset\n\n#include \"bitmap.h\" // atomic bitmap\n```",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 28,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fab77311_bc949628",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_ARENA_BLOCK_SIZE (MI_SEGMENT_SIZE) // 64MiB  (must be at least MI_SEGMENT_ALIGN)\n#define MI_ARENA_MIN_OBJ_SIZE (MI_ARENA_BLOCK_SIZE / 2) // 32MiB\n#define MI_MAX_ARENAS \\\n\t(112) // not more than 126 (since we use 7 bits in the memid and an arena index + 1)\n```",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 39,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "727b0635_dde67a55",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 58,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_arena_id_t id; // arena id; 0 for non-specific\n\tmi_memid_t memid; // memid of the memory area\n\t_Atomic(uint8_t*) start; // the start of the memory area\n\tsize_t block_count; // size of the area in arena blocks (of `MI_ARENA_BLOCK_SIZE`)\n\tsize_t field_count; // number of bitmap fields (where `field_count * MI_BITMAP_FIELD_BITS \u003e\u003d\n\t\t\t\t\t\t// block_count`)\n\tsize_t meta_size; // size of the arena structure itself (including its bitmaps)\n\tmi_memid_t meta_memid; // memid of the arena structure itself (OS or static allocation)\n\tint numa_node; // associated NUMA node\n\tbool exclusive; // only allow allocations if specifically for this arena\n\tbool is_large; // memory area consists of large- or huge OS pages (always committed)\n\t_Atomic(size_t) search_idx; // optimization to start the search for free blocks\n\t_Atomic(mi_msecs_t)\n\t\tpurge_expire; // expiration time when blocks should be decommitted from `blocks_decommit`.\n\tmi_bitmap_field_t* blocks_dirty; // are the blocks potentially non-zero?\n\tmi_bitmap_field_t* blocks_committed; // are the blocks committed? (can be NULL for memory that\n\t\t\t\t\t\t\t\t\t\t // cannot be decommitted)\n\tmi_bitmap_field_t* blocks_purge; // blocks that can be (reset) decommitted. (can be NULL for\n\t\t\t\t\t\t\t\t\t // memory that cannot be (reset) decommitted)\n\tmi_bitmap_field_t blocks_inuse[1]; // in-place bitmap of in-use blocks (of size `field_count`)\n```",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 58,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2cb60601_fa6d6824",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_cache_align _Atomic(size_t) mi_arena_count; // \u003d 0\n\n\n// static bool mi_manage_os_memory_ex2(void* start, size_t size, bool is_large, int numa_node, bool\n// exclusive, mi_memid_t memid, mi_arena_id_t* arena_id) mi_attr_noexcept;\n```",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 67,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3a9d1d0a_5f6cbc54",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 102,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic size_t\nmi_arena_id_index(mi_arena_id_t id)\n{\n\treturn (size_t)(id \u003c\u003d 0 ? MI_MAX_ARENAS : id - 1);\n}\n\n\nstatic mi_arena_id_t\nmi_arena_id_create(size_t arena_index)\n{\n\tmi_assert_internal(arena_index \u003c MI_MAX_ARENAS);\n\treturn (int)arena_index + 1;\n}\n\n\nmi_arena_id_t\n_mi_arena_id_none(void)\n{\n\treturn 0;\n}\n\n\nstatic bool\nmi_arena_id_is_suitable(mi_arena_id_t arena_id, bool arena_is_exclusive, mi_arena_id_t req_arena_id)\n{\n\treturn (!arena_is_exclusive \u0026\u0026 req_arena_id \u003d\u003d _mi_arena_id_none())\n\t\t|| (arena_id \u003d\u003d req_arena_id);\n}\n\n\nbool\n_mi_arena_memid_is_suitable(mi_memid_t memid, mi_arena_id_t request_arena_id)\n{\n\tif (memid.memkind \u003d\u003d MI_MEM_ARENA) {\n\t\treturn mi_arena_id_is_suitable(memid.mem.arena.id, memid.mem.arena.is_exclusive,\n\t\t\trequest_arena_id);\n\t} else {\n\t\treturn mi_arena_id_is_suitable(0, false, request_arena_id);\n\t}\n}\n\n\nbool\n_mi_arena_memid_is_os_allocated(mi_memid_t memid)\n{\n\treturn memid.memkind \u003d\u003d MI_MEM_OS;\n```",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 102,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "338c5c2f_ea94886e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 106,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n  Arena allocations get a (currently) 16-bit memory id where the\n```",
      "range": {
        "startLine": 106,
        "startChar": 0,
        "endLine": 106,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "39e22fd8_b204560c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 136,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic size_t\nmi_block_count_of_size(size_t size)\n{\n\treturn _mi_divide_up(size, MI_ARENA_BLOCK_SIZE);\n}\n\n\nstatic size_t\nmi_arena_block_size(size_t bcount)\n{\n\treturn bcount * MI_ARENA_BLOCK_SIZE;\n}\n\n\nstatic size_t\nmi_arena_size(mi_arena_t* arena)\n{\n\treturn mi_arena_block_size(arena-\u003eblock_count);\n}\n\n\nstatic mi_memid_t\nmi_memid_create_arena(mi_arena_id_t id, bool is_exclusive, mi_bitmap_index_t bitmap_index)\n{\n\tmi_memid_t memid \u003d _mi_memid_create(MI_MEM_ARENA);\n\tmemid.mem.arena.id \u003d id;\n\tmemid.mem.arena.block_index \u003d bitmap_index;\n\tmemid.mem.arena.is_exclusive \u003d is_exclusive;\n\treturn memid;\n}\n\n\nstatic bool\nmi_arena_memid_indices(mi_memid_t memid, size_t* arena_index, mi_bitmap_index_t* bitmap_index)\n{\n\tmi_assert_internal(memid.memkind \u003d\u003d MI_MEM_ARENA);\n\t*arena_index \u003d mi_arena_id_index(memid.mem.arena.id);\n\t*bitmap_index \u003d memid.mem.arena.block_index;\n\treturn memid.mem.arena.is_exclusive;\n}\n```",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 136,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53318901_69e70225",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 144,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_ARENA_STATIC_MAX (MI_INTPTR_SIZE * MI_KiB) // 8 KiB on 64-bit\n```",
      "range": {
        "startLine": 144,
        "startChar": 0,
        "endLine": 144,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f7f8e603_a8b318b8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 195,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void*\nmi_arena_static_zalloc(size_t size, size_t alignment, mi_memid_t* memid)\n{\n\t*memid \u003d _mi_memid_none();\n\tif (size \u003d\u003d 0 || size \u003e MI_ARENA_STATIC_MAX)\n\t\treturn NULL;\n\tif ((mi_atomic_load_relaxed(\u0026mi_arena_static_top) + size) \u003e MI_ARENA_STATIC_MAX)\n\t\treturn NULL;\n\n\t// try to claim space\n\tif (alignment \u003d\u003d 0)\n\t\talignment \u003d 1;\n\tconst size_t oversize \u003d size + alignment - 1;\n\tif (oversize \u003e MI_ARENA_STATIC_MAX)\n\t\treturn NULL;\n\tconst size_t oldtop \u003d mi_atomic_add_acq_rel(\u0026mi_arena_static_top, oversize);\n\tsize_t top \u003d oldtop + oversize;\n\tif (top \u003e MI_ARENA_STATIC_MAX) {\n\t\t// try to roll back, ok if this fails\n\t\tmi_atomic_cas_strong_acq_rel(\u0026mi_arena_static_top, \u0026top, oldtop);\n\t\treturn NULL;\n\t}\n\n\t// success\n\t*memid \u003d _mi_memid_create(MI_MEM_STATIC);\n\tconst size_t start \u003d _mi_align_up(oldtop, alignment);\n\tuint8_t* const p \u003d \u0026mi_arena_static[start];\n\t_mi_memzero(p, size);\n\treturn p;\n}\n\n\nstatic void*\nmi_arena_meta_zalloc(size_t size, mi_memid_t* memid, mi_stats_t* stats)\n{\n\t*memid \u003d _mi_memid_none();\n\n\t// try static\n\tvoid* p \u003d mi_arena_static_zalloc(size, MI_ALIGNMENT_MAX, memid);\n\tif (p !\u003d NULL)\n\t\treturn p;\n\n\t// or fall back to the OS\n\treturn _mi_os_alloc(size, memid, stats);\n}\n\n\nstatic void\nmi_arena_meta_free(void* p, mi_memid_t memid, size_t size, mi_stats_t* stats)\n{\n\tif (mi_memkind_is_os(memid.memkind))\n\t\t_mi_os_free(p, size, memid, stats);\n\telse\n\t\tmi_assert(memid.memkind \u003d\u003d MI_MEM_STATIC);\n}\n\n\nstatic void*\nmi_arena_block_start(mi_arena_t* arena, mi_bitmap_index_t bindex)\n{\n\treturn arena-\u003estart + mi_arena_block_size(mi_bitmap_index_bit(bindex));\n```",
      "range": {
        "startLine": 149,
        "startChar": 0,
        "endLine": 195,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff7d0699_fcbb2944",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 211,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_arena_try_claim(mi_arena_t* arena, size_t blocks, mi_bitmap_index_t* bitmap_idx)\n{\n\tsize_t idx \u003d 0; // mi_atomic_load_relaxed(\u0026arena-\u003esearch_idx);  // start from last search; ok to\n\t\t\t\t\t// be relaxed as the exact start does not matter\n\tif (_mi_bitmap_try_find_from_claim_across(arena-\u003eblocks_inuse, arena-\u003efield_count, idx, blocks,\n\t\t\tbitmap_idx)) {\n\t\tmi_atomic_store_relaxed(\u0026arena-\u003esearch_idx,\n\t\t\tmi_bitmap_index_field(\n\t\t\t\t*bitmap_idx)); // start search from found location next time around\n\t\treturn true;\n\t};\n\treturn false;\n```",
      "range": {
        "startLine": 204,
        "startChar": 0,
        "endLine": 211,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8b1b388f_a8360944",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 269,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_noinline void*\nmi_arena_try_alloc_at(mi_arena_t* arena, size_t arena_index, size_t needed_bcount, bool commit,\n\tmi_memid_t* memid, mi_os_tld_t* tld)\n{\n\tMI_UNUSED(arena_index);\n\tmi_assert_internal(mi_arena_id_index(arena-\u003eid) \u003d\u003d arena_index);\n\n\tmi_bitmap_index_t bitmap_index;\n\tif (!mi_arena_try_claim(arena, needed_bcount, \u0026bitmap_index))\n\t\treturn NULL;\n\n\t// claimed it!\n\tvoid* p \u003d mi_arena_block_start(arena, bitmap_index);\n\t*memid \u003d mi_memid_create_arena(arena-\u003eid, arena-\u003eexclusive, bitmap_index);\n\tmemid-\u003eis_pinned \u003d arena-\u003ememid.is_pinned;\n\n\t// none of the claimed blocks should be scheduled for a decommit\n\tif (arena-\u003eblocks_purge !\u003d NULL) {\n\t\t// this is thread safe as a potential purge only decommits parts that are not yet claimed as\n\t\t// used (in `blocks_inuse`).\n\t\t_mi_bitmap_unclaim_across(arena-\u003eblocks_purge, arena-\u003efield_count, needed_bcount,\n\t\t\tbitmap_index);\n\t}\n\n\t// set the dirty bits (todo: no need for an atomic op here?)\n\tif (arena-\u003ememid.initially_zero \u0026\u0026 arena-\u003eblocks_dirty !\u003d NULL) {\n\t\tmemid-\u003einitially_zero \u003d _mi_bitmap_claim_across(arena-\u003eblocks_dirty, arena-\u003efield_count,\n\t\t\tneeded_bcount, bitmap_index, NULL);\n\t}\n\n\t// set commit state\n\tif (arena-\u003eblocks_committed \u003d\u003d NULL) {\n\t\t// always committed\n\t\tmemid-\u003einitially_committed \u003d true;\n\t} else if (commit) {\n\t\t// commit requested, but the range may not be committed as a whole: ensure it is committed\n\t\t// now\n\t\tmemid-\u003einitially_committed \u003d true;\n\t\tbool any_uncommitted;\n\t\t_mi_bitmap_claim_across(arena-\u003eblocks_committed, arena-\u003efield_count, needed_bcount,\n\t\t\tbitmap_index, \u0026any_uncommitted);\n\t\tif (any_uncommitted) {\n\t\t\tbool commit_zero \u003d false;\n\t\t\tif (!_mi_os_commit(p, mi_arena_block_size(needed_bcount), \u0026commit_zero, tld-\u003estats)) {\n\t\t\t\tmemid-\u003einitially_committed \u003d false;\n\t\t\t} else {\n\t\t\t\tif (commit_zero)\n\t\t\t\t\tmemid-\u003einitially_zero \u003d true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// no need to commit, but check if already fully committed\n\t\tmemid-\u003einitially_committed \u003d _mi_bitmap_is_claimed_across(arena-\u003eblocks_committed,\n\t\t\tarena-\u003efield_count, needed_bcount, bitmap_index);\n\t}\n\n\treturn p;\n```",
      "range": {
        "startLine": 219,
        "startChar": 0,
        "endLine": 269,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ada41ca8_2d2c2ae0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 297,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void*\nmi_arena_try_alloc_at_id(mi_arena_id_t arena_id, bool match_numa_node, int numa_node, size_t size,\n\tsize_t alignment, bool commit, bool allow_large, mi_arena_id_t req_arena_id, mi_memid_t* memid,\n\tmi_os_tld_t* tld)\n{\n\tMI_UNUSED_RELEASE(alignment);\n\tmi_assert_internal(alignment \u003c\u003d MI_SEGMENT_ALIGN);\n\tconst size_t bcount \u003d mi_block_count_of_size(size);\n\tconst size_t arena_index \u003d mi_arena_id_index(arena_id);\n\tmi_assert_internal(arena_index \u003c mi_atomic_load_relaxed(\u0026mi_arena_count));\n\tmi_assert_internal(size \u003c\u003d mi_arena_block_size(bcount));\n\n\t// Check arena suitability\n\tmi_arena_t* arena \u003d mi_atomic_load_ptr_acquire(mi_arena_t, \u0026mi_arenas[arena_index]);\n\tif (arena \u003d\u003d NULL)\n\t\treturn NULL;\n\tif (!allow_large \u0026\u0026 arena-\u003eis_large)\n\t\treturn NULL;\n\tif (!mi_arena_id_is_suitable(arena-\u003eid, arena-\u003eexclusive, req_arena_id))\n\t\treturn NULL;\n\tif (req_arena_id \u003d\u003d _mi_arena_id_none()) { // in not specific, check numa affinity\n\t\tconst bool numa_suitable\n\t\t\t\u003d (numa_node \u003c 0 || arena-\u003enuma_node \u003c 0 || arena-\u003enuma_node \u003d\u003d numa_node);\n\t\tif (match_numa_node) {\n\t\t\tif (!numa_suitable)\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tif (numa_suitable)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// try to allocate\n\tvoid* p \u003d mi_arena_try_alloc_at(arena, arena_index, bcount, commit, memid, tld);\n\tmi_assert_internal(p \u003d\u003d NULL || _mi_is_aligned(p, alignment));\n\treturn p;\n```",
      "range": {
        "startLine": 273,
        "startChar": 0,
        "endLine": 297,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cdc0c273_f978e79c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 333,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_noinline void*\nmi_arena_try_alloc(int numa_node, size_t size, size_t alignment, bool commit, bool allow_large,\n\tmi_arena_id_t req_arena_id, mi_memid_t* memid, mi_os_tld_t* tld)\n{\n\tMI_UNUSED(alignment);\n\tmi_assert_internal(alignment \u003c\u003d MI_SEGMENT_ALIGN);\n\tconst size_t max_arena \u003d mi_atomic_load_relaxed(\u0026mi_arena_count);\n\tif mi_likely (max_arena \u003d\u003d 0)\n\t\treturn NULL;\n\n\tif (req_arena_id !\u003d _mi_arena_id_none()) {\n\t\t// try a specific arena if requested\n\t\tif (mi_arena_id_index(req_arena_id) \u003c max_arena) {\n\t\t\tvoid* p \u003d mi_arena_try_alloc_at_id(req_arena_id, true, numa_node, size, alignment,\n\t\t\t\tcommit, allow_large, req_arena_id, memid, tld);\n\t\t\tif (p !\u003d NULL)\n\t\t\t\treturn p;\n\t\t}\n\t} else {\n\t\t// try numa affine allocation\n\t\tfor (size_t i \u003d 0; i \u003c max_arena; i++) {\n\t\t\tvoid* p \u003d mi_arena_try_alloc_at_id(mi_arena_id_create(i), true, numa_node, size,\n\t\t\t\talignment, commit, allow_large, req_arena_id, memid, tld);\n\t\t\tif (p !\u003d NULL)\n\t\t\t\treturn p;\n\t\t}\n\n\t\t// try from another numa node instead..\n\t\tif (numa_node \u003e\u003d 0) { // if numa_node was \u003c 0 (no specific affinity requested), all arena\u0027s\n\t\t\t\t\t\t\t  // have been tried already\n\t\t\tfor (size_t i \u003d 0; i \u003c max_arena; i++) {\n\t\t\t\tvoid* p \u003d mi_arena_try_alloc_at_id(mi_arena_id_create(i),\n\t\t\t\t\tfalse /* only proceed if not numa local */, numa_node, size, alignment, commit,\n\t\t\t\t\tallow_large, req_arena_id, memid, tld);\n\t\t\t\tif (p !\u003d NULL)\n\t\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n```",
      "range": {
        "startLine": 302,
        "startChar": 0,
        "endLine": 333,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fd8cde65_1db005bf",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 420,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_arena_reserve(size_t req_size, bool allow_large, mi_arena_id_t req_arena_id,\n\tmi_arena_id_t* arena_id)\n{\n\tif (_mi_preloading())\n\t\treturn false; // use OS only while pre loading\n\tif (req_arena_id !\u003d _mi_arena_id_none())\n\t\treturn false;\n\n\tconst size_t arena_count \u003d mi_atomic_load_acquire(\u0026mi_arena_count);\n\tif (arena_count \u003e (MI_MAX_ARENAS - 4))\n\t\treturn false;\n\n\tsize_t arena_reserve \u003d mi_option_get_size(mi_option_arena_reserve);\n\tif (arena_reserve \u003d\u003d 0)\n\t\treturn false;\n\n\tif (!_mi_os_has_virtual_reserve()) {\n\t\tarena_reserve \u003d arena_reserve / 4; // be conservative if virtual reserve is not supported\n\t\t\t\t\t\t\t\t\t\t   // (for some embedded systems for example)\n\t}\n\tarena_reserve \u003d _mi_align_up(arena_reserve, MI_ARENA_BLOCK_SIZE);\n\tif (arena_count \u003e\u003d 8 \u0026\u0026 arena_count \u003c\u003d 128) {\n\t\tarena_reserve \u003d ((size_t)1 \u003c\u003c (arena_count / 8))\n\t\t\t* arena_reserve; // scale up the arena sizes exponentially\n\t}\n\tif (arena_reserve \u003c req_size)\n\t\treturn false; // should be able to at least handle the current allocation size\n\n\t// commit eagerly?\n\tbool arena_commit \u003d false;\n\tif (mi_option_get(mi_option_arena_eager_commit) \u003d\u003d 2)\n\t\tarena_commit \u003d _mi_os_has_overcommit();\n\telse if (mi_option_get(mi_option_arena_eager_commit) \u003d\u003d 1)\n\t\tarena_commit \u003d true;\n\n\treturn mi_reserve_os_memory_ex(arena_reserve, arena_commit, allow_large, false /* exclusive */,\n\t\t\t   arena_id)\n\t\t\u003d\u003d 0;\n}\n\n\nvoid*\n_mi_arena_alloc_aligned(size_t size, size_t alignment, size_t align_offset, bool commit,\n\tbool allow_large, mi_arena_id_t req_arena_id, mi_memid_t* memid, mi_os_tld_t* tld)\n{\n\tmi_assert_internal(memid !\u003d NULL \u0026\u0026 tld !\u003d NULL);\n\tmi_assert_internal(size \u003e 0);\n\t*memid \u003d _mi_memid_none();\n\n\tconst int numa_node \u003d _mi_os_numa_node(tld); // current numa node\n\n\t// try to allocate in an arena if the alignment is small enough and the object is not too small\n\t// (as for heap meta data)\n\tif (size \u003e\u003d MI_ARENA_MIN_OBJ_SIZE \u0026\u0026 alignment \u003c\u003d MI_SEGMENT_ALIGN \u0026\u0026 align_offset \u003d\u003d 0) {\n\t\tvoid* p \u003d mi_arena_try_alloc(numa_node, size, alignment, commit, allow_large, req_arena_id,\n\t\t\tmemid, tld);\n\t\tif (p !\u003d NULL)\n\t\t\treturn p;\n\n\t\t// otherwise, try to first eagerly reserve a new arena\n\t\tif (req_arena_id \u003d\u003d _mi_arena_id_none()) {\n\t\t\tmi_arena_id_t arena_id \u003d 0;\n\t\t\tif (mi_arena_reserve(size, allow_large, req_arena_id, \u0026arena_id)) {\n\t\t\t\t// and try allocate in there\n\t\t\t\tmi_assert_internal(req_arena_id \u003d\u003d _mi_arena_id_none());\n\t\t\t\tp \u003d mi_arena_try_alloc_at_id(arena_id, true, numa_node, size, alignment, commit,\n\t\t\t\t\tallow_large, req_arena_id, memid, tld);\n\t\t\t\tif (p !\u003d NULL)\n\t\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if we cannot use OS allocation, return NULL\n\tif (mi_option_is_enabled(mi_option_limit_os_alloc) || req_arena_id !\u003d _mi_arena_id_none()) {\n\t\terrno \u003d ENOMEM;\n\t\treturn NULL;\n\t}\n\n\t// finally, fall back to the OS\n\tif (align_offset \u003e 0) {\n\t\treturn _mi_os_alloc_aligned_at_offset(size, alignment, align_offset, commit, allow_large,\n\t\t\tmemid, tld-\u003estats);\n\t} else {\n\t\treturn _mi_os_alloc_aligned(size, alignment, commit, allow_large, memid, tld-\u003estats);\n\t}\n}\n\n\nvoid*\n_mi_arena_alloc(size_t size, bool commit, bool allow_large, mi_arena_id_t req_arena_id,\n\tmi_memid_t* memid, mi_os_tld_t* tld)\n{\n\treturn _mi_arena_alloc_aligned(size, MI_ARENA_BLOCK_SIZE, 0, commit, allow_large, req_arena_id,\n\t\tmemid, tld);\n}\n\n\nvoid*\nmi_arena_area(mi_arena_id_t arena_id, size_t* size)\n{\n\tif (size !\u003d NULL)\n\t\t*size \u003d 0;\n\tsize_t arena_index \u003d mi_arena_id_index(arena_id);\n\tif (arena_index \u003e\u003d MI_MAX_ARENAS)\n\t\treturn NULL;\n\tmi_arena_t* arena \u003d mi_atomic_load_ptr_acquire(mi_arena_t, \u0026mi_arenas[arena_index]);\n\tif (arena \u003d\u003d NULL)\n\t\treturn NULL;\n\tif (size !\u003d NULL)\n\t\t*size \u003d mi_arena_block_size(arena-\u003eblock_count);\n\treturn arena-\u003estart;\n```",
      "range": {
        "startLine": 337,
        "startChar": 0,
        "endLine": 420,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "05ab615f_36bf0f23",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 430,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic long\nmi_arena_purge_delay(void)\n{\n\t// \u003c0 \u003d no purging allowed, 0\u003dimmediate purging, \u003e0\u003dmilli-second delay\n\treturn mi_option_get(mi_option_purge_delay) * mi_option_get(mi_option_arena_purge_mult);\n```",
      "range": {
        "startLine": 428,
        "startChar": 0,
        "endLine": 430,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dfb22087_d7cbc2cd",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 461,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_arena_purge(mi_arena_t* arena, size_t bitmap_idx, size_t blocks, mi_stats_t* stats)\n{\n\tmi_assert_internal(arena-\u003eblocks_committed !\u003d NULL);\n\tmi_assert_internal(arena-\u003eblocks_purge !\u003d NULL);\n\tmi_assert_internal(!arena-\u003ememid.is_pinned);\n\tconst size_t size \u003d mi_arena_block_size(blocks);\n\tvoid* const p \u003d mi_arena_block_start(arena, bitmap_idx);\n\tbool needs_recommit;\n\tif (_mi_bitmap_is_claimed_across(arena-\u003eblocks_committed, arena-\u003efield_count, blocks,\n\t\t\tbitmap_idx)) {\n\t\t// all blocks are committed, we can purge freely\n\t\tneeds_recommit \u003d _mi_os_purge(p, size, stats);\n\t} else {\n\t\t// some blocks are not committed -- this can happen when a partially committed block is\n\t\t// freed in `_mi_arena_free` and it is conservatively marked as uncommitted but still\n\t\t// scheduled for a purge we need to ensure we do not try to reset (as that may be invalid\n\t\t// for uncommitted memory), and also undo the decommit stats (as it was already adjusted)\n\t\tmi_assert_internal(mi_option_is_enabled(mi_option_purge_decommits));\n\t\tneeds_recommit \u003d _mi_os_purge_ex(p, size, false /* allow reset? */, stats);\n\t\t_mi_stat_increase(\u0026stats-\u003ecommitted, size);\n\t}\n\n\t// clear the purged blocks\n\t_mi_bitmap_unclaim_across(arena-\u003eblocks_purge, arena-\u003efield_count, blocks, bitmap_idx);\n\t// update committed bitmap\n\tif (needs_recommit)\n\t\t_mi_bitmap_unclaim_across(arena-\u003eblocks_committed, arena-\u003efield_count, blocks, bitmap_idx);\n```",
      "range": {
        "startLine": 435,
        "startChar": 0,
        "endLine": 461,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "70d62002_dae96a54",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 485,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_arena_schedule_purge(mi_arena_t* arena, size_t bitmap_idx, size_t blocks, mi_stats_t* stats)\n{\n\tmi_assert_internal(arena-\u003eblocks_purge !\u003d NULL);\n\tconst long delay \u003d mi_arena_purge_delay();\n\tif (delay \u003c 0)\n\t\treturn; // is purging allowed at all?\n\n\tif (_mi_preloading() || delay \u003d\u003d 0) {\n\t\t// decommit directly\n\t\tmi_arena_purge(arena, bitmap_idx, blocks, stats);\n\t} else {\n\t\t// schedule decommit\n\t\tmi_msecs_t expire \u003d mi_atomic_loadi64_relaxed(\u0026arena-\u003epurge_expire);\n\t\tif (expire !\u003d 0)\n\t\t\tmi_atomic_addi64_acq_rel(\u0026arena-\u003epurge_expire, delay / 10); // add smallish extra delay\n\t\telse\n\t\t\tmi_atomic_storei64_release(\u0026arena-\u003epurge_expire, _mi_clock_now() + delay);\n\t\t_mi_bitmap_claim_across(arena-\u003eblocks_purge, arena-\u003efield_count, blocks, bitmap_idx, NULL);\n\t}\n```",
      "range": {
        "startLine": 466,
        "startChar": 0,
        "endLine": 485,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c0cf232b_2bf61354",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 511,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_arena_purge_range(mi_arena_t* arena, size_t idx, size_t startidx, size_t bitlen, size_t purge,\n\tmi_stats_t* stats)\n{\n\tconst size_t endidx \u003d startidx + bitlen;\n\tsize_t bitidx \u003d startidx;\n\tbool all_purged \u003d false;\n\twhile (bitidx \u003c endidx) {\n\t\t// count consequetive ones in the purge mask\n\t\tsize_t count \u003d 0;\n\t\twhile (bitidx + count \u003c endidx \u0026\u0026 (purge \u0026 ((size_t)1 \u003c\u003c (bitidx + count))) !\u003d 0)\n\t\t\tcount++;\n\t\tif (count \u003e 0) {\n\t\t\t// found range to be purged\n\t\t\tconst mi_bitmap_index_t range_idx \u003d mi_bitmap_index_create(idx, bitidx);\n\t\t\tmi_arena_purge(arena, range_idx, count, stats);\n\t\t\tif (count \u003d\u003d bitlen)\n\t\t\t\tall_purged \u003d true;\n\t\t}\n\t\tbitidx +\u003d (count + 1); // +1 to skip the zero bit (or end)\n\t}\n\treturn all_purged;\n```",
      "range": {
        "startLine": 491,
        "startChar": 0,
        "endLine": 511,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c968975e_6024b64b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 591,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_arena_try_purge(mi_arena_t* arena, mi_msecs_t now, bool force, mi_stats_t* stats)\n{\n\tif (arena-\u003ememid.is_pinned || arena-\u003eblocks_purge \u003d\u003d NULL)\n\t\treturn false;\n\tmi_msecs_t expire \u003d mi_atomic_loadi64_relaxed(\u0026arena-\u003epurge_expire);\n\tif (expire \u003d\u003d 0)\n\t\treturn false;\n\tif (!force \u0026\u0026 expire \u003e now)\n\t\treturn false;\n\n\t// reset expire (if not already set concurrently)\n\tmi_atomic_casi64_strong_acq_rel(\u0026arena-\u003epurge_expire, \u0026expire, 0);\n\n\t// potential purges scheduled, walk through the bitmap\n\tbool any_purged \u003d false;\n\tbool full_purge \u003d true;\n\tfor (size_t i \u003d 0; i \u003c arena-\u003efield_count; i++) {\n\t\tsize_t purge \u003d mi_atomic_load_relaxed(\u0026arena-\u003eblocks_purge[i]);\n\t\tif (purge !\u003d 0) {\n\t\t\tsize_t bitidx \u003d 0;\n\t\t\twhile (bitidx \u003c MI_BITMAP_FIELD_BITS) {\n\t\t\t\t// find consequetive range of ones in the purge mask\n\t\t\t\tsize_t bitlen \u003d 0;\n\t\t\t\twhile (bitidx + bitlen \u003c MI_BITMAP_FIELD_BITS\n\t\t\t\t\t\u0026\u0026 (purge \u0026 ((size_t)1 \u003c\u003c (bitidx + bitlen))) !\u003d 0) {\n\t\t\t\t\tbitlen++;\n\t\t\t\t}\n\t\t\t\t// try to claim the longest range of corresponding in_use bits\n\t\t\t\tconst mi_bitmap_index_t bitmap_index \u003d mi_bitmap_index_create(i, bitidx);\n\t\t\t\twhile (bitlen \u003e 0) {\n\t\t\t\t\tif (_mi_bitmap_try_claim(arena-\u003eblocks_inuse, arena-\u003efield_count, bitlen,\n\t\t\t\t\t\t\tbitmap_index)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbitlen--;\n\t\t\t\t}\n\t\t\t\t// actual claimed bits at `in_use`\n\t\t\t\tif (bitlen \u003e 0) {\n\t\t\t\t\t// read purge again now that we have the in_use bits\n\t\t\t\t\tpurge \u003d mi_atomic_load_acquire(\u0026arena-\u003eblocks_purge[i]);\n\t\t\t\t\tif (!mi_arena_purge_range(arena, i, bitidx, bitlen, purge, stats))\n\t\t\t\t\t\tfull_purge \u003d false;\n\t\t\t\t\tany_purged \u003d true;\n\t\t\t\t\t// release the claimed `in_use` bits again\n\t\t\t\t\t_mi_bitmap_unclaim(arena-\u003eblocks_inuse, arena-\u003efield_count, bitlen,\n\t\t\t\t\t\tbitmap_index);\n\t\t\t\t}\n\t\t\t\tbitidx +\u003d (bitlen + 1); // +1 to skip the zero (or end)\n\t\t\t} // while bitidx\n\t\t} // purge !\u003d 0\n\t}\n\t// if not fully purged, make sure to purge again in the future\n\tif (!full_purge) {\n\t\tconst long delay \u003d mi_arena_purge_delay();\n\t\tmi_msecs_t expected \u003d 0;\n\t\tmi_atomic_casi64_strong_acq_rel(\u0026arena-\u003epurge_expire, \u0026expected, _mi_clock_now() + delay);\n\t}\n\treturn any_purged;\n}\n\n\nstatic void\nmi_arenas_try_purge(bool force, bool visit_all, mi_stats_t* stats)\n{\n\tif (_mi_preloading() || mi_arena_purge_delay() \u003c\u003d 0)\n\t\treturn; // nothing will be scheduled\n\n\tconst size_t max_arena \u003d mi_atomic_load_acquire(\u0026mi_arena_count);\n\tif (max_arena \u003d\u003d 0)\n\t\treturn;\n\n\t// allow only one thread to purge at a time\n\tstatic mi_atomic_guard_t purge_guard;\n\tmi_atomic_guard(\u0026purge_guard)\n\t{\n\t\tmi_msecs_t now \u003d _mi_clock_now();\n\t\tsize_t max_purge_count \u003d (visit_all ? max_arena : 1);\n\t\tfor (size_t i \u003d 0; i \u003c max_arena; i++) {\n\t\t\tmi_arena_t* arena \u003d mi_atomic_load_ptr_acquire(mi_arena_t, \u0026mi_arenas[i]);\n\t\t\tif (arena !\u003d NULL) {\n\t\t\t\tif (mi_arena_try_purge(arena, now, force, stats)) {\n\t\t\t\t\tif (max_purge_count \u003c\u003d 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmax_purge_count--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```",
      "range": {
        "startLine": 515,
        "startChar": 0,
        "endLine": 591,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "48a5b097_a91ea7c4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 676,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_arena_free(void* p, size_t size, size_t committed_size, mi_memid_t memid, mi_stats_t* stats)\n{\n\tmi_assert_internal(size \u003e 0 \u0026\u0026 stats !\u003d NULL);\n\tmi_assert_internal(committed_size \u003c\u003d size);\n\tif (p \u003d\u003d NULL)\n\t\treturn;\n\tif (size \u003d\u003d 0)\n\t\treturn;\n\tconst bool all_committed \u003d (committed_size \u003d\u003d size);\n\n\tif (mi_memkind_is_os(memid.memkind)) {\n\t\t// was a direct OS allocation, pass through\n\t\tif (!all_committed \u0026\u0026 committed_size \u003e 0) {\n\t\t\t// if partially committed, adjust the committed stats (as `_mi_os_free` will increase\n\t\t\t// decommit by the full size)\n\t\t\t_mi_stat_decrease(\u0026stats-\u003ecommitted, committed_size);\n\t\t}\n\t\t_mi_os_free(p, size, memid, stats);\n\t} else if (memid.memkind \u003d\u003d MI_MEM_ARENA) {\n\t\t// allocated in an arena\n\t\tsize_t arena_idx;\n\t\tsize_t bitmap_idx;\n\t\tmi_arena_memid_indices(memid, \u0026arena_idx, \u0026bitmap_idx);\n\t\tmi_assert_internal(arena_idx \u003c MI_MAX_ARENAS);\n\t\tmi_arena_t* arena \u003d mi_atomic_load_ptr_acquire(mi_arena_t, \u0026mi_arenas[arena_idx]);\n\t\tmi_assert_internal(arena !\u003d NULL);\n\t\tconst size_t blocks \u003d mi_block_count_of_size(size);\n\n\t\t// checks\n\t\tif (arena \u003d\u003d NULL) {\n\t\t\t_mi_error_message(EINVAL,\n\t\t\t\t\"trying to free from non-existent arena: %p, size %zu, memid: 0x%zx\\n\", p, size,\n\t\t\t\tmemid);\n\t\t\treturn;\n\t\t}\n\t\tmi_assert_internal(arena-\u003efield_count \u003e mi_bitmap_index_field(bitmap_idx));\n\t\tif (arena-\u003efield_count \u003c\u003d mi_bitmap_index_field(bitmap_idx)) {\n\t\t\t_mi_error_message(EINVAL,\n\t\t\t\t\"trying to free from non-existent arena block: %p, size %zu, memid: 0x%zx\\n\", p,\n\t\t\t\tsize, memid);\n\t\t\treturn;\n\t\t}\n\n\t\t// need to set all memory to undefined as some parts may still be marked as no_access (like\n\t\t// padding etc.)\n\t\tmi_track_mem_undefined(p, size);\n\n\t\t// potentially decommit\n\t\tif (arena-\u003ememid.is_pinned || arena-\u003eblocks_committed \u003d\u003d NULL) {\n\t\t\tmi_assert_internal(all_committed);\n\t\t} else {\n\t\t\tmi_assert_internal(arena-\u003eblocks_committed !\u003d NULL);\n\t\t\tmi_assert_internal(arena-\u003eblocks_purge !\u003d NULL);\n\n\t\t\tif (!all_committed) {\n\t\t\t\t// mark the entire range as no longer committed (so we recommit the full range when\n\t\t\t\t// re-using)\n\t\t\t\t_mi_bitmap_unclaim_across(arena-\u003eblocks_committed, arena-\u003efield_count, blocks,\n\t\t\t\t\tbitmap_idx);\n\t\t\t\tmi_track_mem_noaccess(p, size);\n\t\t\t\tif (committed_size \u003e 0) {\n\t\t\t\t\t// if partially committed, adjust the committed stats (is it will be recommitted\n\t\t\t\t\t// when re-using) in the delayed purge, we now need to not count a decommit if\n\t\t\t\t\t// the range is not marked as committed.\n\t\t\t\t\t_mi_stat_decrease(\u0026stats-\u003ecommitted, committed_size);\n\t\t\t\t}\n\t\t\t\t// note: if not all committed, it may be that the purge will reset/decommit the\n\t\t\t\t// entire range that contains already decommitted parts. Since purge consistently\n\t\t\t\t// uses reset or decommit that works (as we should never reset decommitted parts).\n\t\t\t}\n\t\t\t// (delay) purge the entire range\n\t\t\tmi_arena_schedule_purge(arena, bitmap_idx, blocks, stats);\n\t\t}\n\n\t\t// and make it available to others again\n\t\tbool all_inuse \u003d _mi_bitmap_unclaim_across(arena-\u003eblocks_inuse, arena-\u003efield_count, blocks,\n\t\t\tbitmap_idx);\n\t\tif (!all_inuse) {\n\t\t\t_mi_error_message(EAGAIN, \"trying to free an already freed arena block: %p, size %zu\\n\",\n\t\t\t\tp, size);\n\t\t\treturn;\n\t\t};\n\t} else {\n\t\t// arena was none, external, or static; nothing to do\n\t\tmi_assert_internal(memid.memkind \u003c MI_MEM_OS);\n\t}\n\n\t// purge expired decommits\n\tmi_arenas_try_purge(false, false, stats);\n```",
      "range": {
        "startLine": 599,
        "startChar": 0,
        "endLine": 676,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "430b0867_c01a2f82",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 700,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_arenas_unsafe_destroy(void)\n{\n\tconst size_t max_arena \u003d mi_atomic_load_relaxed(\u0026mi_arena_count);\n\tsize_t new_max_arena \u003d 0;\n\tfor (size_t i \u003d 0; i \u003c max_arena; i++) {\n\t\tmi_arena_t* arena \u003d mi_atomic_load_ptr_acquire(mi_arena_t, \u0026mi_arenas[i]);\n\t\tif (arena !\u003d NULL) {\n\t\t\tif (arena-\u003estart !\u003d NULL \u0026\u0026 mi_memkind_is_os(arena-\u003ememid.memkind)) {\n\t\t\t\tmi_atomic_store_ptr_release(mi_arena_t, \u0026mi_arenas[i], NULL);\n\t\t\t\t_mi_os_free(arena-\u003estart, mi_arena_size(arena), arena-\u003ememid, \u0026_mi_stats_main);\n\t\t\t} else {\n\t\t\t\tnew_max_arena \u003d i;\n\t\t\t}\n\t\t\tmi_arena_meta_free(arena, arena-\u003emeta_memid, arena-\u003emeta_size, \u0026_mi_stats_main);\n\t\t}\n\t}\n\n\t// try to lower the max arena.\n\tsize_t expected \u003d max_arena;\n\tmi_atomic_cas_strong_acq_rel(\u0026mi_arena_count, \u0026expected, new_max_arena);\n```",
      "range": {
        "startLine": 681,
        "startChar": 0,
        "endLine": 700,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a46b7315_16ed84ef",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 705,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_arena_collect(bool force_purge, mi_stats_t* stats)\n{\n\tmi_arenas_try_purge(force_purge, true /* visit all */, stats);\n```",
      "range": {
        "startLine": 704,
        "startChar": 0,
        "endLine": 705,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "acdd0e03_894ca6b8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 712,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_arena_unsafe_destroy_all(mi_stats_t* stats)\n{\n\tmi_arenas_unsafe_destroy();\n\t_mi_arena_collect(true /* force purge */, stats); // purge non-owned arenas\n```",
      "range": {
        "startLine": 710,
        "startChar": 0,
        "endLine": 712,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4808b1d9_955af7df",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 724,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_arena_contains(const void* p)\n{\n\tconst size_t max_arena \u003d mi_atomic_load_relaxed(\u0026mi_arena_count);\n\tfor (size_t i \u003d 0; i \u003c max_arena; i++) {\n\t\tmi_arena_t* arena \u003d mi_atomic_load_ptr_acquire(mi_arena_t, \u0026mi_arenas[i]);\n\t\tif (arena !\u003d NULL \u0026\u0026 arena-\u003estart \u003c\u003d (const uint8_t*)p\n\t\t\t\u0026\u0026 arena-\u003estart + mi_arena_block_size(arena-\u003eblock_count) \u003e (const uint8_t*)p) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n```",
      "range": {
        "startLine": 716,
        "startChar": 0,
        "endLine": 724,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82b9f6fe_15502d12",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 805,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_arena_add(mi_arena_t* arena, mi_arena_id_t* arena_id)\n{\n\tmi_assert_internal(arena !\u003d NULL);\n\tmi_assert_internal(\n\t\t(uintptr_t)mi_atomic_load_ptr_relaxed(uint8_t, \u0026arena-\u003estart) % MI_SEGMENT_ALIGN \u003d\u003d 0);\n\tmi_assert_internal(arena-\u003eblock_count \u003e 0);\n\tif (arena_id !\u003d NULL)\n\t\t*arena_id \u003d -1;\n\n\tsize_t i \u003d mi_atomic_increment_acq_rel(\u0026mi_arena_count);\n\tif (i \u003e\u003d MI_MAX_ARENAS) {\n\t\tmi_atomic_decrement_acq_rel(\u0026mi_arena_count);\n\t\treturn false;\n\t}\n\tarena-\u003eid \u003d mi_arena_id_create(i);\n\tmi_atomic_store_ptr_release(mi_arena_t, \u0026mi_arenas[i], arena);\n\tif (arena_id !\u003d NULL)\n\t\t*arena_id \u003d arena-\u003eid;\n\treturn true;\n}\n\n\nstatic bool\nmi_manage_os_memory_ex2(void* start, size_t size, bool is_large, int numa_node, bool exclusive,\n\tmi_memid_t memid, mi_arena_id_t* arena_id) mi_attr_noexcept\n{\n\tif (arena_id !\u003d NULL)\n\t\t*arena_id \u003d _mi_arena_id_none();\n\tif (size \u003c MI_ARENA_BLOCK_SIZE)\n\t\treturn false;\n\n\tif (is_large)\n\t\tmi_assert_internal(memid.initially_committed \u0026\u0026 memid.is_pinned);\n\n\tconst size_t bcount \u003d size / MI_ARENA_BLOCK_SIZE;\n\tconst size_t fields \u003d _mi_divide_up(bcount, MI_BITMAP_FIELD_BITS);\n\tconst size_t bitmaps \u003d (memid.is_pinned ? 2 : 4);\n\tconst size_t asize \u003d sizeof(mi_arena_t) + (bitmaps * fields * sizeof(mi_bitmap_field_t));\n\tmi_memid_t meta_memid;\n\tmi_arena_t* arena \u003d (mi_arena_t*)mi_arena_meta_zalloc(asize, \u0026meta_memid,\n\t\t\u0026_mi_stats_main); // TODO: can we avoid allocating from the OS?\n\tif (arena \u003d\u003d NULL)\n\t\treturn false;\n\n\t// already zero\u0027d due to os_alloc\n\t// _mi_memzero(arena, asize);\n\tarena-\u003eid \u003d _mi_arena_id_none();\n\tarena-\u003ememid \u003d memid;\n\tarena-\u003eexclusive \u003d exclusive;\n\tarena-\u003emeta_size \u003d asize;\n\tarena-\u003emeta_memid \u003d meta_memid;\n\tarena-\u003eblock_count \u003d bcount;\n\tarena-\u003efield_count \u003d fields;\n\tarena-\u003estart \u003d (uint8_t*)start;\n\tarena-\u003enuma_node \u003d numa_node; // TODO: or get the current numa node if -1? (now it allows anyone\n\t\t\t\t\t\t\t\t  // to allocate on -1)\n\tarena-\u003eis_large \u003d is_large;\n\tarena-\u003epurge_expire \u003d 0;\n\tarena-\u003esearch_idx \u003d 0;\n\tarena-\u003eblocks_dirty \u003d \u0026arena-\u003eblocks_inuse[fields]; // just after inuse bitmap\n\tarena-\u003eblocks_committed\n\t\t\u003d (arena-\u003ememid.is_pinned ? NULL\n\t\t\t\t\t\t\t\t  : \u0026arena-\u003eblocks_inuse[2 * fields]); // just after dirty bitmap\n\tarena-\u003eblocks_purge \u003d (arena-\u003ememid.is_pinned\n\t\t\t? NULL\n\t\t\t: \u0026arena-\u003eblocks_inuse[3 * fields]); // just after committed bitmap\n\t// initialize committed bitmap?\n\tif (arena-\u003eblocks_committed !\u003d NULL \u0026\u0026 arena-\u003ememid.initially_committed) {\n\t\tmemset((void*)arena-\u003eblocks_committed, 0xFF,\n\t\t\tfields * sizeof(mi_bitmap_field_t)); // cast to void* to avoid atomic warning\n\t}\n\n\t// and claim leftover blocks if needed (so we never allocate there)\n\tptrdiff_t post \u003d (fields * MI_BITMAP_FIELD_BITS) - bcount;\n\tmi_assert_internal(post \u003e\u003d 0);\n\tif (post \u003e 0) {\n\t\t// don\u0027t use leftover bits at the end\n\t\tmi_bitmap_index_t postidx \u003d mi_bitmap_index_create(fields - 1, MI_BITMAP_FIELD_BITS - post);\n\t\t_mi_bitmap_claim(arena-\u003eblocks_inuse, fields, post, postidx, NULL);\n\t}\n\treturn mi_arena_add(arena, arena_id);\n}\n\n\nbool\nmi_manage_os_memory_ex(void* start, size_t size, bool is_committed, bool is_large, bool is_zero,\n\tint numa_node, bool exclusive, mi_arena_id_t* arena_id) mi_attr_noexcept\n{\n\tmi_memid_t memid \u003d _mi_memid_create(MI_MEM_EXTERNAL);\n\tmemid.initially_committed \u003d is_committed;\n\tmemid.initially_zero \u003d is_zero;\n\tmemid.is_pinned \u003d is_large;\n\treturn mi_manage_os_memory_ex2(start, size, is_large, numa_node, exclusive, memid, arena_id);\n```",
      "range": {
        "startLine": 732,
        "startChar": 0,
        "endLine": 805,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3e9be0c_7dbb2e1a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 822,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint\nmi_reserve_os_memory_ex(size_t size, bool commit, bool allow_large, bool exclusive,\n\tmi_arena_id_t* arena_id) mi_attr_noexcept\n{\n\tif (arena_id !\u003d NULL)\n\t\t*arena_id \u003d _mi_arena_id_none();\n\tsize \u003d _mi_align_up(size, MI_ARENA_BLOCK_SIZE); // at least one block\n\tmi_memid_t memid;\n\tvoid* start \u003d _mi_os_alloc_aligned(size, MI_SEGMENT_ALIGN, commit, allow_large, \u0026memid,\n\t\t\u0026_mi_stats_main);\n\tif (start \u003d\u003d NULL)\n\t\treturn ENOMEM;\n\tconst bool is_large \u003d memid.is_pinned; // todo: use separate is_large field?\n\tif (!mi_manage_os_memory_ex2(start, size, is_large, -1 /* numa node */, exclusive, memid,\n\t\t\tarena_id)) {\n\t\t_mi_os_free_ex(start, size, commit, memid, \u0026_mi_stats_main);\n\t\t_mi_verbose_message(\"failed to reserve %zu k memory\\n\", _mi_divide_up(size, 1024));\n\t\treturn ENOMEM;\n\t}\n\t_mi_verbose_message(\"reserved %zu KiB memory%s\\n\", _mi_divide_up(size, 1024),\n\t\tis_large ? \" (in large os pages)\" : \"\");\n\treturn 0;\n```",
      "range": {
        "startLine": 809,
        "startChar": 0,
        "endLine": 822,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72326f0a_46b2aa90",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 828,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\nmi_manage_os_memory(void* start, size_t size, bool is_committed, bool is_large, bool is_zero,\n\tint numa_node) mi_attr_noexcept\n{\n\treturn mi_manage_os_memory_ex(start, size, is_committed, is_large, is_zero, numa_node,\n\t\tfalse /* exclusive? */, NULL);\n```",
      "range": {
        "startLine": 827,
        "startChar": 0,
        "endLine": 828,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f12ba333_dd6cb65f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 833,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint\nmi_reserve_os_memory(size_t size, bool commit, bool allow_large) mi_attr_noexcept\n{\n\treturn mi_reserve_os_memory_ex(size, commit, allow_large, false, NULL);\n```",
      "range": {
        "startLine": 832,
        "startChar": 0,
        "endLine": 833,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5342b48f_13324dee",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 866,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic size_t\nmi_debug_show_bitmap(const char* prefix, mi_bitmap_field_t* fields, size_t field_count)\n{\n\tsize_t inuse_count \u003d 0;\n\tfor (size_t i \u003d 0; i \u003c field_count; i++) {\n\t\tchar buf[MI_BITMAP_FIELD_BITS + 1];\n\t\tuintptr_t field \u003d mi_atomic_load_relaxed(\u0026fields[i]);\n\t\tfor (size_t bit \u003d 0; bit \u003c MI_BITMAP_FIELD_BITS; bit++) {\n\t\t\tbool inuse \u003d ((((uintptr_t)1 \u003c\u003c bit) \u0026 field) !\u003d 0);\n\t\t\tif (inuse)\n\t\t\t\tinuse_count++;\n\t\t\tbuf[MI_BITMAP_FIELD_BITS - 1 - bit] \u003d (inuse ? \u0027x\u0027 : \u0027.\u0027);\n\t\t}\n\t\tbuf[MI_BITMAP_FIELD_BITS] \u003d 0;\n\t\t_mi_verbose_message(\"%s%s\\n\", prefix, buf);\n\t}\n\treturn inuse_count;\n}\n\n\nvoid\nmi_debug_show_arenas(void) mi_attr_noexcept\n{\n\tsize_t max_arenas \u003d mi_atomic_load_relaxed(\u0026mi_arena_count);\n\tfor (size_t i \u003d 0; i \u003c max_arenas; i++) {\n\t\tmi_arena_t* arena \u003d mi_atomic_load_ptr_relaxed(mi_arena_t, \u0026mi_arenas[i]);\n\t\tif (arena \u003d\u003d NULL)\n\t\t\tbreak;\n\t\tsize_t inuse_count \u003d 0;\n\t\t_mi_verbose_message(\"arena %zu: %zu blocks with %zu fields\\n\", i, arena-\u003eblock_count,\n\t\t\tarena-\u003efield_count);\n\t\tinuse_count +\u003d mi_debug_show_bitmap(\"  \", arena-\u003eblocks_inuse, arena-\u003efield_count);\n\t\t_mi_verbose_message(\"  blocks in use (\u0027x\u0027): %zu\\n\", inuse_count);\n\t}\n```",
      "range": {
        "startLine": 841,
        "startChar": 0,
        "endLine": 866,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "000dee2e_72d0c574",
        "filename": "src/system/libroot/posix/malloc/mimalloc/arena.c",
        "patchSetId": 7
      },
      "lineNbr": 936,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint\nmi_reserve_huge_os_pages_at_ex(size_t pages, int numa_node, size_t timeout_msecs, bool exclusive,\n\tmi_arena_id_t* arena_id) mi_attr_noexcept\n{\n\tif (arena_id !\u003d NULL)\n\t\t*arena_id \u003d -1;\n\tif (pages \u003d\u003d 0)\n\t\treturn 0;\n\tif (numa_node \u003c -1)\n\t\tnuma_node \u003d -1;\n\tif (numa_node \u003e\u003d 0)\n\t\tnuma_node \u003d numa_node % _mi_os_numa_node_count();\n\tsize_t hsize \u003d 0;\n\tsize_t pages_reserved \u003d 0;\n\tmi_memid_t memid;\n\tvoid* p \u003d _mi_os_alloc_huge_os_pages(pages, numa_node, timeout_msecs, \u0026pages_reserved, \u0026hsize,\n\t\t\u0026memid);\n\tif (p \u003d\u003d NULL || pages_reserved \u003d\u003d 0) {\n\t\t_mi_warning_message(\"failed to reserve %zu GiB huge pages\\n\", pages);\n\t\treturn ENOMEM;\n\t}\n\t_mi_verbose_message(\"numa node %i: reserved %zu GiB huge pages (of the %zu GiB requested)\\n\",\n\t\tnuma_node, pages_reserved, pages);\n\n\tif (!mi_manage_os_memory_ex2(p, hsize, true, numa_node, exclusive, memid, arena_id)) {\n\t\t_mi_os_free(p, hsize, memid, \u0026_mi_stats_main);\n\t\treturn ENOMEM;\n\t}\n\treturn 0;\n}\n\n\nint\nmi_reserve_huge_os_pages_at(size_t pages, int numa_node, size_t timeout_msecs) mi_attr_noexcept\n{\n\treturn mi_reserve_huge_os_pages_at_ex(pages, numa_node, timeout_msecs, false, NULL);\n}\n\n// reserve huge pages evenly among the given number of numa nodes (or use the available ones as\n// detected)\nint\nmi_reserve_huge_os_pages_interleave(size_t pages, size_t numa_nodes,\n\tsize_t timeout_msecs) mi_attr_noexcept\n{\n\tif (pages \u003d\u003d 0)\n\t\treturn 0;\n\n\t// pages per numa node\n\tsize_t numa_count \u003d (numa_nodes \u003e 0 ? numa_nodes : _mi_os_numa_node_count());\n\tif (numa_count \u003c\u003d 0)\n\t\tnuma_count \u003d 1;\n\tconst size_t pages_per \u003d pages / numa_count;\n\tconst size_t pages_mod \u003d pages % numa_count;\n\tconst size_t timeout_per \u003d (timeout_msecs \u003d\u003d 0 ? 0 : (timeout_msecs / numa_count) + 50);\n\n\t// reserve evenly among numa nodes\n\tfor (size_t numa_node \u003d 0; numa_node \u003c numa_count \u0026\u0026 pages \u003e 0; numa_node++) {\n\t\tsize_t node_pages \u003d pages_per; // can be 0\n\t\tif (numa_node \u003c pages_mod)\n\t\t\tnode_pages++;\n\t\tint err \u003d mi_reserve_huge_os_pages_at(node_pages, (int)numa_node, timeout_per);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (pages \u003c node_pages)\n\t\t\tpages \u003d 0;\n\t\telse\n\t\t\tpages -\u003d node_pages;\n\t}\n\n\treturn 0;\n}\n\n\nint\nmi_reserve_huge_os_pages(size_t pages, double max_secs, size_t* pages_reserved) mi_attr_noexcept\n{\n\tMI_UNUSED(max_secs);\n\t_mi_warning_message(\"mi_reserve_huge_os_pages is deprecated: use \"\n\t\t\t\t\t\t\"mi_reserve_huge_os_pages_interleave/at instead\\n\");\n\tif (pages_reserved !\u003d NULL)\n\t\t*pages_reserved \u003d 0;\n\tint err \u003d mi_reserve_huge_os_pages_interleave(pages, 0, (size_t)(max_secs * 1000.0));\n\tif (err \u003d\u003d 0 \u0026\u0026 pages_reserved !\u003d NULL)\n\t\t*pages_reserved \u003d pages;\n\treturn err;\n}\n```",
      "range": {
        "startLine": 874,
        "startChar": 0,
        "endLine": 936,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "948d0104_a55d91b9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 18,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"bitmap.h\"\n```",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f5a3731b_00f7f451",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 21,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52772cbc_62264cf8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 33,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_bitmap_mask_(size_t count, size_t bitidx)\n{\n\tmi_assert_internal(count + bitidx \u003c\u003d MI_BITMAP_FIELD_BITS);\n\tmi_assert_internal(count \u003e 0);\n\tif (count \u003e\u003d MI_BITMAP_FIELD_BITS)\n\t\treturn MI_BITMAP_FIELD_FULL;\n\tif (count \u003d\u003d 0)\n\t\treturn 0;\n\treturn (((size_t)1 \u003c\u003c count) - 1) \u003c\u003c bitidx;\n```",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 33,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f971475e_9bce7e11",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 54,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ninline bool\n_mi_bitmap_try_find_claim_field(mi_bitmap_t bitmap, size_t idx, const size_t count,\n\tmi_bitmap_index_t* bitmap_idx)\n{\n\tmi_assert_internal(bitmap_idx !\u003d NULL);\n\tmi_assert_internal(count \u003c\u003d MI_BITMAP_FIELD_BITS);\n\tmi_assert_internal(count \u003e 0);\n\tmi_bitmap_field_t* field \u003d \u0026bitmap[idx];\n\tsize_t map \u003d mi_atomic_load_relaxed(field);\n\tif (map \u003d\u003d MI_BITMAP_FIELD_FULL)\n\t\treturn false; // short cut\n\n\t// search for 0-bit sequence of length count\n\tconst size_t mask \u003d mi_bitmap_mask_(count, 0);\n\tconst size_t bitidx_max \u003d MI_BITMAP_FIELD_BITS - count;\n```",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 54,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "939c6e59_dd406b40",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 57,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tsize_t bitidx \u003d mi_ctz(~map); // quickly find the first zero bit if possible\n```",
      "range": {
        "startLine": 57,
        "startChar": 0,
        "endLine": 57,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5bedad47_c18d7452",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 59,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tsize_t bitidx \u003d 0; // otherwise start at 0\n```",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 59,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b1d84a3d_7a403a04",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 81,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tsize_t m \u003d (mask \u003c\u003c bitidx); // invariant: m \u003d\u003d mask shifted by bitidx\n\n\t// scan linearly for a free range of zero bits\n\twhile (bitidx \u003c\u003d bitidx_max) {\n\t\tconst size_t mapm \u003d (map \u0026 m);\n\t\tif (mapm \u003d\u003d 0) { // are the mask bits free at bitidx?\n\t\t\tmi_assert_internal((m \u003e\u003e bitidx) \u003d\u003d mask); // no overflow?\n\t\t\tconst size_t newmap \u003d (map | m);\n\t\t\tmi_assert_internal((newmap ^ map) \u003e\u003e bitidx \u003d\u003d mask);\n\t\t\tif (!mi_atomic_cas_strong_acq_rel(field, \u0026map, newmap)) { // TODO: use weak cas here?\n\t\t\t\t// no success, another thread claimed concurrently.. keep going (with updated `map`)\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t// success, we claimed the bits!\n\t\t\t\t*bitmap_idx \u003d mi_bitmap_index_create(idx, bitidx);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\t// on to the next bit range\n```",
      "range": {
        "startLine": 61,
        "startChar": 0,
        "endLine": 81,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "091c47f8_6271ab11",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 85,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t\tmi_assert_internal(mapm !\u003d 0);\n\t\t\tconst size_t shift \u003d (count \u003d\u003d 1 ? 1 : (MI_INTPTR_BITS - mi_clz(mapm) - bitidx));\n\t\t\tmi_assert_internal(shift \u003e 0 \u0026\u0026 shift \u003c\u003d count);\n```",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 85,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "229edd7b_9548a175",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 87,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t\tconst size_t shift \u003d 1;\n```",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 87,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93ea632f_8640ac0d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 94,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t\tbitidx +\u003d shift;\n\t\t\tm \u003c\u003c\u003d shift;\n\t\t}\n\t}\n\t// no bits found\n\treturn false;\n```",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 94,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "449ec6c0_76e2033d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 108,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_bitmap_try_find_from_claim(mi_bitmap_t bitmap, const size_t bitmap_fields,\n\tconst size_t start_field_idx, const size_t count, mi_bitmap_index_t* bitmap_idx)\n{\n\tsize_t idx \u003d start_field_idx;\n\tfor (size_t visited \u003d 0; visited \u003c bitmap_fields; visited++, idx++) {\n\t\tif (idx \u003e\u003d bitmap_fields) {\n\t\t\tidx \u003d 0;\n\t\t} // wrap\n\t\tif (_mi_bitmap_try_find_claim_field(bitmap, idx, count, bitmap_idx))\n\t\t\treturn true;\n\t}\n\treturn false;\n```",
      "range": {
        "startLine": 100,
        "startChar": 0,
        "endLine": 108,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d14a2972_19b7defe",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 127,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_bitmap_try_find_from_claim_pred(mi_bitmap_t bitmap, const size_t bitmap_fields,\n\tconst size_t start_field_idx, const size_t count, mi_bitmap_pred_fun_t pred_fun, void* pred_arg,\n\tmi_bitmap_index_t* bitmap_idx)\n{\n\tsize_t idx \u003d start_field_idx;\n\tfor (size_t visited \u003d 0; visited \u003c bitmap_fields; visited++, idx++) {\n\t\tif (idx \u003e\u003d bitmap_fields)\n\t\t\tidx \u003d 0; // wrap\n\t\tif (_mi_bitmap_try_find_claim_field(bitmap, idx, count, bitmap_idx)) {\n\t\t\tif (pred_fun \u003d\u003d NULL || pred_fun(*bitmap_idx, pred_arg))\n\t\t\t\treturn true;\n\t\t\t// predicate returned false, unclaim and look further\n\t\t\t_mi_bitmap_unclaim(bitmap, bitmap_fields, count, *bitmap_idx);\n\t\t}\n\t}\n\treturn false;\n```",
      "range": {
        "startLine": 112,
        "startChar": 0,
        "endLine": 127,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1851b5ba_005655b4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 139,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_bitmap_unclaim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx)\n{\n\tconst size_t idx \u003d mi_bitmap_index_field(bitmap_idx);\n\tconst size_t bitidx \u003d mi_bitmap_index_bit_in_field(bitmap_idx);\n\tconst size_t mask \u003d mi_bitmap_mask_(count, bitidx);\n\tmi_assert_internal(bitmap_fields \u003e idx);\n\tMI_UNUSED(bitmap_fields);\n\t// mi_assert_internal((bitmap[idx] \u0026 mask) \u003d\u003d mask);\n\tconst size_t prev \u003d mi_atomic_and_acq_rel(\u0026bitmap[idx], ~mask);\n\treturn (prev \u0026 mask) \u003d\u003d mask;\n```",
      "range": {
        "startLine": 132,
        "startChar": 0,
        "endLine": 139,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ae3258af_fcc08ca8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 167,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Returns `true` if all `count` bits were 0 previously. `any_zero` is `true` if there was at least\n// one zero bit.\nbool\n_mi_bitmap_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx, bool* any_zero)\n{\n\tconst size_t idx \u003d mi_bitmap_index_field(bitmap_idx);\n\tconst size_t bitidx \u003d mi_bitmap_index_bit_in_field(bitmap_idx);\n\tconst size_t mask \u003d mi_bitmap_mask_(count, bitidx);\n\tmi_assert_internal(bitmap_fields \u003e idx);\n\tMI_UNUSED(bitmap_fields);\n\t// mi_assert_internal(any_zero !\u003d NULL || (bitmap[idx] \u0026 mask) \u003d\u003d 0);\n\tsize_t prev \u003d mi_atomic_or_acq_rel(\u0026bitmap[idx], mask);\n\tif (any_zero !\u003d NULL)\n\t\t*any_zero \u003d ((prev \u0026 mask) !\u003d mask);\n\treturn (prev \u0026 mask) \u003d\u003d 0;\n}\n\n// Returns `true` if all `count` bits were 1. `any_ones` is `true` if there was at least one bit set\n// to one.\nstatic bool\nmi_bitmap_is_claimedx(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx, bool* any_ones)\n{\n\tconst size_t idx \u003d mi_bitmap_index_field(bitmap_idx);\n\tconst size_t bitidx \u003d mi_bitmap_index_bit_in_field(bitmap_idx);\n\tconst size_t mask \u003d mi_bitmap_mask_(count, bitidx);\n\tmi_assert_internal(bitmap_fields \u003e idx);\n\tMI_UNUSED(bitmap_fields);\n\tconst size_t field \u003d mi_atomic_load_relaxed(\u0026bitmap[idx]);\n\tif (any_ones !\u003d NULL)\n\t\t*any_ones \u003d ((field \u0026 mask) !\u003d 0);\n\treturn (field \u0026 mask) \u003d\u003d mask;\n}\n\n// Try to set `count` bits at `bitmap_idx` from 0 to 1 atomically.\n```",
      "range": {
        "startLine": 144,
        "startChar": 0,
        "endLine": 167,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26e49947_43e19b00",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 191,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_bitmap_try_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx)\n{\n\tconst size_t idx \u003d mi_bitmap_index_field(bitmap_idx);\n\tconst size_t bitidx \u003d mi_bitmap_index_bit_in_field(bitmap_idx);\n\tconst size_t mask \u003d mi_bitmap_mask_(count, bitidx);\n\tmi_assert_internal(bitmap_fields \u003e idx);\n\tMI_UNUSED(bitmap_fields);\n\tsize_t expected \u003d mi_atomic_load_relaxed(\u0026bitmap[idx]);\n\tdo {\n\t\tif ((expected \u0026 mask) !\u003d 0)\n\t\t\treturn false;\n\t} while (!mi_atomic_cas_strong_acq_rel(\u0026bitmap[idx], \u0026expected, expected | mask));\n\tmi_assert_internal((expected \u0026 mask) \u003d\u003d 0);\n\treturn true;\n}\n\n\nbool\n_mi_bitmap_is_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx)\n{\n\treturn mi_bitmap_is_claimedx(bitmap, bitmap_fields, count, bitmap_idx, NULL);\n}\n\n\nbool\n_mi_bitmap_is_any_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx)\n{\n\tbool any_ones;\n\tmi_bitmap_is_claimedx(bitmap, bitmap_fields, count, bitmap_idx, \u0026any_ones);\n\treturn any_ones;\n```",
      "range": {
        "startLine": 169,
        "startChar": 0,
        "endLine": 191,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b53617f_eb065ab3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 264,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_bitmap_try_find_claim_field_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t idx,\n\tconst size_t count, const size_t retries, mi_bitmap_index_t* bitmap_idx)\n{\n\tmi_assert_internal(bitmap_idx !\u003d NULL);\n\n\t// check initial trailing zeros\n\tmi_bitmap_field_t* field \u003d \u0026bitmap[idx];\n\tsize_t map \u003d mi_atomic_load_relaxed(field);\n\tconst size_t initial \u003d mi_clz(map); // count of initial zeros starting at idx\n\tmi_assert_internal(initial \u003c\u003d MI_BITMAP_FIELD_BITS);\n\tif (initial \u003d\u003d 0)\n\t\treturn false;\n\tif (initial \u003e\u003d count) {\n\t\treturn _mi_bitmap_try_find_claim_field(bitmap, idx, count,\n\t\t\tbitmap_idx); // no need to cross fields (this case won\u0027t happen for us)\n\t}\n\tif (_mi_divide_up(count - initial, MI_BITMAP_FIELD_BITS) \u003e\u003d (bitmap_fields - idx))\n\t\treturn false; // not enough entries\n\n\t// scan ahead\n\tsize_t found \u003d initial;\n\tsize_t mask \u003d 0; // mask bits for the final field\n\twhile (found \u003c count) {\n\t\tfield++;\n\t\tmap \u003d mi_atomic_load_relaxed(field);\n\t\tconst size_t mask_bits\n\t\t\t\u003d (found + MI_BITMAP_FIELD_BITS \u003c\u003d count ? MI_BITMAP_FIELD_BITS : (count - found));\n\t\tmi_assert_internal(mask_bits \u003e 0 \u0026\u0026 mask_bits \u003c\u003d MI_BITMAP_FIELD_BITS);\n\t\tmask \u003d mi_bitmap_mask_(mask_bits, 0);\n\t\tif ((map \u0026 mask) !\u003d 0)\n\t\t\treturn false; // some part is already claimed\n\t\tfound +\u003d mask_bits;\n\t}\n\tmi_assert_internal(field \u003c \u0026bitmap[bitmap_fields]);\n\n\t// we found a range of contiguous zeros up to the final field; mask contains mask in the final\n\t// field now try to claim the range atomically\n\tmi_bitmap_field_t* const final_field \u003d field;\n\tconst size_t final_mask \u003d mask;\n\tmi_bitmap_field_t* const initial_field \u003d \u0026bitmap[idx];\n\tconst size_t initial_idx \u003d MI_BITMAP_FIELD_BITS - initial;\n\tconst size_t initial_mask \u003d mi_bitmap_mask_(initial, initial_idx);\n\n\t// initial field\n\tsize_t newmap;\n\tfield \u003d initial_field;\n\tmap \u003d mi_atomic_load_relaxed(field);\n\tdo {\n\t\tnewmap \u003d (map | initial_mask);\n\t\tif ((map \u0026 initial_mask) !\u003d 0)\n\t\t\tgoto rollback;\n\t\t;\n\t} while (!mi_atomic_cas_strong_acq_rel(field, \u0026map, newmap));\n\n\t// intermediate fields\n\twhile (++field \u003c final_field) {\n\t\tnewmap \u003d MI_BITMAP_FIELD_FULL;\n\t\tmap \u003d 0;\n\t\tif (!mi_atomic_cas_strong_acq_rel(field, \u0026map, newmap))\n\t\t\tgoto rollback;\n\t}\n\n\t// final field\n\tmi_assert_internal(field \u003d\u003d final_field);\n\tmap \u003d mi_atomic_load_relaxed(field);\n\tdo {\n\t\tnewmap \u003d (map | final_mask);\n\t\tif ((map \u0026 final_mask) !\u003d 0)\n\t\t\tgoto rollback;\n\t} while (!mi_atomic_cas_strong_acq_rel(field, \u0026map, newmap));\n\n\t// claimed!\n\t*bitmap_idx \u003d mi_bitmap_index_create(idx, initial_idx);\n\treturn true;\n```",
      "range": {
        "startLine": 203,
        "startChar": 0,
        "endLine": 264,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d0aa6381_32f4da8a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 288,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// roll back intermediate fields\n\t// (we just failed to claim `field` so decrement first)\n\twhile (--field \u003e initial_field) {\n\t\tnewmap \u003d 0;\n\t\tmap \u003d MI_BITMAP_FIELD_FULL;\n\t\tmi_assert_internal(mi_atomic_load_relaxed(field) \u003d\u003d map);\n\t\tmi_atomic_store_release(field, newmap);\n\t}\n\tif (field\n\t\t\u003d\u003d initial_field) { // (if we failed on the initial field, `field + 1 \u003d\u003d initial_field`)\n\t\tmap \u003d mi_atomic_load_relaxed(field);\n\t\tdo {\n\t\t\tmi_assert_internal((map \u0026 initial_mask) \u003d\u003d initial_mask);\n\t\t\tnewmap \u003d (map \u0026 ~initial_mask);\n\t\t} while (!mi_atomic_cas_strong_acq_rel(field, \u0026map, newmap));\n\t}\n\t// retry? (we make a recursive call instead of goto to be able to use const declarations)\n\tif (retries \u003c\u003d 2) {\n\t\treturn mi_bitmap_try_find_claim_field_across(bitmap, bitmap_fields, idx, count, retries + 1,\n\t\t\tbitmap_idx);\n\t} else {\n\t\treturn false;\n\t}\n```",
      "range": {
        "startLine": 267,
        "startChar": 0,
        "endLine": 288,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b035a81_04d1b1b0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 316,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_bitmap_try_find_from_claim_across(mi_bitmap_t bitmap, const size_t bitmap_fields,\n\tconst size_t start_field_idx, const size_t count, mi_bitmap_index_t* bitmap_idx)\n{\n\tmi_assert_internal(count \u003e 0);\n\tif (count \u003c\u003d 2) {\n\t\t// we don\u0027t bother with crossover fields for small counts\n\t\treturn _mi_bitmap_try_find_from_claim(bitmap, bitmap_fields, start_field_idx, count,\n\t\t\tbitmap_idx);\n\t}\n\n\t// visit the fields\n\tsize_t idx \u003d start_field_idx;\n\tfor (size_t visited \u003d 0; visited \u003c bitmap_fields; visited++, idx++) {\n\t\tif (idx \u003e\u003d bitmap_fields) {\n\t\t\tidx \u003d 0;\n\t\t} // wrap\n\t\t// first try to claim inside a field\n\t\tif (count \u003c\u003d MI_BITMAP_FIELD_BITS) {\n\t\t\tif (_mi_bitmap_try_find_claim_field(bitmap, idx, count, bitmap_idx))\n\t\t\t\treturn true;\n\t\t}\n\t\t// if that fails, then try to claim across fields\n\t\tif (mi_bitmap_try_find_claim_field_across(bitmap, bitmap_fields, idx, count, 0, bitmap_idx))\n\t\t\treturn true;\n\t}\n\treturn false;\n```",
      "range": {
        "startLine": 294,
        "startChar": 0,
        "endLine": 316,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3aa6ae7_9a32af6e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 341,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic size_t\nmi_bitmap_mask_across(mi_bitmap_index_t bitmap_idx, size_t bitmap_fields, size_t count,\n\tsize_t* pre_mask, size_t* mid_mask, size_t* post_mask)\n{\n\tMI_UNUSED(bitmap_fields);\n\tconst size_t bitidx \u003d mi_bitmap_index_bit_in_field(bitmap_idx);\n\tif mi_likely (bitidx + count \u003c\u003d MI_BITMAP_FIELD_BITS) {\n\t\t*pre_mask \u003d mi_bitmap_mask_(count, bitidx);\n\t\t*mid_mask \u003d 0;\n\t\t*post_mask \u003d 0;\n\t\tmi_assert_internal(mi_bitmap_index_field(bitmap_idx) \u003c bitmap_fields);\n\t\treturn 0;\n\t} else {\n\t\tconst size_t pre_bits \u003d MI_BITMAP_FIELD_BITS - bitidx;\n\t\tmi_assert_internal(pre_bits \u003c count);\n\t\t*pre_mask \u003d mi_bitmap_mask_(pre_bits, bitidx);\n\t\tcount -\u003d pre_bits;\n\t\tconst size_t mid_count \u003d (count / MI_BITMAP_FIELD_BITS);\n\t\t*mid_mask \u003d MI_BITMAP_FIELD_FULL;\n\t\tcount %\u003d MI_BITMAP_FIELD_BITS;\n\t\t*post_mask \u003d (count \u003d\u003d 0 ? 0 : mi_bitmap_mask_(count, 0));\n\t\tmi_assert_internal(\n\t\t\tmi_bitmap_index_field(bitmap_idx) + mid_count + (count \u003d\u003d 0 ? 0 : 1) \u003c bitmap_fields);\n\t\treturn mid_count;\n\t}\n```",
      "range": {
        "startLine": 320,
        "startChar": 0,
        "endLine": 341,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cad05502_1c33633f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 364,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_bitmap_unclaim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx)\n{\n\tsize_t idx \u003d mi_bitmap_index_field(bitmap_idx);\n\tsize_t pre_mask;\n\tsize_t mid_mask;\n\tsize_t post_mask;\n\tsize_t mid_count\n\t\t\u003d mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, \u0026pre_mask, \u0026mid_mask, \u0026post_mask);\n\tbool all_one \u003d true;\n\tmi_bitmap_field_t* field \u003d \u0026bitmap[idx];\n\tsize_t prev \u003d mi_atomic_and_acq_rel(field++, ~pre_mask); // clear first part\n\tif ((prev \u0026 pre_mask) !\u003d pre_mask)\n\t\tall_one \u003d false;\n\twhile (mid_count-- \u003e 0) {\n\t\tprev \u003d mi_atomic_and_acq_rel(field++, ~mid_mask); // clear mid part\n\t\tif ((prev \u0026 mid_mask) !\u003d mid_mask)\n\t\t\tall_one \u003d false;\n\t}\n\tif (post_mask !\u003d 0) {\n\t\tprev \u003d mi_atomic_and_acq_rel(field, ~post_mask); // clear end part\n\t\tif ((prev \u0026 post_mask) !\u003d post_mask)\n\t\t\tall_one \u003d false;\n\t}\n\treturn all_one;\n```",
      "range": {
        "startLine": 346,
        "startChar": 0,
        "endLine": 364,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5daacba0_7c3963aa",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 392,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Returns `true` if all `count` bits were 0 previously. `any_zero` is `true` if there was at least\n// one zero bit.\nbool\n_mi_bitmap_claim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx, bool* pany_zero)\n{\n\tsize_t idx \u003d mi_bitmap_index_field(bitmap_idx);\n\tsize_t pre_mask;\n\tsize_t mid_mask;\n\tsize_t post_mask;\n\tsize_t mid_count\n\t\t\u003d mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, \u0026pre_mask, \u0026mid_mask, \u0026post_mask);\n\tbool all_zero \u003d true;\n\tbool any_zero \u003d false;\n\t_Atomic(size_t)* field \u003d \u0026bitmap[idx];\n\tsize_t prev \u003d mi_atomic_or_acq_rel(field++, pre_mask);\n\tif ((prev \u0026 pre_mask) !\u003d 0)\n\t\tall_zero \u003d false;\n\tif ((prev \u0026 pre_mask) !\u003d pre_mask)\n\t\tany_zero \u003d true;\n\twhile (mid_count-- \u003e 0) {\n\t\tprev \u003d mi_atomic_or_acq_rel(field++, mid_mask);\n\t\tif ((prev \u0026 mid_mask) !\u003d 0)\n\t\t\tall_zero \u003d false;\n\t\tif ((prev \u0026 mid_mask) !\u003d mid_mask)\n\t\t\tany_zero \u003d true;\n\t}\n\tif (post_mask !\u003d 0) {\n\t\tprev \u003d mi_atomic_or_acq_rel(field, post_mask);\n\t\tif ((prev \u0026 post_mask) !\u003d 0)\n\t\t\tall_zero \u003d false;\n\t\tif ((prev \u0026 post_mask) !\u003d post_mask)\n\t\t\tany_zero \u003d true;\n\t}\n\tif (pany_zero !\u003d NULL)\n\t\t*pany_zero \u003d any_zero;\n\treturn all_zero;\n```",
      "range": {
        "startLine": 368,
        "startChar": 0,
        "endLine": 392,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f9d8aff_bf6c35dc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.c",
        "patchSetId": 7
      },
      "lineNbr": 432,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_bitmap_is_claimedx_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx, bool* pany_ones)\n{\n\tsize_t idx \u003d mi_bitmap_index_field(bitmap_idx);\n\tsize_t pre_mask;\n\tsize_t mid_mask;\n\tsize_t post_mask;\n\tsize_t mid_count\n\t\t\u003d mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, \u0026pre_mask, \u0026mid_mask, \u0026post_mask);\n\tbool all_ones \u003d true;\n\tbool any_ones \u003d false;\n\tmi_bitmap_field_t* field \u003d \u0026bitmap[idx];\n\tsize_t prev \u003d mi_atomic_load_relaxed(field++);\n\tif ((prev \u0026 pre_mask) !\u003d pre_mask)\n\t\tall_ones \u003d false;\n\tif ((prev \u0026 pre_mask) !\u003d 0)\n\t\tany_ones \u003d true;\n\twhile (mid_count-- \u003e 0) {\n\t\tprev \u003d mi_atomic_load_relaxed(field++);\n\t\tif ((prev \u0026 mid_mask) !\u003d mid_mask)\n\t\t\tall_ones \u003d false;\n\t\tif ((prev \u0026 mid_mask) !\u003d 0)\n\t\t\tany_ones \u003d true;\n\t}\n\tif (post_mask !\u003d 0) {\n\t\tprev \u003d mi_atomic_load_relaxed(field);\n\t\tif ((prev \u0026 post_mask) !\u003d post_mask)\n\t\t\tall_ones \u003d false;\n\t\tif ((prev \u0026 post_mask) !\u003d 0)\n\t\t\tany_ones \u003d true;\n\t}\n\tif (pany_ones !\u003d NULL)\n\t\t*pany_ones \u003d any_ones;\n\treturn all_ones;\n}\n\n\nbool\n_mi_bitmap_is_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx)\n{\n\treturn mi_bitmap_is_claimedx_across(bitmap, bitmap_fields, count, bitmap_idx, NULL);\n}\n\n\nbool\n_mi_bitmap_is_any_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx)\n{\n\tbool any_ones;\n\tmi_bitmap_is_claimedx_across(bitmap, bitmap_fields, count, bitmap_idx, \u0026any_ones);\n\treturn any_ones;\n}\n```",
      "range": {
        "startLine": 398,
        "startChar": 0,
        "endLine": 432,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9970403e_c9ecdba9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 28,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_BITMAP_FIELD_BITS (8 * MI_SIZE_SIZE)\n#define MI_BITMAP_FIELD_FULL (~((size_t)0)) // all bits set\n```",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 28,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95b15c9d_b032b4c6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef _Atomic(size_t) mi_bitmap_field_t;\ntypedef mi_bitmap_field_t* mi_bitmap_t;\n```",
      "range": {
        "startLine": 31,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "62501fcf_cd977904",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_bitmap_index_t\nmi_bitmap_index_create(size_t idx, size_t bitidx)\n{\n\tmi_assert_internal(bitidx \u003c MI_BITMAP_FIELD_BITS);\n\treturn (idx * MI_BITMAP_FIELD_BITS) + bitidx;\n```",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 40,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "59b54cd9_9914e432",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 45,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_bitmap_index_t\nmi_bitmap_index_create_from_bit(size_t full_bitidx)\n{\n\treturn mi_bitmap_index_create(full_bitidx / MI_BITMAP_FIELD_BITS,\n\t\tfull_bitidx % MI_BITMAP_FIELD_BITS);\n```",
      "range": {
        "startLine": 44,
        "startChar": 0,
        "endLine": 45,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c32772ee_51f9f232",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 50,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_bitmap_index_field(mi_bitmap_index_t bitmap_idx)\n{\n\treturn bitmap_idx / MI_BITMAP_FIELD_BITS;\n```",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 50,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24d82f4c_c00bc8d1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_bitmap_index_bit_in_field(mi_bitmap_index_t bitmap_idx)\n{\n\treturn bitmap_idx % MI_BITMAP_FIELD_BITS;\n```",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 55,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6f513747_09034dbb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 60,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_bitmap_index_bit(mi_bitmap_index_t bitmap_idx)\n{\n\treturn bitmap_idx;\n```",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 60,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cf4eae50_377b8bcf",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 69,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_try_find_claim_field(mi_bitmap_t bitmap, size_t idx, const size_t count,\n\tmi_bitmap_index_t* bitmap_idx);\n```",
      "range": {
        "startLine": 69,
        "startChar": 0,
        "endLine": 69,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e93d7df_bcf8e474",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 73,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_try_find_from_claim(mi_bitmap_t bitmap, const size_t bitmap_fields,\n\tconst size_t start_field_idx, const size_t count, mi_bitmap_index_t* bitmap_idx);\n```",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7ad6e825_7f6ea659",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef bool(mi_cdecl* mi_bitmap_pred_fun_t)(mi_bitmap_index_t bitmap_idx, void* pred_arg);\nbool _mi_bitmap_try_find_from_claim_pred(mi_bitmap_t bitmap, const size_t bitmap_fields,\n\tconst size_t start_field_idx, const size_t count, mi_bitmap_pred_fun_t pred_fun, void* pred_arg,\n\tmi_bitmap_index_t* bitmap_idx);\n```",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 77,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4363b672_db78da03",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 81,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_unclaim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx);\n```",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f22a74f_730428d3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 83,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Try to set `count` bits at `bitmap_idx` from 0 to 1 atomically.\n```",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 83,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fd320f5_836f9338",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 85,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_try_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx);\n```",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 85,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7f0ab5f_5814e208",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 89,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Returns `true` if all `count` bits were 0 previously. `any_zero` is `true` if there was at least\n// one zero bit.\nbool _mi_bitmap_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx, bool* any_zero);\n```",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 89,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dfe2c736_ad70af83",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_is_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx);\nbool _mi_bitmap_is_any_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx);\n```",
      "range": {
        "startLine": 91,
        "startChar": 0,
        "endLine": 92,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e5bd2238_a84f45ee",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 102,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_try_find_from_claim_across(mi_bitmap_t bitmap, const size_t bitmap_fields,\n\tconst size_t start_field_idx, const size_t count, mi_bitmap_index_t* bitmap_idx);\n```",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cefab383_70f63962",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 106,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_unclaim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx);\n```",
      "range": {
        "startLine": 106,
        "startChar": 0,
        "endLine": 106,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ce497d6_702fc7e2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 110,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Returns `true` if all `count` bits were 0 previously. `any_zero` is `true` if there was at least\n// one zero bit.\nbool _mi_bitmap_claim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx, bool* pany_zero);\n```",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 110,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f87bf80a_d9eef3ca",
        "filename": "src/system/libroot/posix/malloc/mimalloc/bitmap.h",
        "patchSetId": 7
      },
      "lineNbr": 113,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_bitmap_is_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx);\nbool _mi_bitmap_is_any_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count,\n\tmi_bitmap_index_t bitmap_idx);\n```",
      "range": {
        "startLine": 112,
        "startChar": 0,
        "endLine": 113,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df161b03_75de6ff2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 8,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 8,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc013ffc_0faab0d3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 13,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \"mimalloc/prim.h\" // mi_prim_get_default_heap\n\n#include \u003cstring.h\u003e // memset, memcpy\n```",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 13,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b1c25391_7c2f9aa3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#pragma warning(disable : 4204) // non-constant aggregate initializer\n```",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7bb0aa03_877e946e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 24,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef bool(heap_page_visitor_fun)(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_t* page,\n\tvoid* arg1, void* arg2);\n```",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 24,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45d8ff65_e11534d2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 75,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_heap_visit_pages(mi_heap_t* heap, heap_page_visitor_fun* fn, void* arg1, void* arg2)\n{\n\tif (heap \u003d\u003d NULL || heap-\u003epage_count \u003d\u003d 0)\n\t\treturn 0;\n\n// visit all pages\n#if MI_DEBUG \u003e 1\n\tsize_t total \u003d heap-\u003epage_count;\n\tsize_t count \u003d 0;\n#endif\n\n\tfor (size_t i \u003d 0; i \u003c\u003d MI_BIN_FULL; i++) {\n\t\tmi_page_queue_t* pq \u003d \u0026heap-\u003epages[i];\n\t\tmi_page_t* page \u003d pq-\u003efirst;\n\t\twhile (page !\u003d NULL) {\n\t\t\tmi_page_t* next \u003d page-\u003enext; // save next in case the page gets removed from the queue\n\t\t\tmi_assert_internal(mi_page_heap(page) \u003d\u003d heap);\n#if MI_DEBUG \u003e 1\n\t\t\tcount++;\n#endif\n\t\t\tif (!fn(heap, pq, page, arg1, arg2))\n\t\t\t\treturn false;\n\t\t\tpage \u003d next; // and continue\n\t\t}\n\t}\n\tmi_assert_internal(count \u003d\u003d total);\n\treturn true;\n}\n\n\n#if MI_DEBUG \u003e\u003d 2\n\n\nstatic bool\nmi_heap_page_is_valid(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_t* page, void* arg1, void* arg2)\n{\n\tMI_UNUSED(arg1);\n\tMI_UNUSED(arg2);\n\tMI_UNUSED(pq);\n\tmi_assert_internal(mi_page_heap(page) \u003d\u003d heap);\n\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\tmi_assert_internal(segment-\u003ethread_id \u003d\u003d heap-\u003ethread_id);\n\tmi_assert_expensive(_mi_page_is_valid(page));\n\treturn true;\n}\n#endif\n#if MI_DEBUG \u003e\u003d 3\n\n\nstatic bool\nmi_heap_is_valid(mi_heap_t* heap)\n{\n\tmi_assert_internal(heap !\u003d NULL);\n\tmi_heap_visit_pages(heap, \u0026mi_heap_page_is_valid, NULL, NULL);\n\treturn true;\n}\n#endif\n```",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 75,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6761fa83_711dfdc4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 182,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef enum mi_collect_e { MI_NORMAL, MI_FORCE, MI_ABANDON } mi_collect_t;\n\n\nstatic bool\nmi_heap_page_collect(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_t* page, void* arg_collect,\n\tvoid* arg2)\n{\n\tMI_UNUSED(arg2);\n\tMI_UNUSED(heap);\n\tmi_assert_internal(mi_heap_page_is_valid(heap, pq, page, NULL, NULL));\n\tmi_collect_t collect \u003d *((mi_collect_t*)arg_collect);\n\t_mi_page_free_collect(page, collect \u003e\u003d MI_FORCE);\n\tif (mi_page_all_free(page)) {\n\t\t// no more used blocks, free the page.\n\t\t// note: this will free retired pages as well.\n\t\t_mi_page_free(page, pq, collect \u003e\u003d MI_FORCE);\n\t} else if (collect \u003d\u003d MI_ABANDON) {\n\t\t// still used blocks but the thread is done; abandon the page\n\t\t_mi_page_abandon(page, pq);\n\t}\n\treturn true; // don\u0027t break\n}\n\n\nstatic bool\nmi_heap_page_never_delayed_free(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_t* page, void* arg1,\n\tvoid* arg2)\n{\n\tMI_UNUSED(arg1);\n\tMI_UNUSED(arg2);\n\tMI_UNUSED(heap);\n\tMI_UNUSED(pq);\n\t_mi_page_use_delayed_free(page, MI_NEVER_DELAYED_FREE, false);\n\treturn true; // don\u0027t break\n}\n\n\nstatic void\nmi_heap_collect_ex(mi_heap_t* heap, mi_collect_t collect)\n{\n\tif (heap \u003d\u003d NULL || !mi_heap_is_initialized(heap))\n\t\treturn;\n\n\tconst bool force \u003d collect \u003e\u003d MI_FORCE;\n\t_mi_deferred_free(heap, force);\n\n\t// note: never reclaim on collect but leave it to threads that need storage to reclaim\n\tconst bool force_main \u003d\n#ifdef NDEBUG\n\t\tcollect \u003d\u003d MI_FORCE\n#else\n\t\tcollect \u003e\u003d MI_FORCE\n#endif\n\t\t\u0026\u0026 _mi_is_main_thread() \u0026\u0026 mi_heap_is_backing(heap) \u0026\u0026 !heap-\u003eno_reclaim;\n\n\tif (force_main) {\n\t\t// the main thread is abandoned (end-of-program), try to reclaim all abandoned segments.\n\t\t// if all memory is freed by now, all segments should be freed.\n\t\t_mi_abandoned_reclaim_all(heap, \u0026heap-\u003etld-\u003esegments);\n\t}\n\n\t// if abandoning, mark all pages to no longer add to delayed_free\n\tif (collect \u003d\u003d MI_ABANDON)\n\t\tmi_heap_visit_pages(heap, \u0026mi_heap_page_never_delayed_free, NULL, NULL);\n\n\t// free all current thread delayed blocks.\n\t// (if abandoning, after this there are no more thread-delayed references into the pages.)\n\t_mi_heap_delayed_free_all(heap);\n\n\t// collect retired pages\n\t_mi_heap_collect_retired(heap, force);\n\n\t// collect all pages owned by this thread\n\tmi_heap_visit_pages(heap, \u0026mi_heap_page_collect, \u0026collect, NULL);\n\tmi_assert_internal(collect !\u003d MI_ABANDON\n\t\t|| mi_atomic_load_ptr_acquire(mi_block_t, \u0026heap-\u003ethread_delayed_free) \u003d\u003d NULL);\n\n\t// collect abandoned segments (in particular, purge expired parts of segments in the abandoned\n\t// segment list) note: forced purge can be quite expensive if many threads are created/destroyed\n\t// so we do not force on abandonment\n\t_mi_abandoned_collect(heap, collect \u003d\u003d MI_FORCE /* force? */, \u0026heap-\u003etld-\u003esegments);\n\n\t// collect segment local caches\n\tif (force)\n\t\t_mi_segment_thread_collect(\u0026heap-\u003etld-\u003esegments);\n\n\t// collect regions on program-exit (or shared library unload)\n\tif (force \u0026\u0026 _mi_is_main_thread() \u0026\u0026 mi_heap_is_backing(heap)) {\n\t\t_mi_thread_data_collect(); // collect thread data cache\n\t\t_mi_arena_collect(true /* force purge */, \u0026heap-\u003etld-\u003estats);\n\t}\n}\n\n\nvoid\n_mi_heap_collect_abandon(mi_heap_t* heap)\n{\n\tmi_heap_collect_ex(heap, MI_ABANDON);\n}\n\n\nvoid\nmi_heap_collect(mi_heap_t* heap, bool force) mi_attr_noexcept\n{\n\tmi_heap_collect_ex(heap, (force ? MI_FORCE : MI_NORMAL));\n}\n\n\nvoid\nmi_collect(bool force) mi_attr_noexcept\n{\n\tmi_heap_collect(mi_prim_get_default_heap(), force);\n```",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 182,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "579b9a18_1fa67128",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 237,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_heap_t*\nmi_heap_get_default(void)\n{\n\tmi_thread_init();\n\treturn mi_prim_get_default_heap();\n}\n\n\nstatic bool\nmi_heap_is_default(const mi_heap_t* heap)\n{\n\treturn heap \u003d\u003d mi_prim_get_default_heap();\n}\n\n\nmi_heap_t*\nmi_heap_get_backing(void)\n{\n\tmi_heap_t* heap \u003d mi_heap_get_default();\n\tmi_assert_internal(heap !\u003d NULL);\n\tmi_heap_t* bheap \u003d heap-\u003etld-\u003eheap_backing;\n\tmi_assert_internal(bheap !\u003d NULL);\n\tmi_assert_internal(bheap-\u003ethread_id \u003d\u003d _mi_thread_id());\n\treturn bheap;\n}\n\n\nmi_decl_nodiscard mi_heap_t*\nmi_heap_new_in_arena(mi_arena_id_t arena_id)\n{\n\tmi_heap_t* bheap \u003d mi_heap_get_backing();\n\tmi_heap_t* heap \u003d mi_heap_malloc_tp(bheap, mi_heap_t); // todo: OS allocate in secure mode?\n\tif (heap \u003d\u003d NULL)\n\t\treturn NULL;\n\t_mi_memcpy_aligned(heap, \u0026_mi_heap_empty, sizeof(mi_heap_t));\n\theap-\u003etld \u003d bheap-\u003etld;\n\theap-\u003ethread_id \u003d _mi_thread_id();\n\theap-\u003earena_id \u003d arena_id;\n\t_mi_random_split(\u0026bheap-\u003erandom, \u0026heap-\u003erandom);\n\theap-\u003ecookie \u003d _mi_heap_random_next(heap) | 1;\n\theap-\u003ekeys[0] \u003d _mi_heap_random_next(heap);\n\theap-\u003ekeys[1] \u003d _mi_heap_random_next(heap);\n\theap-\u003eno_reclaim \u003d true; // don\u0027t reclaim abandoned pages or otherwise destroy is unsafe\n\t// push on the thread local heaps list\n\theap-\u003enext \u003d heap-\u003etld-\u003eheaps;\n\theap-\u003etld-\u003eheaps \u003d heap;\n\treturn heap;\n}\n\n\nmi_decl_nodiscard mi_heap_t*\nmi_heap_new(void)\n{\n\treturn mi_heap_new_in_arena(_mi_arena_id_none());\n}\n\n\nbool\n_mi_heap_memid_is_suitable(mi_heap_t* heap, mi_memid_t memid)\n{\n\treturn _mi_arena_memid_is_suitable(memid, heap-\u003earena_id);\n}\n\n\nuintptr_t\n_mi_heap_random_next(mi_heap_t* heap)\n{\n\treturn _mi_random_next(\u0026heap-\u003erandom);\n```",
      "range": {
        "startLine": 190,
        "startChar": 0,
        "endLine": 237,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "683e3d07_ac506d26",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 248,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_heap_reset_pages(mi_heap_t* heap)\n{\n\tmi_assert_internal(heap !\u003d NULL);\n\tmi_assert_internal(mi_heap_is_initialized(heap));\n\t// TODO: copy full empty heap instead?\n\tmemset(\u0026heap-\u003epages_free_direct, 0, sizeof(heap-\u003epages_free_direct));\n\t_mi_memcpy_aligned(\u0026heap-\u003epages, \u0026_mi_heap_empty.pages, sizeof(heap-\u003epages));\n\theap-\u003ethread_delayed_free \u003d NULL;\n\theap-\u003epage_count \u003d 0;\n```",
      "range": {
        "startLine": 241,
        "startChar": 0,
        "endLine": 248,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98c46fd9_f312d74e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 279,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_heap_free(mi_heap_t* heap)\n{\n\tmi_assert(heap !\u003d NULL);\n\tmi_assert_internal(mi_heap_is_initialized(heap));\n\tif (heap \u003d\u003d NULL || !mi_heap_is_initialized(heap))\n\t\treturn;\n\tif (mi_heap_is_backing(heap))\n\t\treturn; // dont free the backing heap\n\n\t// reset default\n\tif (mi_heap_is_default(heap))\n\t\t_mi_heap_set_default_direct(heap-\u003etld-\u003eheap_backing);\n\n\t// remove ourselves from the thread local heaps list\n\t// linear search but we expect the number of heaps to be relatively small\n\tmi_heap_t* prev \u003d NULL;\n\tmi_heap_t* curr \u003d heap-\u003etld-\u003eheaps;\n\twhile (curr !\u003d heap \u0026\u0026 curr !\u003d NULL) {\n\t\tprev \u003d curr;\n\t\tcurr \u003d curr-\u003enext;\n\t}\n\tmi_assert_internal(curr \u003d\u003d heap);\n\tif (curr \u003d\u003d heap) {\n\t\tif (prev !\u003d NULL)\n\t\t\tprev-\u003enext \u003d heap-\u003enext;\n\t\telse\n\t\t\theap-\u003etld-\u003eheaps \u003d heap-\u003enext;\n\t}\n\tmi_assert_internal(heap-\u003etld-\u003eheaps !\u003d NULL);\n\n\t// and free the used memory\n\tmi_free(heap);\n```",
      "range": {
        "startLine": 252,
        "startChar": 0,
        "endLine": 279,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a6aed46_fbe480f6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 305,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\n_mi_heap_page_destroy(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_t* page, void* arg1, void* arg2)\n{\n\tMI_UNUSED(arg1);\n\tMI_UNUSED(arg2);\n\tMI_UNUSED(heap);\n\tMI_UNUSED(pq);\n\n\t// ensure no more thread_delayed_free will be added\n\t_mi_page_use_delayed_free(page, MI_NEVER_DELAYED_FREE, false);\n\n\t// stats\n\tconst size_t bsize \u003d mi_page_block_size(page);\n\tif (bsize \u003e MI_MEDIUM_OBJ_SIZE_MAX) {\n\t\tif (bsize \u003c\u003d MI_LARGE_OBJ_SIZE_MAX)\n\t\t\tmi_heap_stat_decrease(heap, large, bsize);\n\t\telse\n\t\t\tmi_heap_stat_decrease(heap, huge, bsize);\n\t}\n```",
      "range": {
        "startLine": 287,
        "startChar": 0,
        "endLine": 305,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d0df91b_9108cb84",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 333,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t_mi_page_free_collect(page, false); // update used count\n\tconst size_t inuse \u003d page-\u003eused;\n\tif (bsize \u003c\u003d MI_LARGE_OBJ_SIZE_MAX) {\n\t\tmi_heap_stat_decrease(heap, normal, bsize * inuse);\n#if (MI_STAT \u003e 1)\n\t\tmi_heap_stat_decrease(heap, normal_bins[_mi_bin(bsize)], inuse);\n#endif\n\t}\n\tmi_heap_stat_decrease(heap, malloc, bsize * inuse); // todo: off for aligned blocks...\n#endif\n\n\t/// pretend it is all free now\n\tmi_assert_internal(mi_page_thread_free(page) \u003d\u003d NULL);\n\tpage-\u003eused \u003d 0;\n\n\t// and free the page\n\t// mi_page_free(page,false);\n\tpage-\u003enext \u003d NULL;\n\tpage-\u003eprev \u003d NULL;\n\t_mi_segment_page_free(page, false /* no force? */, \u0026heap-\u003etld-\u003esegments);\n\n\treturn true; // keep going\n}\n\n\nvoid\n_mi_heap_destroy_pages(mi_heap_t* heap)\n{\n\tmi_heap_visit_pages(heap, \u0026_mi_heap_page_destroy, NULL, NULL);\n\tmi_heap_reset_pages(heap);\n```",
      "range": {
        "startLine": 307,
        "startChar": 0,
        "endLine": 333,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ae7524d_a40a4a79",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 362,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic bool mi_cdecl\nmi_heap_track_block_free(const mi_heap_t* heap, const mi_heap_area_t* area, void* block,\n\tsize_t block_size, void* arg)\n{\n\tMI_UNUSED(heap);\n\tMI_UNUSED(area);\n\tMI_UNUSED(arg);\n\tMI_UNUSED(block_size);\n\tmi_track_free_size(block, mi_usable_size(block));\n\treturn true;\n}\n#endif\n\n\nvoid\nmi_heap_destroy(mi_heap_t* heap)\n{\n\tmi_assert(heap !\u003d NULL);\n\tmi_assert(mi_heap_is_initialized(heap));\n\tmi_assert(heap-\u003eno_reclaim);\n\tmi_assert_expensive(mi_heap_is_valid(heap));\n\tif (heap \u003d\u003d NULL || !mi_heap_is_initialized(heap))\n\t\treturn;\n\tif (!heap-\u003eno_reclaim) {\n\t\t// don\u0027t free in case it may contain reclaimed pages\n\t\tmi_heap_delete(heap);\n\t} else {\n// track all blocks as freed\n#if MI_TRACK_HEAP_DESTROY\n\t\tmi_heap_visit_blocks(heap, true, mi_heap_track_block_free, NULL);\n#endif\n\t\t// free all pages\n\t\t_mi_heap_destroy_pages(heap);\n\t\tmi_heap_free(heap);\n\t}\n```",
      "range": {
        "startLine": 337,
        "startChar": 0,
        "endLine": 362,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4a832e63_505fa700",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 378,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_heap_unsafe_destroy_all(void)\n{\n\tmi_heap_t* bheap \u003d mi_heap_get_backing();\n\tmi_heap_t* curr \u003d bheap-\u003etld-\u003eheaps;\n\twhile (curr !\u003d NULL) {\n\t\tmi_heap_t* next \u003d curr-\u003enext;\n\t\tif (curr-\u003eno_reclaim)\n\t\t\tmi_heap_destroy(curr);\n\t\telse\n\t\t\t_mi_heap_destroy_pages(curr);\n\t\tcurr \u003d next;\n\t}\n```",
      "range": {
        "startLine": 366,
        "startChar": 0,
        "endLine": 378,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "716e7884_2b04a528",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 416,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_heap_absorb(mi_heap_t* heap, mi_heap_t* from)\n{\n\tmi_assert_internal(heap !\u003d NULL);\n\tif (from \u003d\u003d NULL || from-\u003epage_count \u003d\u003d 0)\n\t\treturn;\n\n\t// reduce the size of the delayed frees\n\t_mi_heap_delayed_free_partial(from);\n\n\t// transfer all pages by appending the queues; this will set a new heap field\n\t// so threads may do delayed frees in either heap for a while.\n\t// note: appending waits for each page to not be in the `MI_DELAYED_FREEING` state\n\t// so after this only the new heap will get delayed frees\n\tfor (size_t i \u003d 0; i \u003c\u003d MI_BIN_FULL; i++) {\n\t\tmi_page_queue_t* pq \u003d \u0026heap-\u003epages[i];\n\t\tmi_page_queue_t* append \u003d \u0026from-\u003epages[i];\n\t\tsize_t pcount \u003d _mi_page_queue_append(heap, pq, append);\n\t\theap-\u003epage_count +\u003d pcount;\n\t\tfrom-\u003epage_count -\u003d pcount;\n\t}\n\tmi_assert_internal(from-\u003epage_count \u003d\u003d 0);\n\n\t// and do outstanding delayed frees in the `from` heap\n\t// note: be careful here as the `heap` field in all those pages no longer point to `from`,\n\t// turns out to be ok as `_mi_heap_delayed_free` only visits the list and calls a\n\t// the regular `_mi_free_delayed_block` which is safe.\n\t_mi_heap_delayed_free_all(from);\n#if !defined(_MSC_VER) \\\n\t|| (_MSC_VER \u003e 1900) // somehow the following line gives an error in VS2015, issue #353\n\tmi_assert_internal(mi_atomic_load_ptr_relaxed(mi_block_t, \u0026from-\u003ethread_delayed_free) \u003d\u003d NULL);\n#endif\n\n\t// and reset the `from` heap\n\tmi_heap_reset_pages(from);\n```",
      "range": {
        "startLine": 386,
        "startChar": 0,
        "endLine": 416,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97825416_4b117b22",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 449,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\nmi_heap_delete(mi_heap_t* heap)\n{\n\tmi_assert(heap !\u003d NULL);\n\tmi_assert(mi_heap_is_initialized(heap));\n\tmi_assert_expensive(mi_heap_is_valid(heap));\n\tif (heap \u003d\u003d NULL || !mi_heap_is_initialized(heap))\n\t\treturn;\n\n\tif (!mi_heap_is_backing(heap)) {\n\t\t// tranfer still used pages to the backing heap\n\t\tmi_heap_absorb(heap-\u003etld-\u003eheap_backing, heap);\n\t} else {\n\t\t// the backing heap abandons its pages\n\t\t_mi_heap_collect_abandon(heap);\n\t}\n\tmi_assert_internal(heap-\u003epage_count \u003d\u003d 0);\n\tmi_heap_free(heap);\n}\n\n\nmi_heap_t*\nmi_heap_set_default(mi_heap_t* heap)\n{\n\tmi_assert(heap !\u003d NULL);\n\tmi_assert(mi_heap_is_initialized(heap));\n\tif (heap \u003d\u003d NULL || !mi_heap_is_initialized(heap))\n\t\treturn NULL;\n\tmi_assert_expensive(mi_heap_is_valid(heap));\n\tmi_heap_t* old \u003d mi_prim_get_default_heap();\n\t_mi_heap_set_default_direct(heap);\n\treturn old;\n}\n```",
      "range": {
        "startLine": 420,
        "startChar": 0,
        "endLine": 449,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "785623b3_ca547d46",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 494,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_heap_t*\nmi_heap_of_block(const void* p)\n{\n\tif (p \u003d\u003d NULL)\n\t\treturn NULL;\n\tmi_segment_t* segment \u003d _mi_ptr_segment(p);\n\tbool valid \u003d (_mi_ptr_cookie(segment) \u003d\u003d segment-\u003ecookie);\n\tmi_assert_internal(valid);\n\tif mi_unlikely (!valid)\n\t\treturn NULL;\n\treturn mi_page_heap(_mi_segment_page_of(segment, p));\n}\n\n\nbool\nmi_heap_contains_block(mi_heap_t* heap, const void* p)\n{\n\tmi_assert(heap !\u003d NULL);\n\tif (heap \u003d\u003d NULL || !mi_heap_is_initialized(heap))\n\t\treturn false;\n\treturn heap \u003d\u003d mi_heap_of_block(p);\n}\n\n\nstatic bool\nmi_heap_page_check_owned(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_t* page, void* p,\n\tvoid* vfound)\n{\n\tMI_UNUSED(heap);\n\tMI_UNUSED(pq);\n\tbool* found \u003d (bool*)vfound;\n\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\tvoid* start \u003d _mi_page_start(segment, page, NULL);\n\tvoid* end \u003d (uint8_t*)start + (page-\u003ecapacity * mi_page_block_size(page));\n\t*found \u003d (p \u003e\u003d start \u0026\u0026 p \u003c end);\n\treturn !*found; // continue if not found\n}\n\n\nbool\nmi_heap_check_owned(mi_heap_t* heap, const void* p)\n{\n\tmi_assert(heap !\u003d NULL);\n\tif (heap \u003d\u003d NULL || !mi_heap_is_initialized(heap))\n\t\treturn false;\n\tif (((uintptr_t)p \u0026 (MI_INTPTR_SIZE - 1)) !\u003d 0)\n\t\treturn false; // only aligned pointers\n\tbool found \u003d false;\n\tmi_heap_visit_pages(heap, \u0026mi_heap_page_check_owned, (void*)p, \u0026found);\n\treturn found;\n}\n\n\nbool\nmi_check_owned(const void* p)\n{\n\treturn mi_heap_check_owned(mi_prim_get_default_heap(), p);\n```",
      "range": {
        "startLine": 457,
        "startChar": 0,
        "endLine": 494,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ab99dfc_540e4a6b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 500,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\tenable visiting all blocks of all heaps across threads\n```",
      "range": {
        "startLine": 500,
        "startChar": 0,
        "endLine": 500,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "669a3f5f_5a7eb5e2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 506,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_heap_area_t area;\n\tmi_page_t* page;\n```",
      "range": {
        "startLine": 505,
        "startChar": 0,
        "endLine": 506,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "86bb9c09_f971397b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 595,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic bool\nmi_heap_area_visit_blocks(const mi_heap_area_ex_t* xarea, mi_block_visit_fun* visitor, void* arg)\n{\n\tmi_assert(xarea !\u003d NULL);\n\tif (xarea \u003d\u003d NULL)\n\t\treturn true;\n\tconst mi_heap_area_t* area \u003d \u0026xarea-\u003earea;\n\tmi_page_t* page \u003d xarea-\u003epage;\n\tmi_assert(page !\u003d NULL);\n\tif (page \u003d\u003d NULL)\n\t\treturn true;\n\n\t_mi_page_free_collect(page, true);\n\tmi_assert_internal(page-\u003elocal_free \u003d\u003d NULL);\n\tif (page-\u003eused \u003d\u003d 0)\n\t\treturn true;\n\n\tconst size_t bsize \u003d mi_page_block_size(page);\n\tconst size_t ubsize \u003d mi_page_usable_block_size(page); // without padding\n\tsize_t psize;\n\tuint8_t* pstart \u003d _mi_page_start(_mi_page_segment(page), page, \u0026psize);\n\n\tif (page-\u003ecapacity \u003d\u003d 1) {\n\t\t// optimize page with one block\n\t\tmi_assert_internal(page-\u003eused \u003d\u003d 1 \u0026\u0026 page-\u003efree \u003d\u003d NULL);\n\t\treturn visitor(mi_page_heap(page), area, pstart, ubsize, arg);\n\t}\n\n// create a bitmap of free blocks.\n#define MI_MAX_BLOCKS (MI_SMALL_PAGE_SIZE / sizeof(void*))\n\tuintptr_t free_map[MI_MAX_BLOCKS / sizeof(uintptr_t)];\n\tmemset(free_map, 0, sizeof(free_map));\n\n#if MI_DEBUG \u003e 1\n\tsize_t free_count \u003d 0;\n#endif\n\tfor (mi_block_t* block \u003d page-\u003efree; block !\u003d NULL; block \u003d mi_block_next(page, block)) {\n#if MI_DEBUG \u003e 1\n\t\tfree_count++;\n#endif\n\t\tmi_assert_internal((uint8_t*)block \u003e\u003d pstart \u0026\u0026 (uint8_t*)block \u003c (pstart + psize));\n\t\tsize_t offset \u003d (uint8_t*)block - pstart;\n\t\tmi_assert_internal(offset % bsize \u003d\u003d 0);\n\t\tsize_t blockidx \u003d offset / bsize; // Todo: avoid division?\n\t\tmi_assert_internal(blockidx \u003c MI_MAX_BLOCKS);\n\t\tsize_t bitidx \u003d (blockidx / sizeof(uintptr_t));\n\t\tsize_t bit \u003d blockidx - (bitidx * sizeof(uintptr_t));\n\t\tfree_map[bitidx] |\u003d ((uintptr_t)1 \u003c\u003c bit);\n\t}\n\tmi_assert_internal(page-\u003ecapacity \u003d\u003d (free_count + page-\u003eused));\n\n// walk through all blocks skipping the free ones\n#if MI_DEBUG \u003e 1\n\tsize_t used_count \u003d 0;\n#endif\n\tfor (size_t i \u003d 0; i \u003c page-\u003ecapacity; i++) {\n\t\tsize_t bitidx \u003d (i / sizeof(uintptr_t));\n\t\tsize_t bit \u003d i - (bitidx * sizeof(uintptr_t));\n\t\tuintptr_t m \u003d free_map[bitidx];\n\t\tif (bit \u003d\u003d 0 \u0026\u0026 m \u003d\u003d UINTPTR_MAX) {\n\t\t\ti +\u003d (sizeof(uintptr_t) - 1); // skip a run of free blocks\n\t\t} else if ((m \u0026 ((uintptr_t)1 \u003c\u003c bit)) \u003d\u003d 0) {\n#if MI_DEBUG \u003e 1\n\t\t\tused_count++;\n#endif\n\t\t\tuint8_t* block \u003d pstart + (i * bsize);\n\t\t\tif (!visitor(mi_page_heap(page), area, block, ubsize, arg))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tmi_assert_internal(page-\u003eused \u003d\u003d used_count);\n\treturn true;\n}\n\ntypedef bool(\n\tmi_heap_area_visit_fun)(const mi_heap_t* heap, const mi_heap_area_ex_t* area, void* arg);\n\n\nstatic bool\nmi_heap_visit_areas_page(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_t* page, void* vfun,\n\tvoid* arg)\n{\n\tMI_UNUSED(heap);\n\tMI_UNUSED(pq);\n\tmi_heap_area_visit_fun* fun \u003d (mi_heap_area_visit_fun*)vfun;\n\tmi_heap_area_ex_t xarea;\n\tconst size_t bsize \u003d mi_page_block_size(page);\n\tconst size_t ubsize \u003d mi_page_usable_block_size(page);\n\txarea.page \u003d page;\n\txarea.area.reserved \u003d page-\u003ereserved * bsize;\n\txarea.area.committed \u003d page-\u003ecapacity * bsize;\n\txarea.area.blocks \u003d _mi_page_start(_mi_page_segment(page), page, NULL);\n\txarea.area.used \u003d page-\u003eused; // number of blocks in use (#553)\n\txarea.area.block_size \u003d ubsize;\n\txarea.area.full_block_size \u003d bsize;\n\treturn fun(heap, \u0026xarea, arg);\n```",
      "range": {
        "startLine": 509,
        "startChar": 0,
        "endLine": 595,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a547614_8eff05a0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 601,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_heap_visit_areas(const mi_heap_t* heap, mi_heap_area_visit_fun* visitor, void* arg)\n{\n\tif (visitor \u003d\u003d NULL)\n\t\treturn false;\n\treturn mi_heap_visit_pages((mi_heap_t*)heap, \u0026mi_heap_visit_areas_page, (void*)(visitor),\n\t\targ); // note: function pointer to void* :-{\n```",
      "range": {
        "startLine": 599,
        "startChar": 0,
        "endLine": 601,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e3626488_05c8ba16",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 608,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tbool visit_blocks;\n\tmi_block_visit_fun* visitor;\n\tvoid* arg;\n```",
      "range": {
        "startLine": 606,
        "startChar": 0,
        "endLine": 608,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9b6317ef_dc658cf2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 619,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic bool\nmi_heap_area_visitor(const mi_heap_t* heap, const mi_heap_area_ex_t* xarea, void* arg)\n{\n\tmi_visit_blocks_args_t* args \u003d (mi_visit_blocks_args_t*)arg;\n\tif (!args-\u003evisitor(heap, \u0026xarea-\u003earea, NULL, xarea-\u003earea.block_size, args-\u003earg))\n\t\treturn false;\n\tif (args-\u003evisit_blocks)\n\t\treturn mi_heap_area_visit_blocks(xarea, args-\u003evisitor, args-\u003earg);\n\telse\n\t\treturn true;\n```",
      "range": {
        "startLine": 611,
        "startChar": 0,
        "endLine": 619,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f607b68_3e7ad620",
        "filename": "src/system/libroot/posix/malloc/mimalloc/heap.c",
        "patchSetId": 7
      },
      "lineNbr": 626,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\nmi_heap_visit_blocks(const mi_heap_t* heap, bool visit_blocks, mi_block_visit_fun* visitor,\n\tvoid* arg)\n{\n\tmi_visit_blocks_args_t args \u003d {visit_blocks, visitor, arg};\n\treturn mi_heap_visit_areas(heap, \u0026mi_heap_area_visitor, \u0026args);\n}\n```",
      "range": {
        "startLine": 623,
        "startChar": 0,
        "endLine": 626,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f6f0afee_92e53e12",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 12,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cstdlib.h\u003e // atexit\n#include \u003cstring.h\u003e // memcpy, memset\n```",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "422a91b3_9b6eba0c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t0, false, false, false,\n\t0, // capacity\n\t0, // reserved capacity\n\t{0}, // flags\n\tfalse, // is_zero\n\t0, // retire_expire\n\tNULL, // free\n\t0, // used\n\t0, // xblock_size\n\tNULL, // local_free\n#if (MI_PADDING || MI_ENCODE_FREELIST)\n\t{0, 0},\n#endif\n\tMI_ATOMIC_VAR_INIT(0), // xthread_free\n\tMI_ATOMIC_VAR_INIT(0), // xheap\n\tNULL, NULL\n#if MI_INTPTR_SIZE \u003d\u003d 8\n\t,\n\t{0} // padding\n#endif\n```",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 39,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "684ea611_6a1fb5a0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 50,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_SMALL_WSIZE_MAX \u003d\u003d 128)\n#if (MI_PADDING \u003e 0) \u0026\u0026 (MI_INTPTR_SIZE \u003e\u003d 8)\n#define MI_SMALL_PAGES_EMPTY \\\n\t{ \\\n\t\tMI_INIT128(MI_PAGE_EMPTY), MI_PAGE_EMPTY(), MI_PAGE_EMPTY() \\\n\t}\n#elif (MI_PADDING \u003e 0)\n#define MI_SMALL_PAGES_EMPTY \\\n\t{ \\\n\t\tMI_INIT128(MI_PAGE_EMPTY), MI_PAGE_EMPTY(), MI_PAGE_EMPTY(), MI_PAGE_EMPTY() \\\n\t}\n#else\n#define MI_SMALL_PAGES_EMPTY \\\n\t{ \\\n\t\tMI_INIT128(MI_PAGE_EMPTY), MI_PAGE_EMPTY() \\\n\t}\n```",
      "range": {
        "startLine": 44,
        "startChar": 0,
        "endLine": 50,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bbfc8b2f_dcc7eae6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 57,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define QNULL(sz) \\\n\t{ \\\n\t\tNULL, NULL, (sz) * sizeof(uintptr_t) \\\n\t}\n```",
      "range": {
        "startLine": 57,
        "startChar": 0,
        "endLine": 57,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b067c63_252baf13",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 72,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t{ \\\n\t\tQNULL(1), QNULL(1), QNULL(2), QNULL(3), QNULL(4), QNULL(5), QNULL(6), QNULL(7), \\\n\t\t\tQNULL(8), /* 8 */ \\\n\t\t\tQNULL(10), QNULL(12), QNULL(14), QNULL(16), QNULL(20), QNULL(24), QNULL(28), \\\n\t\t\tQNULL(32), /* 16 */ \\\n\t\t\tQNULL(40), QNULL(48), QNULL(56), QNULL(64), QNULL(80), QNULL(96), QNULL(112), \\\n\t\t\tQNULL(128), /* 24 */ \\\n\t\t\tQNULL(160), QNULL(192), QNULL(224), QNULL(256), QNULL(320), QNULL(384), QNULL(448), \\\n\t\t\tQNULL(512), /* 32 */ \\\n\t\t\tQNULL(640), QNULL(768), QNULL(896), QNULL(1024), QNULL(1280), QNULL(1536), \\\n\t\t\tQNULL(1792), QNULL(2048), /* 40 */ \\\n\t\t\tQNULL(2560), QNULL(3072), QNULL(3584), QNULL(4096), QNULL(5120), QNULL(6144), \\\n\t\t\tQNULL(7168), QNULL(8192), /* 48 */ \\\n\t\t\tQNULL(10240), QNULL(12288), QNULL(14336), QNULL(16384), QNULL(20480), QNULL(24576), \\\n\t\t\tQNULL(28672), QNULL(32768), /* 56 */ \\\n\t\t\tQNULL(40960), QNULL(49152), QNULL(57344), QNULL(65536), QNULL(81920), QNULL(98304), \\\n\t\t\tQNULL(114688), QNULL(131072), /* 64 */ \\\n\t\t\tQNULL(163840), QNULL(196608), QNULL(229376), QNULL(262144), QNULL(327680), \\\n\t\t\tQNULL(393216), QNULL(458752), QNULL(524288), /* 72 */ \\\n\t\t\tQNULL(MI_MEDIUM_OBJ_WSIZE_MAX + 1 /* 655360, Huge queue */), \\\n\t\t\tQNULL(MI_MEDIUM_OBJ_WSIZE_MAX + 2) /* Full queue */ \\\n\t}\n\n#define MI_STAT_COUNT_NULL() \\\n\t{ \\\n\t\t0, 0, 0, 0 \\\n\t}\n```",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 72,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4256d925_37d6adac",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 76,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if MI_STAT \u003e 1\n#define MI_STAT_COUNT_END_NULL() \\\n\t, \\\n\t{ \\\n\t\tMI_STAT_COUNT_NULL(), MI_INIT32(MI_STAT_COUNT_NULL) \\\n\t}\n```",
      "range": {
        "startLine": 75,
        "startChar": 0,
        "endLine": 76,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "410701b1_caced0dc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_STATS_NULL \\\n\tMI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \\\n\t\tMI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \\\n\t\tMI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \\\n\t\tMI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), {0, 0}, {0, 0}, {0, 0}, \\\n\t\t{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} MI_STAT_COUNT_END_NULL()\n```",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 92,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96c0d1b0_ad612e4c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 96,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define SQNULL(sz) \\\n\t{ \\\n\t\tNULL, NULL, sz \\\n\t}\n```",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 96,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1a5be3d_e6cb8add",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 103,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t{ \\\n\t\tSQNULL(1), SQNULL(1), SQNULL(2), SQNULL(3), SQNULL(4), SQNULL(5), SQNULL(6), SQNULL(7), \\\n\t\t\tSQNULL(10), /*  8 */ \\\n\t\t\tSQNULL(12), SQNULL(14), SQNULL(16), SQNULL(20), SQNULL(24), SQNULL(28), SQNULL(32), \\\n\t\t\tSQNULL(40), /* 16 */ \\\n\t\t\tSQNULL(48), SQNULL(56), SQNULL(64), SQNULL(80), SQNULL(96), SQNULL(112), SQNULL(128), \\\n\t\t\tSQNULL(160), /* 24 */ \\\n\t\t\tSQNULL(192), SQNULL(224), SQNULL(256), SQNULL(320), SQNULL(384), SQNULL(448), \\\n\t\t\tSQNULL(512), SQNULL(640), /* 32 */ \\\n\t\t\tSQNULL(768), SQNULL(896), SQNULL(1024) /* 35 */ \\\n\t}\n```",
      "range": {
        "startLine": 98,
        "startChar": 0,
        "endLine": 103,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9f77796_1827ab15",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 128,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_cache_align const mi_heap_t _mi_heap_empty\n\t\u003d {NULL, MI_SMALL_PAGES_EMPTY, MI_PAGE_QUEUES_EMPTY, MI_ATOMIC_VAR_INIT(NULL),\n\t\t0, // tid\n\t\t0, // cookie\n\t\t0, // arena id\n\t\t{0, 0}, // keys\n\t\t{{0}, {0}, 0, true}, // random\n\t\t0, // page count\n\t\tMI_BIN_FULL, 0, // page retired min/max\n\t\tNULL, // next\n\t\tfalse};\n\n#define tld_empty_stats ((mi_stats_t*)((uint8_t*)\u0026tld_empty + offsetof(mi_tld_t, stats)))\n#define tld_empty_os ((mi_os_tld_t*)((uint8_t*)\u0026tld_empty + offsetof(mi_tld_t, os)))\n\nmi_decl_cache_align static const mi_tld_t tld_empty \u003d {\n\t0, false, NULL, NULL,\n\t{MI_SEGMENT_SPAN_QUEUES_EMPTY, 0, 0, 0, 0, tld_empty_stats, tld_empty_os}, // segments\n\t{0, tld_empty_stats}, // os\n\t{MI_STATS_NULL} // stats\n```",
      "range": {
        "startLine": 115,
        "startChar": 0,
        "endLine": 128,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf7e3eed_eb0e2d87",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 144,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nmi_threadid_t\n_mi_thread_id(void) mi_attr_noexcept\n{\n\treturn _mi_prim_thread_id();\n```",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 144,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e80358ee_6cedcbc8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 157,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t0, false, \u0026_mi_heap_main, \u0026_mi_heap_main,\n\t{MI_SEGMENT_SPAN_QUEUES_EMPTY, 0, 0, 0, 0, \u0026tld_main.stats, \u0026tld_main.os}, // segments\n\t{0, \u0026tld_main.stats}, // os\n\t{MI_STATS_NULL} // stats\n```",
      "range": {
        "startLine": 153,
        "startChar": 0,
        "endLine": 157,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2842023a_c0f25a5f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 173,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\u0026tld_main, MI_SMALL_PAGES_EMPTY, MI_PAGE_QUEUES_EMPTY, MI_ATOMIC_VAR_INIT(NULL),\n\t0, // thread id\n\t0, // initial cookie\n\t0, // arena id\n\t{0, 0}, // the key of the main heap can be fixed (unlike page keys that need to be secure!)\n\t{{0x846ca68b}, {0}, 0, true}, // random\n\t0, // page count\n\tMI_BIN_FULL, 0, // page retired min/max\n\tNULL, // next heap\n\tfalse // can reclaim\n```",
      "range": {
        "startLine": 161,
        "startChar": 0,
        "endLine": 173,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a2fc702f_613027d5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 198,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_process_is_initialized \u003d false; // set to `true` in `mi_process_init`.\n\nmi_stats_t _mi_stats_main \u003d {MI_STATS_NULL};\n\n\nstatic void\nmi_heap_main_init(void)\n{\n\tif (_mi_heap_main.cookie \u003d\u003d 0) {\n\t\t_mi_heap_main.thread_id \u003d _mi_thread_id();\n\t\t_mi_heap_main.cookie \u003d 1;\n#if defined(_WIN32) \u0026\u0026 !defined(MI_SHARED_LIB) || defined(__HAIKU__)\n\t\t_mi_random_init_weak(\u0026_mi_heap_main.random); // prevent allocation failure during bcrypt dll\n\t\t\t\t\t\t\t\t\t\t\t\t\t // initialization with static linking\n#else\n\t\t_mi_random_init(\u0026_mi_heap_main.random);\n#endif\n\t\t_mi_heap_main.cookie \u003d _mi_heap_random_next(\u0026_mi_heap_main);\n\t\t_mi_heap_main.keys[0] \u003d _mi_heap_random_next(\u0026_mi_heap_main);\n\t\t_mi_heap_main.keys[1] \u003d _mi_heap_random_next(\u0026_mi_heap_main);\n\t}\n}\n\n\nmi_heap_t*\n_mi_heap_main_get(void)\n{\n\tmi_heap_main_init();\n\treturn \u0026_mi_heap_main;\n```",
      "range": {
        "startLine": 176,
        "startChar": 0,
        "endLine": 198,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "753ed2ea_c69589f2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 210,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_heap_t heap; // must come first due to cast in `_mi_heap_done`\n\tmi_tld_t tld;\n\tmi_memid_t memid;\n```",
      "range": {
        "startLine": 208,
        "startChar": 0,
        "endLine": 210,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89d0d87b_316a8b48",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 286,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic mi_thread_data_t*\nmi_thread_data_zalloc(void)\n{\n\t// try to find thread metadata in the cache\n\tbool is_zero \u003d false;\n\tmi_thread_data_t* td \u003d NULL;\n\tfor (int i \u003d 0; i \u003c TD_CACHE_SIZE; i++) {\n\t\ttd \u003d mi_atomic_load_ptr_relaxed(mi_thread_data_t, \u0026td_cache[i]);\n\t\tif (td !\u003d NULL) {\n\t\t\t// found cached allocation, try use it\n\t\t\ttd \u003d mi_atomic_exchange_ptr_acq_rel(mi_thread_data_t, \u0026td_cache[i], NULL);\n\t\t\tif (td !\u003d NULL)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// if that fails, allocate as meta data\n\tif (td \u003d\u003d NULL) {\n\t\tmi_memid_t memid;\n\t\ttd \u003d (mi_thread_data_t*)_mi_os_alloc(sizeof(mi_thread_data_t), \u0026memid, \u0026_mi_stats_main);\n\t\tif (td \u003d\u003d NULL) {\n\t\t\t// if this fails, try once more. (issue #257)\n\t\t\ttd \u003d (mi_thread_data_t*)_mi_os_alloc(sizeof(mi_thread_data_t), \u0026memid, \u0026_mi_stats_main);\n\t\t\tif (td \u003d\u003d NULL) {\n\t\t\t\t// really out of memory\n\t\t\t\t_mi_error_message(ENOMEM,\n\t\t\t\t\t\"unable to allocate thread local heap metadata (%zu bytes)\\n\",\n\t\t\t\t\tsizeof(mi_thread_data_t));\n\t\t\t}\n\t\t}\n\t\tif (td !\u003d NULL) {\n\t\t\ttd-\u003ememid \u003d memid;\n\t\t\tis_zero \u003d memid.initially_zero;\n\t\t}\n\t}\n\n\tif (td !\u003d NULL \u0026\u0026 !is_zero)\n\t\t_mi_memzero_aligned(td, sizeof(*td));\n\treturn td;\n}\n\n\nstatic void\nmi_thread_data_free(mi_thread_data_t* tdfree)\n{\n\t// try to add the thread metadata to the cache\n\tfor (int i \u003d 0; i \u003c TD_CACHE_SIZE; i++) {\n\t\tmi_thread_data_t* td \u003d mi_atomic_load_ptr_relaxed(mi_thread_data_t, \u0026td_cache[i]);\n\t\tif (td \u003d\u003d NULL) {\n\t\t\tmi_thread_data_t* expected \u003d NULL;\n\t\t\tif (mi_atomic_cas_ptr_weak_acq_rel(mi_thread_data_t, \u0026td_cache[i], \u0026expected, tdfree))\n\t\t\t\treturn;\n\t\t}\n\t}\n\t// if that fails, just free it directly\n\t_mi_os_free(tdfree, sizeof(mi_thread_data_t), tdfree-\u003ememid, \u0026_mi_stats_main);\n}\n\n\nvoid\n_mi_thread_data_collect(void)\n{\n\t// free all thread metadata from the cache\n\tfor (int i \u003d 0; i \u003c TD_CACHE_SIZE; i++) {\n\t\tmi_thread_data_t* td \u003d mi_atomic_load_ptr_relaxed(mi_thread_data_t, \u0026td_cache[i]);\n\t\tif (td !\u003d NULL) {\n\t\t\ttd \u003d mi_atomic_exchange_ptr_acq_rel(mi_thread_data_t, \u0026td_cache[i], NULL);\n\t\t\tif (td !\u003d NULL)\n\t\t\t\t_mi_os_free(td, sizeof(mi_thread_data_t), td-\u003ememid, \u0026_mi_stats_main);\n\t\t}\n\t}\n```",
      "range": {
        "startLine": 222,
        "startChar": 0,
        "endLine": 286,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5dedb8f5_961554fb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 308,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\n_mi_heap_init(void)\n{\n\tif (mi_heap_is_initialized(mi_prim_get_default_heap()))\n\t\treturn true;\n\tif (_mi_is_main_thread()) {\n\t\t// mi_assert_internal(_mi_heap_main.thread_id !\u003d 0);  // can happen on freeBSD where alloc\n\t\t// is called before any initialization the main heap is statically allocated\n\t\tmi_heap_main_init();\n\t\t_mi_heap_set_default_direct(\u0026_mi_heap_main);\n\t\t// mi_assert_internal(_mi_heap_default-\u003etld-\u003eheap_backing \u003d\u003d mi_prim_get_default_heap());\n\t} else {\n\t\t// use `_mi_os_alloc` to allocate directly from the OS\n\t\tmi_thread_data_t* td \u003d mi_thread_data_zalloc();\n\t\tif (td \u003d\u003d NULL)\n\t\t\treturn false;\n\n\t\tmi_tld_t* tld \u003d \u0026td-\u003etld;\n\t\tmi_heap_t* heap \u003d \u0026td-\u003eheap;\n\t\t_mi_memcpy_aligned(tld, \u0026tld_empty, sizeof(*tld));\n\t\t_mi_memcpy_aligned(heap, \u0026_mi_heap_empty, sizeof(*heap));\n\t\theap-\u003ethread_id \u003d _mi_thread_id();\n```",
      "range": {
        "startLine": 290,
        "startChar": 0,
        "endLine": 308,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f8ae4840_59d69016",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 325,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t_mi_random_init_weak(\u0026heap-\u003erandom);\n#else\n\t\t_mi_random_init(\u0026heap-\u003erandom);\n#endif\n\t\theap-\u003ecookie \u003d _mi_heap_random_next(heap) | 1;\n\t\theap-\u003ekeys[0] \u003d _mi_heap_random_next(heap);\n\t\theap-\u003ekeys[1] \u003d _mi_heap_random_next(heap);\n\t\theap-\u003etld \u003d tld;\n\t\ttld-\u003eheap_backing \u003d heap;\n\t\ttld-\u003eheaps \u003d heap;\n\t\ttld-\u003esegments.stats \u003d \u0026tld-\u003estats;\n\t\ttld-\u003esegments.os \u003d \u0026tld-\u003eos;\n\t\ttld-\u003eos.stats \u003d \u0026tld-\u003estats;\n\t\t_mi_heap_set_default_direct(heap);\n\t}\n\treturn false;\n```",
      "range": {
        "startLine": 310,
        "startChar": 0,
        "endLine": 325,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7a77b40e_e1e8da68",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 369,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\n_mi_heap_done(mi_heap_t* heap)\n{\n\tif (!mi_heap_is_initialized(heap))\n\t\treturn true;\n\n\t// reset default heap\n\t_mi_heap_set_default_direct(\n\t\t_mi_is_main_thread() ? \u0026_mi_heap_main : (mi_heap_t*)\u0026_mi_heap_empty);\n\n\t// switch to backing heap\n\theap \u003d heap-\u003etld-\u003eheap_backing;\n\tif (!mi_heap_is_initialized(heap))\n\t\treturn false;\n\n\t// delete all non-backing heaps in this thread\n\tmi_heap_t* curr \u003d heap-\u003etld-\u003eheaps;\n\twhile (curr !\u003d NULL) {\n\t\tmi_heap_t* next \u003d curr-\u003enext; // save `next` as `curr` will be freed\n\t\tif (curr !\u003d heap) {\n\t\t\tmi_assert_internal(!mi_heap_is_backing(curr));\n\t\t\tmi_heap_delete(curr);\n\t\t}\n\t\tcurr \u003d next;\n\t}\n\tmi_assert_internal(heap-\u003etld-\u003eheaps \u003d\u003d heap \u0026\u0026 heap-\u003enext \u003d\u003d NULL);\n\tmi_assert_internal(mi_heap_is_backing(heap));\n\n\t// collect if not the main thread\n\tif (heap !\u003d \u0026_mi_heap_main)\n\t\t_mi_heap_collect_abandon(heap);\n\n\t// merge stats\n\t_mi_stats_done(\u0026heap-\u003etld-\u003estats);\n\n\t// free if not the main thread\n\tif (heap !\u003d \u0026_mi_heap_main) {\n\t\t// the following assertion does not always hold for huge segments as those are always\n\t\t// treated as abondened: one may allocate it in one thread, but deallocate in another in\n\t\t// which case the count can be too large or negative. todo: perhaps not count huge segments?\n\t\t// see issue #363 mi_assert_internal(heap-\u003etld-\u003esegments.count \u003d\u003d 0 || heap-\u003ethread_id !\u003d\n\t\t// _mi_thread_id());\n\t\tmi_thread_data_free((mi_thread_data_t*)heap);\n\t} else {\n#if 0\n```",
      "range": {
        "startLine": 329,
        "startChar": 0,
        "endLine": 369,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8fd148f6_d59c188f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 378,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#endif\n\t}\n\treturn false;\n}\n```",
      "range": {
        "startLine": 374,
        "startChar": 0,
        "endLine": 378,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bc291fc2_02140f06",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 408,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_process_setup_auto_thread_done(void)\n{\n\tstatic bool tls_initialized \u003d false; // fine if it races\n\tif (tls_initialized)\n\t\treturn;\n\ttls_initialized \u003d true;\n\t_mi_prim_thread_init_auto_done();\n\t_mi_heap_set_default_direct(\u0026_mi_heap_main);\n}\n\n\nbool\n_mi_is_main_thread(void)\n{\n\treturn _mi_heap_main.thread_id \u003d\u003d 0 || _mi_heap_main.thread_id \u003d\u003d _mi_thread_id();\n```",
      "range": {
        "startLine": 398,
        "startChar": 0,
        "endLine": 408,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c445d281_3790ef7a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 414,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nsize_t\n_mi_current_thread_count(void)\n{\n\treturn mi_atomic_load_relaxed(\u0026thread_count);\n```",
      "range": {
        "startLine": 413,
        "startChar": 0,
        "endLine": 414,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30ff6d7e_1ac80885",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 475,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\nmi_thread_init(void) mi_attr_noexcept\n{\n\t// ensure our process has started already\n\tmi_process_init();\n\n\t// initialize the thread local default heap\n\t// (this will call `_mi_heap_set_default_direct` and thus set the\n\t//  fiber/pthread key to a non-zero value, ensuring `_mi_thread_done` is called)\n\tif (_mi_heap_init())\n\t\treturn; // returns true if already initialized\n\n\t_mi_stat_increase(\u0026_mi_stats_main.threads, 1);\n\tmi_atomic_increment_relaxed(\u0026thread_count);\n\t//_mi_verbose_message(\"thread init: 0x%zx\\n\", _mi_thread_id());\n}\n\n\nvoid\nmi_thread_done(void) mi_attr_noexcept\n{\n\t_mi_thread_done(NULL);\n}\n\n\nvoid\n_mi_thread_done(mi_heap_t* heap)\n{\n\t// calling with NULL implies using the default heap\n\tif (heap \u003d\u003d NULL) {\n\t\theap \u003d mi_prim_get_default_heap();\n\t\tif (heap \u003d\u003d NULL)\n\t\t\treturn;\n\t}\n\n\t// prevent re-entrancy through heap_done/heap_set_default_direct (issue #699)\n\tif (!mi_heap_is_initialized(heap))\n\t\treturn;\n\n\t// adjust stats\n\tmi_atomic_decrement_relaxed(\u0026thread_count);\n\t_mi_stat_decrease(\u0026_mi_stats_main.threads, 1);\n\n\t// check thread-id as on Windows shutdown with FLS the main (exit) thread may call this on\n\t// thread-local heaps...\n\tif (heap-\u003ethread_id !\u003d _mi_thread_id())\n\t\treturn;\n\n\t// abandon the thread local heap\n\tif (_mi_heap_done(heap))\n\t\treturn; // returns true if already ran\n}\n\n\nvoid\n_mi_heap_set_default_direct(mi_heap_t* heap)\n{\n\tmi_assert_internal(heap !\u003d NULL);\n#if defined(MI_TLS_SLOT)\n\tmi_prim_tls_slot_set(MI_TLS_SLOT, heap);\n#elif defined(MI_TLS_PTHREAD_SLOT_OFS)\n\t*mi_tls_pthread_heap_slot() \u003d heap;\n#elif defined(MI_TLS_PTHREAD)\n// we use _mi_heap_default_key\n#else\n\t_mi_heap_default \u003d heap;\n#endif\n\n\t// ensure the default heap is passed to `_mi_thread_done`\n\t// setting to a non-NULL value also ensures `mi_thread_done` is called.\n\t_mi_prim_thread_associate_default_heap(heap);\n```",
      "range": {
        "startLine": 418,
        "startChar": 0,
        "endLine": 475,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "365032d0_ca6519bc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 493,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool os_preloading \u003d true; // true until this module is initialized\nstatic bool mi_redirected \u003d false; // true if malloc redirects to mi_malloc\n\n// Returns true if this module has not been initialized; Don\u0027t use C runtime routines until it\n// returns false.\nbool mi_decl_noinline\n_mi_preloading(void)\n{\n\treturn os_preloading;\n}\n\n\nmi_decl_nodiscard bool\nmi_is_redirected(void) mi_attr_noexcept\n{\n\treturn mi_redirected;\n```",
      "range": {
        "startLine": 484,
        "startChar": 0,
        "endLine": 493,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa3787fe_b589dbdb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 514,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\"\n{\n#endif\n\tmi_decl_export void _mi_redirect_entry(DWORD reason)\n\t{\n\t\t// called on redirection; careful as this may be called before DllMain\n\t\tif (reason \u003d\u003d DLL_PROCESS_ATTACH)\n\t\t\tmi_redirected \u003d true;\n\t\telse if (reason \u003d\u003d DLL_PROCESS_DETACH)\n\t\t\tmi_redirected \u003d false;\n\t\telse if (reason \u003d\u003d DLL_THREAD_DETACH)\n\t\t\tmi_thread_done();\n\t}\n\t__declspec(dllimport) bool mi_cdecl mi_allocator_init(const char** message);\n\t__declspec(dllimport) void mi_cdecl mi_allocator_done(void);\n```",
      "range": {
        "startLine": 499,
        "startChar": 0,
        "endLine": 514,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f36b08f1_bf70fd7a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 524,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic bool\nmi_allocator_init(const char** message)\n{\n\tif (message !\u003d NULL)\n\t\t*message \u003d NULL;\n\treturn true;\n}\n\n\nstatic void\nmi_allocator_done(void)\n{\n\t// nothing to do\n```",
      "range": {
        "startLine": 519,
        "startChar": 0,
        "endLine": 524,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e10be8cd_d5d46a09",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 553,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_process_load(void)\n{\n\tmi_heap_main_init();\n#if defined(__APPLE__) || defined(MI_TLS_RECURSE_GUARD)\n\tvolatile mi_heap_t* dummy\n\t\t\u003d _mi_heap_default; // access TLS to allocate it before setting tls_initialized to true;\n\tif (dummy \u003d\u003d NULL)\n\t\treturn; // use dummy or otherwise the access may get optimized away (issue #697)\n#endif\n\tos_preloading \u003d false;\n\tmi_assert_internal(_mi_is_main_thread());\n#if !(defined(_WIN32) \\\n\t\u0026\u0026 defined( \\\n\t\tMI_SHARED_LIB)) // use Dll process detach (see below) instead of atexit (issue #521)\n\tatexit(\u0026mi_process_done);\n#endif\n\t_mi_options_init();\n\tmi_process_setup_auto_thread_done();\n\tmi_process_init();\n\tif (mi_redirected)\n\t\t_mi_verbose_message(\"malloc is redirected.\\n\");\n\n\t// show message from the redirector (if present)\n\tconst char* msg \u003d NULL;\n\tmi_allocator_init(\u0026msg);\n\tif (msg !\u003d NULL\n\t\t\u0026\u0026 (mi_option_is_enabled(mi_option_verbose)\n\t\t\t|| mi_option_is_enabled(mi_option_show_errors))) {\n\t\t_mi_fputs(NULL, NULL, NULL, msg);\n\t}\n\n\t// reseed random\n\t_mi_random_reinit_if_weak(\u0026_mi_heap_main.random);\n```",
      "range": {
        "startLine": 529,
        "startChar": 0,
        "endLine": 553,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "212f5e17_60f1c4de",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 568,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void\nmi_detect_cpu_features(void)\n{\n\t// FSRM for fast rep movsb support (AMD Zen3+ (~2020) or Intel Ice Lake+ (~2017))\n\tint32_t cpu_info[4];\n\t__cpuid(cpu_info, 7);\n\t_mi_cpu_has_fsrm \u003d ((cpu_info[3] \u0026 (1 \u003c\u003c 4))\n\t\t!\u003d 0); // bit 4 of EDX : see\n\t\t\t   // \u003chttps://en.wikipedia.org/wiki/CPUID#EAX\u003d7,_ECX\u003d0:_Extended_Features\u003e\n}\n#else\n\n\nstatic void\nmi_detect_cpu_features(void)\n{\n\t// nothing\n```",
      "range": {
        "startLine": 560,
        "startChar": 0,
        "endLine": 568,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d88da6f1_a9a3b6c7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 576,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\nmi_process_init(void) mi_attr_noexcept\n{\n\t// ensure we are called once\n\tstatic mi_atomic_once_t process_init;\n#if _MSC_VER \u003c 1920\n```",
      "range": {
        "startLine": 573,
        "startChar": 0,
        "endLine": 576,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e6e28df3_2588db3a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 621,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#endif\n\tif (!mi_atomic_once(\u0026process_init))\n\t\treturn;\n\t_mi_process_is_initialized \u003d true;\n\t_mi_verbose_message(\"process init: 0x%zx\\n\", _mi_thread_id());\n\tmi_process_setup_auto_thread_done();\n\n\tmi_detect_cpu_features();\n\t_mi_os_init();\n\tmi_heap_main_init();\n#if MI_DEBUG\n\t_mi_verbose_message(\"debug level : %d\\n\", MI_DEBUG);\n#endif\n\t_mi_verbose_message(\"secure level: %d\\n\", MI_SECURE);\n\t_mi_verbose_message(\"mem tracking: %s\\n\", MI_TRACK_TOOL);\n#if MI_TSAN\n\t_mi_verbose_message(\"thread santizer enabled\\n\");\n#endif\n\tmi_thread_init();\n\n#if defined(_WIN32)\n\t// On windows, when building as a static lib the FLS cleanup happens to early for the main\n\t// thread. To avoid this, set the FLS value for the main thread to NULL so the fls cleanup will\n\t// not call _mi_thread_done on the (still executing) main thread. See issue #508.\n\t_mi_prim_thread_associate_default_heap(NULL);\n#endif\n\n\tmi_stats_reset(); // only call stat reset *after* thread init (or the heap tld \u003d\u003d NULL)\n\tmi_track_init();\n\n\tif (mi_option_is_enabled(mi_option_reserve_huge_os_pages)) {\n\t\tsize_t pages \u003d mi_option_get_clamp(mi_option_reserve_huge_os_pages, 0, 128 * 1024);\n\t\tlong reserve_at \u003d mi_option_get(mi_option_reserve_huge_os_pages_at);\n\t\tif (reserve_at !\u003d -1)\n\t\t\tmi_reserve_huge_os_pages_at(pages, reserve_at, pages * 500);\n\t\telse\n\t\t\tmi_reserve_huge_os_pages_interleave(pages, 0, pages * 500);\n\t}\n\tif (mi_option_is_enabled(mi_option_reserve_os_memory)) {\n\t\tlong ksize \u003d mi_option_get(mi_option_reserve_os_memory);\n\t\tif (ksize \u003e 0) {\n\t\t\tmi_reserve_os_memory((size_t)ksize * MI_KiB, true /* commit? */,\n\t\t\t\ttrue /* allow large pages? */);\n\t\t}\n\t}\n```",
      "range": {
        "startLine": 578,
        "startChar": 0,
        "endLine": 621,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9533ef8_66c4fbf6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 661,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void mi_cdecl\nmi_process_done(void)\n{\n\t// only shutdown if we were initialized\n\tif (!_mi_process_is_initialized)\n\t\treturn;\n\t// ensure we are called once\n\tstatic bool process_done \u003d false;\n\tif (process_done)\n\t\treturn;\n\tprocess_done \u003d true;\n\n\t// release any thread specific resources and ensure _mi_thread_done is called on all but the\n\t// main thread\n\t_mi_prim_thread_done_auto_done();\n\n#ifndef MI_SKIP_COLLECT_ON_EXIT\n#if (MI_DEBUG || !defined(MI_SHARED_LIB))\n\t// free all memory if possible on process exit. This is not needed for a stand-alone process\n\t// but should be done if mimalloc is statically linked into another shared library which\n\t// is repeatedly loaded/unloaded, see issue #281.\n\tmi_collect(true /* force */);\n#endif\n#endif\n\n\t// Forcefully release all retained memory; this can be dangerous in general if overriding\n\t// regular malloc/free since after process_done there might still be other code running that\n\t// calls `free` (like at_exit routines, or C-runtime termination code.\n\tif (mi_option_is_enabled(mi_option_destroy_on_exit)) {\n\t\tmi_collect(true /* force */);\n\t\t_mi_heap_unsafe_destroy_all(); // forcefully release all memory held by all heaps (of this\n\t\t\t\t\t\t\t\t\t   // thread only!)\n\t\t_mi_arena_unsafe_destroy_all(\u0026_mi_heap_main_get()-\u003etld-\u003estats);\n\t}\n\n\tif (mi_option_is_enabled(mi_option_show_stats) || mi_option_is_enabled(mi_option_verbose))\n\t\tmi_stats_print(NULL);\n\tmi_allocator_done();\n\t_mi_verbose_message(\"process done: 0x%zx\\n\", _mi_heap_main.thread_id);\n\tos_preloading \u003d true; // don\u0027t call the C runtime anymore\n}\n```",
      "range": {
        "startLine": 625,
        "startChar": 0,
        "endLine": 661,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b856443_89977c42",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 681,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Windows DLL: easy to hook into process_init and thread_done\n__declspec(dllexport) BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, LPVOID reserved)\n{\n\tMI_UNUSED(reserved);\n\tMI_UNUSED(inst);\n\tif (reason \u003d\u003d DLL_PROCESS_ATTACH) {\n\t\tmi_process_load();\n\t} else if (reason \u003d\u003d DLL_PROCESS_DETACH) {\n\t\tmi_process_done();\n\t} else if (reason \u003d\u003d DLL_THREAD_DETACH) {\n\t\tif (!mi_is_redirected())\n\t\t\tmi_thread_done();\n\t}\n\treturn TRUE;\n}\n```",
      "range": {
        "startLine": 665,
        "startChar": 0,
        "endLine": 681,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b69c5932_8af6e530",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 699,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// MSVC: use data section magic for static libraries\n// See\n// \u003chttps://www.codeguru.com/cpp/misc/misc/applicationcontrol/article.php/c6945/Running-Code-Before-and-After-Main.htm\u003e\nstatic int\n_mi_process_init(void)\n{\n\tmi_process_load();\n\treturn 0;\n}\ntypedef int (*_mi_crt_callback_t)(void);\n#if defined(_M_X64) || defined(_M_ARM64)\n__pragma(comment(linker,\n\t\"/include:\"\n\t\"_mi_msvc_initu\"))\n#pragma section(\".CRT$XIU\", long, read)\n#else\n__pragma(comment(linker,\n\t\"/include:\"\n\t\"__mi_msvc_initu\"))\n#endif\n#pragma data_seg(\".CRT$XIU\")\n\tmi_decl_externc _mi_crt_callback_t _mi_msvc_initu[]\n\t\u003d {\u0026_mi_process_init};\n#pragma data_seg()\n```",
      "range": {
        "startLine": 684,
        "startChar": 0,
        "endLine": 699,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eff3a794_e8bbf50f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 703,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatus_t\n__init_heap(void)\n```",
      "range": {
        "startLine": 703,
        "startChar": 0,
        "endLine": 703,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3b4b8db4_408b3473",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 709,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n__heap_terminate_after(void)\n```",
      "range": {
        "startLine": 709,
        "startChar": 0,
        "endLine": 709,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea664ef6_d8e8b65e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 714,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n__heap_thread_init(void)\n```",
      "range": {
        "startLine": 714,
        "startChar": 0,
        "endLine": 714,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b89d328_a47ea12a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 719,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n__heap_thread_exit(void)\n```",
      "range": {
        "startLine": 719,
        "startChar": 0,
        "endLine": 719,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7a320d1a_0c3da540",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 730,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// C++: use static initialization to detect process start\nstatic bool\n_mi_process_init(void)\n{\n\tmi_process_load();\n\treturn _mi_heap_main.thread_id !\u003d 0;\n}\nstatic bool mi_initialized \u003d _mi_process_init();\n```",
      "range": {
        "startLine": 725,
        "startChar": 0,
        "endLine": 730,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eb5c670b_19370ca5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/init.c",
        "patchSetId": 7
      },
      "lineNbr": 736,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// GCC,Clang: use the constructor attribute\nstatic void __attribute__((constructor)) _mi_process_init(void)\n{\n\tmi_process_load();\n}\n```",
      "range": {
        "startLine": 733,
        "startChar": 0,
        "endLine": 736,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0939cad7_e8fc9033",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 23,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cmimalloc.h\u003e\n#include \u003cnew\u003e\n```",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 23,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6bb91c36_9494663a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if defined(_MSC_VER) \u0026\u0026 defined(_Ret_notnull_) \u0026\u0026 defined(_Post_writable_byte_size_)\n// stay consistent with VCRT definitions\n#define mi_decl_new(n) mi_decl_nodiscard mi_decl_restrict _Ret_notnull_ _Post_writable_byte_size_(n)\n#define mi_decl_new_nothrow(n) \\\n\tmi_decl_nodiscard mi_decl_restrict _Ret_maybenull_ _Success_(return !\u003d NULL) \\\n\t\t_Post_writable_byte_size_(n)\n#else\n#define mi_decl_new(n) mi_decl_nodiscard mi_decl_restrict\n#define mi_decl_new_nothrow(n) mi_decl_nodiscard mi_decl_restrict\n#endif\n```",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3bacf6a6_cc99c1b8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 35,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 35,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "78c8d66c_814becbb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 38,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\noperator delete(void* p) noexcept\n{\n\tmi_free(p);\n};\n```",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 38,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4d40d805_b2303bf5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 41,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 41,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ee91590d_611d0fe4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\noperator delete[](void* p) noexcept\n{\n\tmi_free(p);\n};\n```",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 44,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26260e59_67e871d8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 49,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "568d7c5c_377e3802",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 57,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\noperator delete(void* p, const std::nothrow_t\u0026) noexcept\n{\n\tmi_free(p);\n}\n```",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 57,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "37539f7d_5f98b6f6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-new-delete.h",
        "patchSetId": 7
      },
      "lineNbr": 63,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\noperator delete[](void* p, const std::nothrow_t\u0026) noexcept\n{\n\tmi_free(p);\n}\n\n\nmi_decl_new(n) void*\noperator new(std::size_t n) noexcept(false)\n{\n\treturn mi_new(n);\n}\n\n\nmi_decl_new(n) void*\noperator new[](std::size_t n) noexcept(false)\n{\n\treturn mi_new(n);\n}\n\n\nmi_decl_new_nothrow(n) void*\noperator new(std::size_t n, const std::nothrow_t\u0026 tag) noexcept\n{\n\t(void)(tag);\n\treturn mi_new_nothrow(n);\n}\n\n\nmi_decl_new_nothrow(n) void*\noperator new[](std::size_t n, const std::nothrow_t\u0026 tag) noexcept\n{\n\t(void)(tag);\n\treturn mi_new_nothrow(n);\n}\n\n#if (__cplusplus \u003e\u003d 201402L || _MSC_VER \u003e\u003d 1916)\n\n\nvoid\noperator delete(void* p, std::size_t n) noexcept\n{\n\tmi_free_size(p, n);\n};\n\n\nvoid\noperator delete[](void* p, std::size_t n) noexcept\n{\n\tmi_free_size(p, n);\n};\n#endif\n\n#if (__cplusplus \u003e 201402L || defined(__cpp_aligned_new))\n\n\nvoid\noperator delete(void* p, std::align_val_t al) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid\noperator delete[](void* p, std::align_val_t al) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid\noperator delete(void* p, std::size_t n, std::align_val_t al) noexcept\n{\n\tmi_free_size_aligned(p, n, static_cast\u003csize_t\u003e(al));\n};\n\n\nvoid\noperator delete[](void* p, std::size_t n, std::align_val_t al) noexcept\n{\n\tmi_free_size_aligned(p, n, static_cast\u003csize_t\u003e(al));\n};\n\n\nvoid\noperator delete(void* p, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid\noperator delete[](void* p, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\tmi_free_aligned(p, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new(std::size_t n, std::align_val_t al) noexcept(false)\n{\n\treturn mi_new_aligned(n, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new[](std::size_t n, std::align_val_t al) noexcept(false)\n{\n\treturn mi_new_aligned(n, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new(std::size_t n, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\treturn mi_new_aligned_nothrow(n, static_cast\u003csize_t\u003e(al));\n}\n\n\nvoid*\noperator new[](std::size_t n, std::align_val_t al, const std::nothrow_t\u0026) noexcept\n{\n\treturn mi_new_aligned_nothrow(n, static_cast\u003csize_t\u003e(al));\n}\n#endif\n```",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 63,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bbd81cd5_e6643fdf",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-override.h",
        "patchSetId": 7
      },
      "lineNbr": 24,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define malloc(n) mi_malloc(n)\n#define calloc(n, c) mi_calloc(n, c)\n#define realloc(p, n) mi_realloc(p, n)\n#define free(p) mi_free(p)\n```",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 24,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e86d0c85_f3a911bf",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-override.h",
        "patchSetId": 7
      },
      "lineNbr": 28,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define strdup(s) mi_strdup(s)\n#define strndup(s, n) mi_strndup(s, n)\n#define realpath(f, n) mi_realpath(f, n)\n```",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 28,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "576bcb12_5f57f970",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-override.h",
        "patchSetId": 7
      },
      "lineNbr": 33,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _expand(p, n) mi_expand(p, n)\n#define _msize(p) mi_usable_size(p)\n#define _recalloc(p, n, c) mi_recalloc(p, n, c)\n```",
      "range": {
        "startLine": 31,
        "startChar": 0,
        "endLine": 33,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6554a050_2dd226fe",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-override.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _strdup(s) mi_strdup(s)\n#define _strndup(s, n) mi_strndup(s, n)\n#define _wcsdup(s) (wchar_t*)mi_wcsdup((const unsigned short*)(s))\n#define _mbsdup(s) mi_mbsdup(s)\n#define _dupenv_s(b, n, v) mi_dupenv_s(b, n, v)\n#define _wdupenv_s(b, n, v) mi_wdupenv_s((unsigned short*)(b), n, (const unsigned short*)(v))\n```",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 40,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "15e37ac1_2d566840",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-override.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define reallocf(p, n) mi_reallocf(p, n)\n#define malloc_size(p) mi_usable_size(p)\n#define malloc_usable_size(p) mi_usable_size(p)\n#define cfree(p) mi_free(p)\n```",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 46,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "325a0497_41b41984",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-override.h",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define valloc(n) mi_valloc(n)\n#define pvalloc(n) mi_pvalloc(n)\n#define reallocarray(p, s, n) mi_reallocarray(p, s, n)\n#define reallocarr(p, s, n) mi_reallocarr(p, s, n)\n#define memalign(a, n) mi_memalign(a, n)\n#define aligned_alloc(a, n) mi_aligned_alloc(a, n)\n#define posix_memalign(p, a, n) mi_posix_memalign(p, a, n)\n#define _posix_memalign(p, a, n) mi_posix_memalign(p, a, n)\n```",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 55,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12198eb2_a8acfae5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc-override.h",
        "patchSetId": 7
      },
      "lineNbr": 65,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _aligned_malloc(n, a) mi_malloc_aligned(n, a)\n#define _aligned_realloc(p, n, a) mi_realloc_aligned(p, n, a)\n#define _aligned_recalloc(p, s, n, a) mi_aligned_recalloc(p, s, n, a)\n#define _aligned_msize(p, a, o) mi_usable_size(p)\n#define _aligned_free(p) mi_free(p)\n#define _aligned_offset_malloc(n, a, o) mi_malloc_aligned_at(n, a, o)\n#define _aligned_offset_realloc(p, n, a, o) mi_realloc_aligned_at(p, n, a, o)\n#define _aligned_offset_recalloc(p, s, n, a, o) mi_recalloc_aligned_at(p, s, n, a, o)\n```",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 65,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0241efd8_d1aa150e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 11,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MALLOC_VERSION 212 // major + 2 digits minor\n```",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 11,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "727c4a9f_7e352e61",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 24,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (__cplusplus \u003e\u003d 201103L) || (_MSC_VER \u003e 1900) // C++11\n#define mi_attr_noexcept noexcept\n#else\n#define mi_attr_noexcept throw()\n#endif\n#else\n#define mi_attr_noexcept\n```",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 24,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2b0cb95_9a94eb61",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 30,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_decl_nodiscard [[nodiscard]]\n#elif (defined(__GNUC__) \u0026\u0026 (__GNUC__ \u003e\u003d 4)) \\\n\t|| defined(__clang__) // includes clang, icc, and clang-cl\n#define mi_decl_nodiscard __attribute__((warn_unused_result))\n```",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 30,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d98ef5e_14dfef8f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_decl_nodiscard _NODISCARD\n```",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e1e65317_f94f4a63",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 36,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_decl_nodiscard _Check_return_\n#else\n#define mi_decl_nodiscard\n```",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 36,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "da864fb7_09260b7e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 91,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if !defined(MI_SHARED_LIB)\n#define mi_decl_export\n#elif defined(MI_SHARED_LIB_EXPORT)\n#define mi_decl_export __declspec(dllexport)\n#else\n#define mi_decl_export __declspec(dllimport)\n#endif\n#if defined(__MINGW32__)\n#define mi_decl_restrict\n#define mi_attr_malloc __attribute__((malloc))\n#else\n#if (_MSC_VER \u003e\u003d 1900) \u0026\u0026 !defined(__EDG__)\n#define mi_decl_restrict __declspec(allocator) __declspec(restrict)\n#else\n#define mi_decl_restrict __declspec(restrict)\n#endif\n#define mi_attr_malloc\n#endif\n#define mi_cdecl __cdecl\n#define mi_attr_alloc_size(s)\n#define mi_attr_alloc_size2(s1, s2)\n#define mi_attr_alloc_align(p)\n#elif defined(__GNUC__) // includes clang and icc\n#if defined(MI_SHARED_LIB) \u0026\u0026 defined(MI_SHARED_LIB_EXPORT)\n#define mi_decl_export __attribute__((visibility(\"default\")))\n#else\n#define mi_decl_export\n#endif\n#define mi_cdecl // leads to warnings... __attribute__((cdecl))\n#define mi_decl_restrict\n#define mi_attr_malloc __attribute__((malloc))\n#if (defined(__clang_major__) \u0026\u0026 (__clang_major__ \u003c 4)) || (__GNUC__ \u003c 5)\n#define mi_attr_alloc_size(s)\n#define mi_attr_alloc_size2(s1, s2)\n#define mi_attr_alloc_align(p)\n#elif defined(__INTEL_COMPILER)\n#define mi_attr_alloc_size(s) __attribute__((alloc_size(s)))\n#define mi_attr_alloc_size2(s1, s2) __attribute__((alloc_size(s1, s2)))\n#define mi_attr_alloc_align(p)\n#else\n#define mi_attr_alloc_size(s) __attribute__((alloc_size(s)))\n#define mi_attr_alloc_size2(s1, s2) __attribute__((alloc_size(s1, s2)))\n#define mi_attr_alloc_align(p) __attribute__((alloc_align(p)))\n#endif\n#else\n#define mi_cdecl\n#define mi_decl_export\n#define mi_decl_restrict\n#define mi_attr_malloc\n#define mi_attr_alloc_size(s)\n#define mi_attr_alloc_size2(s1, s2)\n#define mi_attr_alloc_align(p)\n```",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 91,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "de80180a_8f6fec45",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 100,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cstdbool.h\u003e // bool\n#include \u003cstddef.h\u003e // size_t\n#include \u003cstdint.h\u003e // INTPTR_MAX\n```",
      "range": {
        "startLine": 98,
        "startChar": 0,
        "endLine": 100,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6ed3df2e_02f14499",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 118,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\"\n{\n#endif\n\n\t// ------------------------------------------------------\n\t// Standard malloc interface\n\t// ------------------------------------------------------\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_malloc(\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_calloc(size_t count,\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size2(1, 2);\n\tmi_decl_nodiscard mi_decl_export void* mi_realloc(void* p, size_t newsize) mi_attr_noexcept\n\t\tmi_attr_alloc_size(2);\n\tmi_decl_export void* mi_expand(void* p, size_t newsize) mi_attr_noexcept mi_attr_alloc_size(2);\n\n\tmi_decl_export void mi_free(void* p) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict char* mi_strdup(\n\t\tconst char* s) mi_attr_noexcept mi_attr_malloc;\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict char* mi_strndup(const char* s,\n\t\tsize_t n) mi_attr_noexcept mi_attr_malloc;\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict char* mi_realpath(const char* fname,\n\t\tchar* resolved_name) mi_attr_noexcept mi_attr_malloc;\n```",
      "range": {
        "startLine": 103,
        "startChar": 0,
        "endLine": 118,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8dabf910_a8d41c9d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 285,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SMALL_WSIZE_MAX (128)\n#define MI_SMALL_SIZE_MAX (MI_SMALL_WSIZE_MAX * sizeof(void*))\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_malloc_small(\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_zalloc_small(\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_zalloc(\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_mallocn(size_t count,\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size2(1, 2);\n\tmi_decl_nodiscard mi_decl_export void* mi_reallocn(void* p, size_t count,\n\t\tsize_t size) mi_attr_noexcept mi_attr_alloc_size2(2, 3);\n\tmi_decl_nodiscard mi_decl_export void* mi_reallocf(void* p, size_t newsize) mi_attr_noexcept\n\t\tmi_attr_alloc_size(2);\n\n\tmi_decl_nodiscard mi_decl_export size_t mi_usable_size(const void* p) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export size_t mi_good_size(size_t size) mi_attr_noexcept;\n\n\n\t// ------------------------------------------------------\n\t// Internals\n\t// ------------------------------------------------------\n\n\ttypedef void(\n\t\tmi_cdecl mi_deferred_free_fun)(bool force, unsigned long long heartbeat, void* arg);\n\tmi_decl_export void mi_register_deferred_free(mi_deferred_free_fun* deferred_free,\n\t\tvoid* arg) mi_attr_noexcept;\n\n\ttypedef void(mi_cdecl mi_output_fun)(const char* msg, void* arg);\n\tmi_decl_export void mi_register_output(mi_output_fun* out, void* arg) mi_attr_noexcept;\n\n\ttypedef void(mi_cdecl mi_error_fun)(int err, void* arg);\n\tmi_decl_export void mi_register_error(mi_error_fun* fun, void* arg);\n\n\tmi_decl_export void mi_collect(bool force) mi_attr_noexcept;\n\tmi_decl_export int mi_version(void) mi_attr_noexcept;\n\tmi_decl_export void mi_stats_reset(void) mi_attr_noexcept;\n\tmi_decl_export void mi_stats_merge(void) mi_attr_noexcept;\n\tmi_decl_export void mi_stats_print(\n\t\tvoid* out) mi_attr_noexcept; // backward compatibility: `out` is ignored and should be NULL\n\tmi_decl_export void mi_stats_print_out(mi_output_fun* out, void* arg) mi_attr_noexcept;\n\n\tmi_decl_export void mi_process_init(void) mi_attr_noexcept;\n\tmi_decl_export void mi_thread_init(void) mi_attr_noexcept;\n\tmi_decl_export void mi_thread_done(void) mi_attr_noexcept;\n\tmi_decl_export void mi_thread_stats_print_out(mi_output_fun* out, void* arg) mi_attr_noexcept;\n\n\tmi_decl_export void mi_process_info(size_t* elapsed_msecs, size_t* user_msecs,\n\t\tsize_t* system_msecs, size_t* current_rss, size_t* peak_rss, size_t* current_commit,\n\t\tsize_t* peak_commit, size_t* page_faults) mi_attr_noexcept;\n\n\t// -------------------------------------------------------------------------------------\n\t// Aligned allocation\n\t// Note that `alignment` always follows `size` for consistency with unaligned\n\t// allocation, but unfortunately this differs from `posix_memalign` and `aligned_alloc`.\n\t// -------------------------------------------------------------------------------------\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_malloc_aligned(size_t size,\n\t\tsize_t alignment) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1)\n\t\tmi_attr_alloc_align(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_malloc_aligned_at(size_t size,\n\t\tsize_t alignment, size_t offset) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_zalloc_aligned(size_t size,\n\t\tsize_t alignment) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1)\n\t\tmi_attr_alloc_align(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_zalloc_aligned_at(size_t size,\n\t\tsize_t alignment, size_t offset) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_calloc_aligned(size_t count,\n\t\tsize_t size, size_t alignment) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size2(1, 2)\n\t\tmi_attr_alloc_align(3);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_calloc_aligned_at(size_t count,\n\t\tsize_t size, size_t alignment, size_t offset) mi_attr_noexcept mi_attr_malloc\n\t\tmi_attr_alloc_size2(1, 2);\n\tmi_decl_nodiscard mi_decl_export void* mi_realloc_aligned(void* p, size_t newsize,\n\t\tsize_t alignment) mi_attr_noexcept mi_attr_alloc_size(2) mi_attr_alloc_align(3);\n\tmi_decl_nodiscard mi_decl_export void* mi_realloc_aligned_at(void* p, size_t newsize,\n\t\tsize_t alignment, size_t offset) mi_attr_noexcept mi_attr_alloc_size(2);\n\n\n\t// -------------------------------------------------------------------------------------\n\t// Heaps: first-class, but can only allocate from the same thread that created it.\n\t// -------------------------------------------------------------------------------------\n\n\tstruct mi_heap_s;\n\ttypedef struct mi_heap_s mi_heap_t;\n\n\tmi_decl_nodiscard mi_decl_export mi_heap_t* mi_heap_new(void);\n\tmi_decl_export void mi_heap_delete(mi_heap_t* heap);\n\tmi_decl_export void mi_heap_destroy(mi_heap_t* heap);\n\tmi_decl_export mi_heap_t* mi_heap_set_default(mi_heap_t* heap);\n\tmi_decl_export mi_heap_t* mi_heap_get_default(void);\n\tmi_decl_export mi_heap_t* mi_heap_get_backing(void);\n\tmi_decl_export void mi_heap_collect(mi_heap_t* heap, bool force) mi_attr_noexcept;\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_malloc(mi_heap_t* heap,\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_zalloc(mi_heap_t* heap,\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_calloc(mi_heap_t* heap,\n\t\tsize_t count, size_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size2(2, 3);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_mallocn(mi_heap_t* heap,\n\t\tsize_t count, size_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size2(2, 3);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_malloc_small(mi_heap_t* heap,\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2);\n\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_realloc(mi_heap_t* heap, void* p,\n\t\tsize_t newsize) mi_attr_noexcept mi_attr_alloc_size(3);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_reallocn(mi_heap_t* heap, void* p, size_t count,\n\t\tsize_t size) mi_attr_noexcept mi_attr_alloc_size2(3, 4);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_reallocf(mi_heap_t* heap, void* p,\n\t\tsize_t newsize) mi_attr_noexcept mi_attr_alloc_size(3);\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict char* mi_heap_strdup(mi_heap_t* heap,\n\t\tconst char* s) mi_attr_noexcept mi_attr_malloc;\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict char* mi_heap_strndup(mi_heap_t* heap,\n\t\tconst char* s, size_t n) mi_attr_noexcept mi_attr_malloc;\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict char* mi_heap_realpath(mi_heap_t* heap,\n\t\tconst char* fname, char* resolved_name) mi_attr_noexcept mi_attr_malloc;\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_malloc_aligned(mi_heap_t* heap,\n\t\tsize_t size, size_t alignment) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2)\n\t\tmi_attr_alloc_align(3);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_malloc_aligned_at(\n\t\tmi_heap_t* heap, size_t size, size_t alignment,\n\t\tsize_t offset) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_zalloc_aligned(mi_heap_t* heap,\n\t\tsize_t size, size_t alignment) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2)\n\t\tmi_attr_alloc_align(3);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_zalloc_aligned_at(\n\t\tmi_heap_t* heap, size_t size, size_t alignment,\n\t\tsize_t offset) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_calloc_aligned(mi_heap_t* heap,\n\t\tsize_t count, size_t size, size_t alignment) mi_attr_noexcept mi_attr_malloc\n\t\tmi_attr_alloc_size2(2, 3) mi_attr_alloc_align(4);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_calloc_aligned_at(\n\t\tmi_heap_t* heap, size_t count, size_t size, size_t alignment,\n\t\tsize_t offset) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size2(2, 3);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_realloc_aligned(mi_heap_t* heap, void* p,\n\t\tsize_t newsize, size_t alignment) mi_attr_noexcept mi_attr_alloc_size(3)\n\t\tmi_attr_alloc_align(4);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_realloc_aligned_at(mi_heap_t* heap, void* p,\n\t\tsize_t newsize, size_t alignment, size_t offset) mi_attr_noexcept mi_attr_alloc_size(3);\n\n\n\t// --------------------------------------------------------------------------------\n\t// Zero initialized re-allocation.\n\t// Only valid on memory that was originally allocated with zero initialization too.\n\t// e.g. `mi_calloc`, `mi_zalloc`, `mi_zalloc_aligned` etc.\n\t// see \u003chttps://github.com/microsoft/mimalloc/issues/63#issuecomment-508272992\u003e\n\t// --------------------------------------------------------------------------------\n\n\tmi_decl_nodiscard mi_decl_export void* mi_rezalloc(void* p, size_t newsize) mi_attr_noexcept\n\t\tmi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export void* mi_recalloc(void* p, size_t newcount,\n\t\tsize_t size) mi_attr_noexcept mi_attr_alloc_size2(2, 3);\n\n\tmi_decl_nodiscard mi_decl_export void* mi_rezalloc_aligned(void* p, size_t newsize,\n\t\tsize_t alignment) mi_attr_noexcept mi_attr_alloc_size(2) mi_attr_alloc_align(3);\n\tmi_decl_nodiscard mi_decl_export void* mi_rezalloc_aligned_at(void* p, size_t newsize,\n\t\tsize_t alignment, size_t offset) mi_attr_noexcept mi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export void* mi_recalloc_aligned(void* p, size_t newcount,\n\t\tsize_t size, size_t alignment) mi_attr_noexcept mi_attr_alloc_size2(2, 3)\n\t\tmi_attr_alloc_align(4);\n\tmi_decl_nodiscard mi_decl_export void* mi_recalloc_aligned_at(void* p, size_t newcount,\n\t\tsize_t size, size_t alignment, size_t offset) mi_attr_noexcept mi_attr_alloc_size2(2, 3);\n\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_rezalloc(mi_heap_t* heap, void* p,\n\t\tsize_t newsize) mi_attr_noexcept mi_attr_alloc_size(3);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_recalloc(mi_heap_t* heap, void* p,\n\t\tsize_t newcount, size_t size) mi_attr_noexcept mi_attr_alloc_size2(3, 4);\n\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_rezalloc_aligned(mi_heap_t* heap, void* p,\n\t\tsize_t newsize, size_t alignment) mi_attr_noexcept mi_attr_alloc_size(3)\n\t\tmi_attr_alloc_align(4);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_rezalloc_aligned_at(mi_heap_t* heap, void* p,\n\t\tsize_t newsize, size_t alignment, size_t offset) mi_attr_noexcept mi_attr_alloc_size(3);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_recalloc_aligned(mi_heap_t* heap, void* p,\n\t\tsize_t newcount, size_t size, size_t alignment) mi_attr_noexcept mi_attr_alloc_size2(3, 4)\n\t\tmi_attr_alloc_align(5);\n\tmi_decl_nodiscard mi_decl_export void* mi_heap_recalloc_aligned_at(mi_heap_t* heap, void* p,\n\t\tsize_t newcount, size_t size, size_t alignment, size_t offset) mi_attr_noexcept\n\t\tmi_attr_alloc_size2(3, 4);\n\n\n\t// ------------------------------------------------------\n\t// Analysis\n\t// ------------------------------------------------------\n\n\tmi_decl_export bool mi_heap_contains_block(mi_heap_t* heap, const void* p);\n\tmi_decl_export bool mi_heap_check_owned(mi_heap_t* heap, const void* p);\n\tmi_decl_export bool mi_check_owned(const void* p);\n\n\t// An area of heap space contains blocks of a single size.\n\ttypedef struct mi_heap_area_s {\n\t\tvoid* blocks; // start of the area containing heap blocks\n\t\tsize_t reserved; // bytes reserved for this area (virtual)\n\t\tsize_t committed; // current available bytes for this area\n\t\tsize_t used; // number of allocated blocks\n\t\tsize_t block_size; // size in bytes of each block\n\t\tsize_t full_block_size; // size in bytes of a full block including padding and metadata.\n\t} mi_heap_area_t;\n\n\ttypedef bool(mi_cdecl mi_block_visit_fun)(const mi_heap_t* heap, const mi_heap_area_t* area,\n\t\tvoid* block, size_t block_size, void* arg);\n\n\tmi_decl_export bool mi_heap_visit_blocks(const mi_heap_t* heap, bool visit_all_blocks,\n\t\tmi_block_visit_fun* visitor, void* arg);\n\n\t// Experimental\n\tmi_decl_nodiscard mi_decl_export bool mi_is_in_heap_region(const void* p) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export bool mi_is_redirected(void) mi_attr_noexcept;\n\n\tmi_decl_export int mi_reserve_huge_os_pages_interleave(size_t pages, size_t numa_nodes,\n\t\tsize_t timeout_msecs) mi_attr_noexcept;\n\tmi_decl_export int mi_reserve_huge_os_pages_at(size_t pages, int numa_node,\n\t\tsize_t timeout_msecs) mi_attr_noexcept;\n\n\tmi_decl_export int mi_reserve_os_memory(size_t size, bool commit,\n\t\tbool allow_large) mi_attr_noexcept;\n\tmi_decl_export bool mi_manage_os_memory(void* start, size_t size, bool is_committed,\n\t\tbool is_large, bool is_zero, int numa_node) mi_attr_noexcept;\n\n\tmi_decl_export void mi_debug_show_arenas(void) mi_attr_noexcept;\n\n\t// Experimental: heaps associated with specific memory arena\u0027s\n\ttypedef int mi_arena_id_t;\n\tmi_decl_export void* mi_arena_area(mi_arena_id_t arena_id, size_t* size);\n\tmi_decl_export int mi_reserve_huge_os_pages_at_ex(size_t pages, int numa_node,\n\t\tsize_t timeout_msecs, bool exclusive, mi_arena_id_t* arena_id) mi_attr_noexcept;\n\tmi_decl_export int mi_reserve_os_memory_ex(size_t size, bool commit, bool allow_large,\n\t\tbool exclusive, mi_arena_id_t* arena_id) mi_attr_noexcept;\n\tmi_decl_export bool mi_manage_os_memory_ex(void* start, size_t size, bool is_committed,\n\t\tbool is_large, bool is_zero, int numa_node, bool exclusive,\n\t\tmi_arena_id_t* arena_id) mi_attr_noexcept;\n```",
      "range": {
        "startLine": 123,
        "startChar": 0,
        "endLine": 285,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d24030a8_f6dd147c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 414,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// Create a heap that only allocates in the specified arena\n\tmi_decl_nodiscard mi_decl_export mi_heap_t* mi_heap_new_in_arena(mi_arena_id_t arena_id);\n#endif\n\n\t// deprecated\n\tmi_decl_export int mi_reserve_huge_os_pages(size_t pages, double max_secs,\n\t\tsize_t* pages_reserved) mi_attr_noexcept;\n\n\n\t// ------------------------------------------------------\n\t// Convenience\n\t// ------------------------------------------------------\n\n#define mi_malloc_tp(tp) ((tp*)mi_malloc(sizeof(tp)))\n#define mi_zalloc_tp(tp) ((tp*)mi_zalloc(sizeof(tp)))\n#define mi_calloc_tp(tp, n) ((tp*)mi_calloc(n, sizeof(tp)))\n#define mi_mallocn_tp(tp, n) ((tp*)mi_mallocn(n, sizeof(tp)))\n#define mi_reallocn_tp(p, tp, n) ((tp*)mi_reallocn(p, n, sizeof(tp)))\n#define mi_recalloc_tp(p, tp, n) ((tp*)mi_recalloc(p, n, sizeof(tp)))\n\n#define mi_heap_malloc_tp(hp, tp) ((tp*)mi_heap_malloc(hp, sizeof(tp)))\n#define mi_heap_zalloc_tp(hp, tp) ((tp*)mi_heap_zalloc(hp, sizeof(tp)))\n#define mi_heap_calloc_tp(hp, tp, n) ((tp*)mi_heap_calloc(hp, n, sizeof(tp)))\n#define mi_heap_mallocn_tp(hp, tp, n) ((tp*)mi_heap_mallocn(hp, n, sizeof(tp)))\n#define mi_heap_reallocn_tp(hp, p, tp, n) ((tp*)mi_heap_reallocn(hp, p, n, sizeof(tp)))\n#define mi_heap_recalloc_tp(hp, p, tp, n) ((tp*)mi_heap_recalloc(hp, p, n, sizeof(tp)))\n\n\n\t// ------------------------------------------------------\n\t// Options\n\t// ------------------------------------------------------\n\n\ttypedef enum mi_option_e {\n\t\t// stable options\n\t\tmi_option_show_errors, // print error messages\n\t\tmi_option_show_stats, // print statistics on termination\n\t\tmi_option_verbose, // print verbose messages\n\t\t// the following options are experimental (see src/options.h)\n\t\tmi_option_eager_commit, // eager commit segments? (after `eager_commit_delay` segments) (\u003d1)\n\t\tmi_option_arena_eager_commit, // eager commit arenas? Use 2 to enable just on overcommit\n\t\t\t\t\t\t\t\t\t  // systems (\u003d2)\n\t\tmi_option_purge_decommits, // should a memory purge decommit (or only reset) (\u003d1)\n\t\tmi_option_allow_large_os_pages, // allow large (2MiB) OS pages, implies eager commit\n\t\tmi_option_reserve_huge_os_pages, // reserve N huge OS pages (1GiB/page) at startup\n\t\tmi_option_reserve_huge_os_pages_at, // reserve huge OS pages at a specific NUMA node\n\t\tmi_option_reserve_os_memory, // reserve specified amount of OS memory in an arena at startup\n\t\tmi_option_deprecated_segment_cache,\n\t\tmi_option_deprecated_page_reset,\n\t\tmi_option_abandoned_page_purge, // immediately purge delayed purges on thread termination\n\t\tmi_option_deprecated_segment_reset,\n\t\tmi_option_eager_commit_delay,\n\t\tmi_option_purge_delay, // memory purging is delayed by N milli seconds; use 0 for immediate\n\t\t\t\t\t\t\t   // purging or -1 for no purging at all.\n\t\tmi_option_use_numa_nodes, // 0 \u003d use all available numa nodes, otherwise use at most N\n\t\t\t\t\t\t\t\t  // nodes.\n\t\tmi_option_limit_os_alloc, // 1 \u003d do not use OS memory for allocation (but only\n\t\t\t\t\t\t\t\t  // programmatically reserved arenas)\n\t\tmi_option_os_tag, // tag used for OS logging (macOS only for now)\n\t\tmi_option_max_errors, // issue at most N error messages\n\t\tmi_option_max_warnings, // issue at most N warning messages\n\t\tmi_option_max_segment_reclaim,\n\t\tmi_option_destroy_on_exit, // if set, release all memory on exit; sometimes used for dynamic\n\t\t\t\t\t\t\t\t   // unloading but can be unsafe.\n\t\tmi_option_arena_reserve, // initial memory size in KiB for arena reservation (1GiB on\n\t\t\t\t\t\t\t\t // 64-bit)\n\t\tmi_option_arena_purge_mult,\n\t\tmi_option_purge_extend_delay,\n\t\t_mi_option_last,\n\t\t// legacy option names\n\t\tmi_option_large_os_pages \u003d mi_option_allow_large_os_pages,\n\t\tmi_option_eager_region_commit \u003d mi_option_arena_eager_commit,\n\t\tmi_option_reset_decommits \u003d mi_option_purge_decommits,\n\t\tmi_option_reset_delay \u003d mi_option_purge_delay,\n\t\tmi_option_abandoned_page_reset \u003d mi_option_abandoned_page_purge\n\t} mi_option_t;\n\n\n\tmi_decl_nodiscard mi_decl_export bool mi_option_is_enabled(mi_option_t option);\n\tmi_decl_export void mi_option_enable(mi_option_t option);\n\tmi_decl_export void mi_option_disable(mi_option_t option);\n\tmi_decl_export void mi_option_set_enabled(mi_option_t option, bool enable);\n\tmi_decl_export void mi_option_set_enabled_default(mi_option_t option, bool enable);\n\n\tmi_decl_nodiscard mi_decl_export long mi_option_get(mi_option_t option);\n\tmi_decl_nodiscard mi_decl_export long mi_option_get_clamp(mi_option_t option, long min,\n\t\tlong max);\n\tmi_decl_nodiscard mi_decl_export size_t mi_option_get_size(mi_option_t option);\n\tmi_decl_export void mi_option_set(mi_option_t option, long value);\n\tmi_decl_export void mi_option_set_default(mi_option_t option, long value);\n\n\n\t// -------------------------------------------------------------------------------------------------------\n\t// \"mi\" prefixed implementations of various posix, Unix, Windows, and C++ allocation functions.\n\t// (This can be convenient when providing overrides of these functions as done in\n\t// `mimalloc-override.h`.) note: we use `mi_cfree` as \"checked free\" and it checks if the\n\t// pointer is in our heap before free-ing.\n\t// -------------------------------------------------------------------------------------------------------\n\n\tmi_decl_export void mi_cfree(void* p) mi_attr_noexcept;\n\tmi_decl_export void* mi__expand(void* p, size_t newsize) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export size_t mi_malloc_size(const void* p) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export size_t mi_malloc_good_size(size_t size) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export size_t mi_malloc_usable_size(const void* p) mi_attr_noexcept;\n\n\tmi_decl_export int mi_posix_memalign(void** p, size_t alignment, size_t size) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_memalign(size_t alignment,\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2) mi_attr_alloc_align(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_valloc(\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_pvalloc(\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_aligned_alloc(size_t alignment,\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(2) mi_attr_alloc_align(1);\n\n\tmi_decl_nodiscard mi_decl_export void* mi_reallocarray(void* p, size_t count,\n\t\tsize_t size) mi_attr_noexcept mi_attr_alloc_size2(2, 3);\n\tmi_decl_nodiscard mi_decl_export int mi_reallocarr(void* p, size_t count,\n\t\tsize_t size) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export void* mi_aligned_recalloc(void* p, size_t newcount,\n\t\tsize_t size, size_t alignment) mi_attr_noexcept;\n\tmi_decl_nodiscard mi_decl_export void* mi_aligned_offset_recalloc(void* p, size_t newcount,\n\t\tsize_t size, size_t alignment, size_t offset) mi_attr_noexcept;\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict unsigned short* mi_wcsdup(\n\t\tconst unsigned short* s) mi_attr_noexcept mi_attr_malloc;\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict unsigned char* mi_mbsdup(\n\t\tconst unsigned char* s) mi_attr_noexcept mi_attr_malloc;\n\tmi_decl_export int mi_dupenv_s(char** buf, size_t* size, const char* name) mi_attr_noexcept;\n\tmi_decl_export int mi_wdupenv_s(unsigned short** buf, size_t* size,\n\t\tconst unsigned short* name) mi_attr_noexcept;\n\n\tmi_decl_export void mi_free_size(void* p, size_t size) mi_attr_noexcept;\n\tmi_decl_export void mi_free_size_aligned(void* p, size_t size,\n\t\tsize_t alignment) mi_attr_noexcept;\n\tmi_decl_export void mi_free_aligned(void* p, size_t alignment) mi_attr_noexcept;\n\n\t// The `mi_new` wrappers implement C++ semantics on out-of-memory instead of directly returning\n\t// `NULL`. (and call `std::get_new_handler` and potentially raise a `std::bad_alloc` exception).\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_new(size_t size) mi_attr_malloc\n\t\tmi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_new_aligned(size_t size,\n\t\tsize_t alignment) mi_attr_malloc mi_attr_alloc_size(1) mi_attr_alloc_align(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_new_nothrow(\n\t\tsize_t size) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_new_aligned_nothrow(size_t size,\n\t\tsize_t alignment) mi_attr_noexcept mi_attr_malloc mi_attr_alloc_size(1)\n\t\tmi_attr_alloc_align(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_new_n(size_t count,\n\t\tsize_t size) mi_attr_malloc mi_attr_alloc_size2(1, 2);\n\tmi_decl_nodiscard mi_decl_export void* mi_new_realloc(void* p, size_t newsize)\n\t\tmi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export void* mi_new_reallocn(void* p, size_t newcount, size_t size)\n\t\tmi_attr_alloc_size2(2, 3);\n\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_alloc_new(mi_heap_t* heap,\n\t\tsize_t size) mi_attr_malloc mi_attr_alloc_size(2);\n\tmi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_alloc_new_n(mi_heap_t* heap,\n\t\tsize_t count, size_t size) mi_attr_malloc mi_attr_alloc_size2(2, 3);\n```",
      "range": {
        "startLine": 288,
        "startChar": 0,
        "endLine": 414,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aa2f3c50_fdfe2cf9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 428,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003ccstddef\u003e // std::size_t\n#include \u003ccstdint\u003e // PTRDIFF_MAX\n#if (__cplusplus \u003e\u003d 201103L) || (_MSC_VER \u003e 1900) // C++11\n```",
      "range": {
        "startLine": 426,
        "startChar": 0,
        "endLine": 428,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5e1fbf4_fd9abcf6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 430,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cutility\u003e // std::forward\n```",
      "range": {
        "startLine": 430,
        "startChar": 0,
        "endLine": 430,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b73ed56f_4d9abffc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 455,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\ttypedef T value_type;\n\ttypedef std::size_t size_type;\n\ttypedef std::ptrdiff_t difference_type;\n\ttypedef value_type\u0026 reference;\n\ttypedef value_type const\u0026 const_reference;\n\ttypedef value_type* pointer;\n\ttypedef value_type const* const_pointer;\n\n#if ((__cplusplus \u003e\u003d 201103L) || (_MSC_VER \u003e 1900)) // C++11\n\tusing propagate_on_container_copy_assignment \u003d std::true_type;\n\tusing propagate_on_container_move_assignment \u003d std::true_type;\n\tusing propagate_on_container_swap \u003d std::true_type;\n\ttemplate\u003cclass U, class... Args\u003e void construct(U* p, Args\u0026\u0026... args)\n\t{\n\t\t::new(p) U(std::forward\u003cArgs\u003e(args)...);\n\t}\n\ttemplate\u003cclass U\u003e void destroy(U* p) mi_attr_noexcept { p-\u003e~U(); }\n#else\n\tvoid construct(pointer p, value_type const\u0026 val) { ::new(p) value_type(val); }\n\tvoid destroy(pointer p) { p-\u003e~value_type(); }\n#endif\n\n\tsize_type max_size() const mi_attr_noexcept { return PTRDIFF_MAX / sizeof(value_type); }\n\tpointer address(reference x) const { return \u0026x; }\n\tconst_pointer address(const_reference x) const { return \u0026x; }\n```",
      "range": {
        "startLine": 434,
        "startChar": 0,
        "endLine": 455,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c827f32_ac127f89",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 479,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tusing typename _mi_stl_allocator_common\u003cT\u003e::size_type;\n\tusing typename _mi_stl_allocator_common\u003cT\u003e::value_type;\n\tusing typename _mi_stl_allocator_common\u003cT\u003e::pointer;\n\ttemplate\u003cclass U\u003e struct rebind {\n\t\ttypedef mi_stl_allocator\u003cU\u003e other;\n\t};\n\n\tmi_stl_allocator() mi_attr_noexcept \u003d default;\n\tmi_stl_allocator(const mi_stl_allocator\u0026) mi_attr_noexcept \u003d default;\n\ttemplate\u003cclass U\u003e mi_stl_allocator(const mi_stl_allocator\u003cU\u003e\u0026) mi_attr_noexcept {}\n\tmi_stl_allocator select_on_container_copy_construction() const { return *this; }\n\tvoid deallocate(T* p, size_type) { mi_free(p); }\n\n#if (__cplusplus \u003e\u003d 201703L) // C++17\n\tmi_decl_nodiscard T* allocate(size_type count)\n\t{\n\t\treturn static_cast\u003cT*\u003e(mi_new_n(count, sizeof(T)));\n\t}\n\tmi_decl_nodiscard T* allocate(size_type count, const void*) { return allocate(count); }\n#else\n\tmi_decl_nodiscard pointer allocate(size_type count, const void* \u003d 0)\n\t{\n\t\treturn static_cast\u003cpointer\u003e(mi_new_n(count, sizeof(value_type)));\n\t}\n#endif\n\n#if ((__cplusplus \u003e\u003d 201103L) || (_MSC_VER \u003e 1900)) // C++11\n\tusing is_always_equal \u003d std::true_type;\n#endif\n```",
      "range": {
        "startLine": 459,
        "startChar": 0,
        "endLine": 479,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c21e6791_9799907e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 486,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\ntemplate\u003cclass T1, class T2\u003e\nbool\noperator\u003d\u003d(const mi_stl_allocator\u003cT1\u003e\u0026, const mi_stl_allocator\u003cT2\u003e\u0026) mi_attr_noexcept\n{\n\treturn true;\n}\n\n\ntemplate\u003cclass T1, class T2\u003e\nbool\noperator!\u003d(const mi_stl_allocator\u003cT1\u003e\u0026, const mi_stl_allocator\u003cT2\u003e\u0026) mi_attr_noexcept\n{\n\treturn false;\n}\n\n\n#if (__cplusplus \u003e\u003d 201103L) || (_MSC_VER \u003e\u003d 1900) // C++11\n```",
      "range": {
        "startLine": 482,
        "startChar": 0,
        "endLine": 486,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "db0e32bc_d34e8d9b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 489,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cmemory\u003e // std::shared_ptr\n```",
      "range": {
        "startLine": 489,
        "startChar": 0,
        "endLine": 489,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2d35521_133be426",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 511,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntemplate\u003cclass T, bool _mi_destroy\u003e\nstruct _mi_heap_stl_allocator_common : public _mi_stl_allocator_common\u003cT\u003e {\n\tusing typename _mi_stl_allocator_common\u003cT\u003e::size_type;\n\tusing typename _mi_stl_allocator_common\u003cT\u003e::value_type;\n\tusing typename _mi_stl_allocator_common\u003cT\u003e::pointer;\n\n\t_mi_heap_stl_allocator_common(mi_heap_t* hp)\n\t\t:\n\t\theap(hp)\n\t{\n\t} /* will not delete nor destroy the passed in heap */\n\n#if (__cplusplus \u003e\u003d 201703L) // C++17\n\tmi_decl_nodiscard T* allocate(size_type count)\n\t{\n\t\treturn static_cast\u003cT*\u003e(mi_heap_alloc_new_n(this-\u003eheap.get(), count, sizeof(T)));\n\t}\n\tmi_decl_nodiscard T* allocate(size_type count, const void*) { return allocate(count); }\n#else\n\tmi_decl_nodiscard pointer allocate(size_type count, const void* \u003d 0)\n\t{\n\t\treturn static_cast\u003cpointer\u003e(\n\t\t\tmi_heap_alloc_new_n(this-\u003eheap.get(), count, sizeof(value_type)));\n\t}\n#endif\n\n#if ((__cplusplus \u003e\u003d 201103L) || (_MSC_VER \u003e 1900)) // C++11\n\tusing is_always_equal \u003d std::false_type;\n#endif\n\n\tvoid collect(bool force) { mi_heap_collect(this-\u003eheap.get(), force); }\n\ttemplate\u003cclass U\u003e bool is_equal(const _mi_heap_stl_allocator_common\u003cU, _mi_destroy\u003e\u0026 x) const\n\t{\n\t\treturn this-\u003eheap \u003d\u003d x.heap;\n\t}\n```",
      "range": {
        "startLine": 492,
        "startChar": 0,
        "endLine": 511,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "13a76483_ccf7225c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 522,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tstd::shared_ptr\u003cmi_heap_t\u003e heap;\n\ttemplate\u003cclass U, bool D\u003e friend struct _mi_heap_stl_allocator_common;\n\n\t_mi_heap_stl_allocator_common()\n\t{\n\t\tmi_heap_t* hp \u003d mi_heap_new();\n\t\tthis-\u003eheap.reset(hp,\n\t\t\t(_mi_destroy ? \u0026heap_destroy : \u0026heap_delete)); /* calls heap_delete/destroy when the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  refcount drops to zero */\n\t}\n\t_mi_heap_stl_allocator_common(const _mi_heap_stl_allocator_common\u0026 x) mi_attr_noexcept\n\t\t: heap(x.heap)\n\t{\n\t}\n\ttemplate\u003cclass U\u003e\n\t_mi_heap_stl_allocator_common(\n\t\tconst _mi_heap_stl_allocator_common\u003cU, _mi_destroy\u003e\u0026 x) mi_attr_noexcept : heap(x.heap)\n\t{\n\t}\n```",
      "range": {
        "startLine": 514,
        "startChar": 0,
        "endLine": 522,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f8deae28_a8593d19",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 526,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tstatic void heap_delete(mi_heap_t* hp)\n\t{\n\t\tif (hp !\u003d NULL)\n\t\t\tmi_heap_delete(hp);\n\t}\n\tstatic void heap_destroy(mi_heap_t* hp)\n\t{\n\t\tif (hp !\u003d NULL)\n\t\t\tmi_heap_destroy(hp);\n\t}\n```",
      "range": {
        "startLine": 525,
        "startChar": 0,
        "endLine": 526,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7ffb0bc9_c5d866ed",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 538,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tusing typename _mi_heap_stl_allocator_common\u003cT, false\u003e::size_type;\n\tmi_heap_stl_allocator()\n\t\t:\n\t\t_mi_heap_stl_allocator_common\u003cT, false\u003e()\n\t{\n\t} // creates fresh heap that is deleted when the destructor is called\n\tmi_heap_stl_allocator(mi_heap_t* hp)\n\t\t:\n\t\t_mi_heap_stl_allocator_common\u003cT, false\u003e(hp)\n\t{\n\t} // no delete nor destroy on the passed in heap\n\ttemplate\u003cclass U\u003e\n\tmi_heap_stl_allocator(const mi_heap_stl_allocator\u003cU\u003e\u0026 x) mi_attr_noexcept\n\t\t: _mi_heap_stl_allocator_common\u003cT, false\u003e(x)\n\t{\n\t}\n\n\tmi_heap_stl_allocator select_on_container_copy_construction() const { return *this; }\n\tvoid deallocate(T* p, size_type) { mi_free(p); }\n\ttemplate\u003cclass U\u003e struct rebind {\n\t\ttypedef mi_heap_stl_allocator\u003cU\u003e other;\n\t};\n```",
      "range": {
        "startLine": 531,
        "startChar": 0,
        "endLine": 538,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "61717a9d_096bb238",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 542,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\ntemplate\u003cclass T1, class T2\u003e\nbool\noperator\u003d\u003d(const mi_heap_stl_allocator\u003cT1\u003e\u0026 x, const mi_heap_stl_allocator\u003cT2\u003e\u0026 y) mi_attr_noexcept\n{\n\treturn x.is_equal(y);\n}\n\n\ntemplate\u003cclass T1, class T2\u003e\nbool\noperator!\u003d(const mi_heap_stl_allocator\u003cT1\u003e\u0026 x, const mi_heap_stl_allocator\u003cT2\u003e\u0026 y) mi_attr_noexcept\n{\n\treturn !x.is_equal(y);\n}\n```",
      "range": {
        "startLine": 541,
        "startChar": 0,
        "endLine": 542,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3f32754_d78781e9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 555,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntemplate\u003cclass T\u003e\nstruct mi_heap_destroy_stl_allocator : public _mi_heap_stl_allocator_common\u003cT, true\u003e {\n\tusing typename _mi_heap_stl_allocator_common\u003cT, true\u003e::size_type;\n\tmi_heap_destroy_stl_allocator()\n\t\t:\n\t\t_mi_heap_stl_allocator_common\u003cT, true\u003e()\n\t{\n\t} // creates fresh heap that is destroyed when the destructor is called\n\tmi_heap_destroy_stl_allocator(mi_heap_t* hp)\n\t\t:\n\t\t_mi_heap_stl_allocator_common\u003cT, true\u003e(hp)\n\t{\n\t} // no delete nor destroy on the passed in heap\n\ttemplate\u003cclass U\u003e\n\tmi_heap_destroy_stl_allocator(const mi_heap_destroy_stl_allocator\u003cU\u003e\u0026 x) mi_attr_noexcept\n\t\t: _mi_heap_stl_allocator_common\u003cT, true\u003e(x)\n\t{\n\t}\n\n\tmi_heap_destroy_stl_allocator select_on_container_copy_construction() const { return *this; }\n\tvoid deallocate(T*, size_type)\n\t{ /* do nothing as we destroy the heap on destruct. */\n\t}\n\ttemplate\u003cclass U\u003e struct rebind {\n\t\ttypedef mi_heap_destroy_stl_allocator\u003cU\u003e other;\n\t};\n```",
      "range": {
        "startLine": 547,
        "startChar": 0,
        "endLine": 555,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc6dea7b_eace7e6e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc.h",
        "patchSetId": 7
      },
      "lineNbr": 559,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\ntemplate\u003cclass T1, class T2\u003e\nbool\noperator\u003d\u003d(const mi_heap_destroy_stl_allocator\u003cT1\u003e\u0026 x,\n\tconst mi_heap_destroy_stl_allocator\u003cT2\u003e\u0026 y) mi_attr_noexcept\n{\n\treturn x.is_equal(y);\n}\n\n\ntemplate\u003cclass T1, class T2\u003e\nbool\noperator!\u003d(const mi_heap_destroy_stl_allocator\u003cT1\u003e\u0026 x,\n\tconst mi_heap_destroy_stl_allocator\u003cT2\u003e\u0026 y) mi_attr_noexcept\n{\n\treturn !x.is_equal(y);\n}\n```",
      "range": {
        "startLine": 558,
        "startChar": 0,
        "endLine": 559,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "730d0870_07d821a4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// We base the primitives on the C/C++ atomics and create a mimimal wrapper for MSVC in C\n// compilation mode. This is why we try to use only `uintptr_t` and `\u003ctype\u003e*` as atomic types. To\n// gain better insight in the range of used atomics, we use explicitly named memory order operations\n```",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5518db98_f03eb2b7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 25,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _Atomic(tp) std::atomic\u003ctp\u003e\n#define mi_atomic(name) std::atomic_##name\n#define mi_memory_order(name) std::memory_order_##name\n```",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 25,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce83ddc4_7a1a967d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 29,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_ATOMIC_VAR_INIT(x) x\n#else\n#define MI_ATOMIC_VAR_INIT(x) ATOMIC_VAR_INIT(x)\n```",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d7016f79_72267536",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 36,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _Atomic(tp) tp\n#define MI_ATOMIC_VAR_INIT(x) x\n#define mi_atomic(name) mi_atomic_##name\n#define mi_memory_order(name) mi_memory_order_##name\n```",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 36,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a321d2aa_1f48367e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 41,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_atomic(name) atomic_##name\n#define mi_memory_order(name) memory_order_##name\n```",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 41,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ae7a1b6e_28587943",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 45,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_ATOMIC_VAR_INIT(x) x\n#else\n#define MI_ATOMIC_VAR_INIT(x) ATOMIC_VAR_INIT(x)\n```",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 45,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cbe698db_391eb19b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_atomic_cas_weak(p, expected, desired, mem_success, mem_fail) \\\n\tmi_atomic(compare_exchange_weak_explicit)(p, expected, desired, mem_success, mem_fail)\n\n#define mi_atomic_cas_strong(p, expected, desired, mem_success, mem_fail) \\\n\tmi_atomic(compare_exchange_strong_explicit)(p, expected, desired, mem_success, mem_fail)\n\n#define mi_atomic_load_acquire(p) mi_atomic(load_explicit)(p, mi_memory_order(acquire))\n#define mi_atomic_load_relaxed(p) mi_atomic(load_explicit)(p, mi_memory_order(relaxed))\n#define mi_atomic_store_release(p, x) mi_atomic(store_explicit)(p, x, mi_memory_order(release))\n#define mi_atomic_store_relaxed(p, x) mi_atomic(store_explicit)(p, x, mi_memory_order(relaxed))\n#define mi_atomic_exchange_release(p, x) \\\n\tmi_atomic(exchange_explicit)(p, x, mi_memory_order(release))\n#define mi_atomic_exchange_acq_rel(p, x) \\\n\tmi_atomic(exchange_explicit)(p, x, mi_memory_order(acq_rel))\n#define mi_atomic_cas_weak_release(p, exp, des) \\\n\tmi_atomic_cas_weak(p, exp, des, mi_memory_order(release), mi_memory_order(relaxed))\n#define mi_atomic_cas_weak_acq_rel(p, exp, des) \\\n\tmi_atomic_cas_weak(p, exp, des, mi_memory_order(acq_rel), mi_memory_order(acquire))\n#define mi_atomic_cas_strong_release(p, exp, des) \\\n\tmi_atomic_cas_strong(p, exp, des, mi_memory_order(release), mi_memory_order(relaxed))\n#define mi_atomic_cas_strong_acq_rel(p, exp, des) \\\n\tmi_atomic_cas_strong(p, exp, des, mi_memory_order(acq_rel), mi_memory_order(acquire))\n\n#define mi_atomic_add_relaxed(p, x) mi_atomic(fetch_add_explicit)(p, x, mi_memory_order(relaxed))\n#define mi_atomic_sub_relaxed(p, x) mi_atomic(fetch_sub_explicit)(p, x, mi_memory_order(relaxed))\n#define mi_atomic_add_acq_rel(p, x) mi_atomic(fetch_add_explicit)(p, x, mi_memory_order(acq_rel))\n#define mi_atomic_sub_acq_rel(p, x) mi_atomic(fetch_sub_explicit)(p, x, mi_memory_order(acq_rel))\n#define mi_atomic_and_acq_rel(p, x) mi_atomic(fetch_and_explicit)(p, x, mi_memory_order(acq_rel))\n#define mi_atomic_or_acq_rel(p, x) mi_atomic(fetch_or_explicit)(p, x, mi_memory_order(acq_rel))\n\n#define mi_atomic_increment_relaxed(p) mi_atomic_add_relaxed(p, (uintptr_t)1)\n#define mi_atomic_decrement_relaxed(p) mi_atomic_sub_relaxed(p, (uintptr_t)1)\n#define mi_atomic_increment_acq_rel(p) mi_atomic_add_acq_rel(p, (uintptr_t)1)\n#define mi_atomic_decrement_acq_rel(p) mi_atomic_sub_acq_rel(p, (uintptr_t)1)\n```",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 77,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8272607e_defe63b7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 81,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline intptr_t mi_atomic_addi(_Atomic(intptr_t)* p, intptr_t add);\nstatic inline intptr_t mi_atomic_subi(_Atomic(intptr_t)* p, intptr_t sub);\n```",
      "range": {
        "startLine": 80,
        "startChar": 0,
        "endLine": 81,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e63fd9b_81995631",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 89,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// In C++/C11 atomics we have polymorphic atomics so can use the typed `ptr` variants (where `tp` is\n// the type of atomic value) We use these macros so we can provide a typed wrapper in MSVC in C\n// compilation mode as well\n#define mi_atomic_load_ptr_acquire(tp, p) mi_atomic_load_acquire(p)\n#define mi_atomic_load_ptr_relaxed(tp, p) mi_atomic_load_relaxed(p)\n```",
      "range": {
        "startLine": 86,
        "startChar": 0,
        "endLine": 89,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a3982700_bc550a35",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 107,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_atomic_store_ptr_release(tp, p, x) mi_atomic_store_release(p, (tp*)x)\n#define mi_atomic_store_ptr_relaxed(tp, p, x) mi_atomic_store_relaxed(p, (tp*)x)\n#define mi_atomic_cas_ptr_weak_release(tp, p, exp, des) mi_atomic_cas_weak_release(p, exp, (tp*)des)\n#define mi_atomic_cas_ptr_weak_acq_rel(tp, p, exp, des) mi_atomic_cas_weak_acq_rel(p, exp, (tp*)des)\n#define mi_atomic_cas_ptr_strong_release(tp, p, exp, des) \\\n\tmi_atomic_cas_strong_release(p, exp, (tp*)des)\n#define mi_atomic_exchange_ptr_release(tp, p, x) mi_atomic_exchange_release(p, (tp*)x)\n#define mi_atomic_exchange_ptr_acq_rel(tp, p, x) mi_atomic_exchange_acq_rel(p, (tp*)x)\n#else\n#define mi_atomic_store_ptr_release(tp, p, x) mi_atomic_store_release(p, x)\n#define mi_atomic_store_ptr_relaxed(tp, p, x) mi_atomic_store_relaxed(p, x)\n#define mi_atomic_cas_ptr_weak_release(tp, p, exp, des) mi_atomic_cas_weak_release(p, exp, des)\n#define mi_atomic_cas_ptr_weak_acq_rel(tp, p, exp, des) mi_atomic_cas_weak_acq_rel(p, exp, des)\n#define mi_atomic_cas_ptr_strong_release(tp, p, exp, des) mi_atomic_cas_strong_release(p, exp, des)\n#define mi_atomic_exchange_ptr_release(tp, p, x) mi_atomic_exchange_release(p, x)\n#define mi_atomic_exchange_ptr_acq_rel(tp, p, x) mi_atomic_exchange_acq_rel(p, x)\n```",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 107,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "37a1b438_f9834804",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 116,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline int64_t\nmi_atomic_addi64_relaxed(volatile int64_t* p, int64_t add)\n{\n\treturn mi_atomic(fetch_add_explicit)((_Atomic(int64_t)*)p, add, mi_memory_order(relaxed));\n}\n\n\nstatic inline void\nmi_atomic_maxi64_relaxed(volatile int64_t* p, int64_t x)\n{\n\tint64_t current \u003d mi_atomic_load_relaxed((_Atomic(int64_t)*)p);\n\twhile (current \u003c x\n\t\t\u0026\u0026 !mi_atomic_cas_weak_release((_Atomic(int64_t)*)p, \u0026current, x)) { /* nothing */\n\t};\n```",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 116,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2be4ff39_1f44cba1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 126,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_atomic_loadi64_acquire(p) mi_atomic(load_explicit)(p, mi_memory_order(acquire))\n#define mi_atomic_loadi64_relaxed(p) mi_atomic(load_explicit)(p, mi_memory_order(relaxed))\n#define mi_atomic_storei64_release(p, x) mi_atomic(store_explicit)(p, x, mi_memory_order(release))\n#define mi_atomic_storei64_relaxed(p, x) mi_atomic(store_explicit)(p, x, mi_memory_order(relaxed))\n\n#define mi_atomic_casi64_strong_acq_rel(p, e, d) mi_atomic_cas_strong_acq_rel(p, e, d)\n#define mi_atomic_addi64_acq_rel(p, i) mi_atomic_add_acq_rel(p, i)\n```",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 126,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "23ab6de9_a4b85bc3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 132,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \u003cintrin.h\u003e\n```",
      "range": {
        "startLine": 132,
        "startChar": 0,
        "endLine": 132,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f1df90e_1b25760e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 134,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 134,
        "startChar": 0,
        "endLine": 134,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb617586_535440b5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 136,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef LONG64 msc_intptr_t;\n```",
      "range": {
        "startLine": 136,
        "startChar": 0,
        "endLine": 136,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff4de131_12814b11",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 139,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef LONG msc_intptr_t;\n```",
      "range": {
        "startLine": 139,
        "startChar": 0,
        "endLine": 139,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b43e3ae4_6736055e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 149,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_memory_order_relaxed,\n\tmi_memory_order_consume,\n\tmi_memory_order_acquire,\n\tmi_memory_order_release,\n\tmi_memory_order_acq_rel,\n\tmi_memory_order_seq_cst\n```",
      "range": {
        "startLine": 144,
        "startChar": 0,
        "endLine": 149,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d8c70e1_3afae588",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 192,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic inline uintptr_t\nmi_atomic_fetch_add_explicit(_Atomic(uintptr_t)* p, uintptr_t add, mi_memory_order mo)\n{\n\t(void)(mo);\n\treturn (uintptr_t)MI_64(_InterlockedExchangeAdd)((volatile msc_intptr_t*)p, (msc_intptr_t)add);\n}\n\n\nstatic inline uintptr_t\nmi_atomic_fetch_sub_explicit(_Atomic(uintptr_t)* p, uintptr_t sub, mi_memory_order mo)\n{\n\t(void)(mo);\n\treturn (uintptr_t)MI_64(\n\t\t_InterlockedExchangeAdd)((volatile msc_intptr_t*)p, -((msc_intptr_t)sub));\n}\n\n\nstatic inline uintptr_t\nmi_atomic_fetch_and_explicit(_Atomic(uintptr_t)* p, uintptr_t x, mi_memory_order mo)\n{\n\t(void)(mo);\n\treturn (uintptr_t)MI_64(_InterlockedAnd)((volatile msc_intptr_t*)p, (msc_intptr_t)x);\n}\n\n\nstatic inline uintptr_t\nmi_atomic_fetch_or_explicit(_Atomic(uintptr_t)* p, uintptr_t x, mi_memory_order mo)\n{\n\t(void)(mo);\n\treturn (uintptr_t)MI_64(_InterlockedOr)((volatile msc_intptr_t*)p, (msc_intptr_t)x);\n}\n\n\nstatic inline bool\nmi_atomic_compare_exchange_strong_explicit(_Atomic(uintptr_t)* p, uintptr_t* expected,\n\tuintptr_t desired, mi_memory_order mo1, mi_memory_order mo2)\n{\n\t(void)(mo1);\n\t(void)(mo2);\n\tuintptr_t read \u003d (uintptr_t)MI_64(_InterlockedCompareExchange)((volatile msc_intptr_t*)p,\n\t\t(msc_intptr_t)desired, (msc_intptr_t)(*expected));\n\tif (read \u003d\u003d *expected) {\n\t\treturn true;\n\t} else {\n\t\t*expected \u003d read;\n\t\treturn false;\n\t}\n}\n\n\nstatic inline bool\nmi_atomic_compare_exchange_weak_explicit(_Atomic(uintptr_t)* p, uintptr_t* expected,\n\tuintptr_t desired, mi_memory_order mo1, mi_memory_order mo2)\n{\n\treturn mi_atomic_compare_exchange_strong_explicit(p, expected, desired, mo1, mo2);\n}\n\n\nstatic inline uintptr_t\nmi_atomic_exchange_explicit(_Atomic(uintptr_t)* p, uintptr_t exchange, mi_memory_order mo)\n{\n\t(void)(mo);\n\treturn (uintptr_t)MI_64(\n\t\t_InterlockedExchange)((volatile msc_intptr_t*)p, (msc_intptr_t)exchange);\n}\n\n\nstatic inline void\nmi_atomic_thread_fence(mi_memory_order mo)\n{\n\t(void)(mo);\n\t_Atomic(uintptr_t) x \u003d 0;\n\tmi_atomic_exchange_explicit(\u0026x, 1, mo);\n}\n\n\nstatic inline uintptr_t\nmi_atomic_load_explicit(_Atomic(uintptr_t) const* p, mi_memory_order mo)\n{\n\t(void)(mo);\n```",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 192,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7791cde7_45351dd2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 204,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\treturn *p;\n#else\n\tuintptr_t x \u003d *p;\n\tif (mo \u003e mi_memory_order_relaxed) {\n\t\twhile (!mi_atomic_compare_exchange_weak_explicit(p, \u0026x, x, mo,\n\t\t\tmi_memory_order_relaxed)) { /* nothing */\n\t\t};\n\t}\n\treturn x;\n#endif\n}\n\n\nstatic inline void\nmi_atomic_store_explicit(_Atomic(uintptr_t)* p, uintptr_t x, mi_memory_order mo)\n{\n\t(void)(mo);\n```",
      "range": {
        "startLine": 194,
        "startChar": 0,
        "endLine": 204,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4092688d_e8febc96",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 212,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t*p \u003d x;\n#else\n\tmi_atomic_exchange_explicit(p, x, mo);\n#endif\n}\n\n\nstatic inline int64_t\nmi_atomic_loadi64_explicit(_Atomic(int64_t)* p, mi_memory_order mo)\n{\n\t(void)(mo);\n```",
      "range": {
        "startLine": 206,
        "startChar": 0,
        "endLine": 212,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ade1bc9b_4c77bd79",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 225,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\treturn *p;\n#else\n\tint64_t old \u003d *p;\n\tint64_t x \u003d old;\n\twhile ((old \u003d InterlockedCompareExchange64(p, x, old)) !\u003d x)\n\t\tx \u003d old;\n\treturn x;\n#endif\n}\n\n\nstatic inline void\nmi_atomic_storei64_explicit(_Atomic(int64_t)* p, int64_t x, mi_memory_order mo)\n{\n\t(void)(mo);\n```",
      "range": {
        "startLine": 214,
        "startChar": 0,
        "endLine": 225,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e06d778_9f73841e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 229,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t*p \u003d x;\n#else\n\tInterlockedExchange64(p, x);\n```",
      "range": {
        "startLine": 227,
        "startChar": 0,
        "endLine": 229,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ca830ea_939d58e2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 234,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline int64_t\nmi_atomic_addi64_relaxed(volatile _Atomic(int64_t)* p, int64_t add)\n{\n```",
      "range": {
        "startLine": 234,
        "startChar": 0,
        "endLine": 234,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9f1b8c2_dd1b7010",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 266,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\treturn (int64_t)mi_atomic_addi((int64_t*)p, add);\n#else\n\tint64_t current;\n\tint64_t sum;\n\tdo {\n\t\tcurrent \u003d *p;\n\t\tsum \u003d current + add;\n\t} while (_InterlockedCompareExchange64(p, sum, current) !\u003d current);\n\treturn current;\n#endif\n}\n\n\nstatic inline void\nmi_atomic_maxi64_relaxed(volatile _Atomic(int64_t)* p, int64_t x)\n{\n\tint64_t current;\n\tdo {\n\t\tcurrent \u003d *p;\n\t} while (current \u003c x \u0026\u0026 _InterlockedCompareExchange64(p, x, current) !\u003d current);\n}\n\n\nstatic inline void\nmi_atomic_addi64_acq_rel(volatile _Atomic(int64_t*) p, int64_t i)\n{\n\tmi_atomic_addi64_relaxed(p, i);\n}\n\n\nstatic inline bool\nmi_atomic_casi64_strong_acq_rel(volatile _Atomic(int64_t*) p, int64_t* exp, int64_t des)\n{\n\tint64_t read \u003d _InterlockedCompareExchange64(p, des, *exp);\n\tif (read \u003d\u003d *exp) {\n\t\treturn true;\n\t} else {\n\t\t*exp \u003d read;\n\t\treturn false;\n\t}\n```",
      "range": {
        "startLine": 236,
        "startChar": 0,
        "endLine": 266,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3c559c48_7c8726ef",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 283,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_atomic_load_ptr_acquire(tp, p) (tp*)mi_atomic_load_acquire((_Atomic(uintptr_t)*)(p))\n#define mi_atomic_load_ptr_relaxed(tp, p) (tp*)mi_atomic_load_relaxed((_Atomic(uintptr_t)*)(p))\n#define mi_atomic_store_ptr_release(tp, p, x) \\\n\tmi_atomic_store_release((_Atomic(uintptr_t)*)(p), (uintptr_t)(x))\n#define mi_atomic_store_ptr_relaxed(tp, p, x) \\\n\tmi_atomic_store_relaxed((_Atomic(uintptr_t)*)(p), (uintptr_t)(x))\n#define mi_atomic_cas_ptr_weak_release(tp, p, exp, des) \\\n\tmi_atomic_cas_weak_release((_Atomic(uintptr_t)*)(p), (uintptr_t*)exp, (uintptr_t)des)\n#define mi_atomic_cas_ptr_weak_acq_rel(tp, p, exp, des) \\\n\tmi_atomic_cas_weak_acq_rel((_Atomic(uintptr_t)*)(p), (uintptr_t*)exp, (uintptr_t)des)\n#define mi_atomic_cas_ptr_strong_release(tp, p, exp, des) \\\n\tmi_atomic_cas_strong_release((_Atomic(uintptr_t)*)(p), (uintptr_t*)exp, (uintptr_t)des)\n#define mi_atomic_exchange_ptr_release(tp, p, x) \\\n\t(tp*)mi_atomic_exchange_release((_Atomic(uintptr_t)*)(p), (uintptr_t)x)\n#define mi_atomic_exchange_ptr_acq_rel(tp, p, x) \\\n\t(tp*)mi_atomic_exchange_acq_rel((_Atomic(uintptr_t)*)(p), (uintptr_t)x)\n\n#define mi_atomic_loadi64_acquire(p) mi_atomic(loadi64_explicit)(p, mi_memory_order(acquire))\n#define mi_atomic_loadi64_relaxed(p) mi_atomic(loadi64_explicit)(p, mi_memory_order(relaxed))\n#define mi_atomic_storei64_release(p, x) \\\n\tmi_atomic(storei64_explicit)(p, x, mi_memory_order(release))\n#define mi_atomic_storei64_relaxed(p, x) \\\n\tmi_atomic(storei64_explicit)(p, x, mi_memory_order(relaxed))\n```",
      "range": {
        "startLine": 270,
        "startChar": 0,
        "endLine": 283,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "90ce3805_f8858eac",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 291,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline intptr_t\nmi_atomic_addi(_Atomic(intptr_t)* p, intptr_t add)\n{\n\treturn (intptr_t)mi_atomic_add_acq_rel((_Atomic(uintptr_t)*)p, (uintptr_t)add);\n```",
      "range": {
        "startLine": 290,
        "startChar": 0,
        "endLine": 291,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "158a1bdb_fed3a359",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 296,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline intptr_t\nmi_atomic_subi(_Atomic(intptr_t)* p, intptr_t sub)\n{\n\treturn (intptr_t)mi_atomic_addi(p, -sub);\n```",
      "range": {
        "startLine": 295,
        "startChar": 0,
        "endLine": 296,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac6b207a_095a7c2d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 305,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_atomic_once(mi_atomic_once_t* once)\n{\n\tif (mi_atomic_load_relaxed(once) !\u003d 0)\n\t\treturn false; // quick test\n\tuintptr_t expected \u003d 0;\n\treturn mi_atomic_cas_strong_acq_rel(once, \u0026expected, (uintptr_t)1); // try to set to 1\n```",
      "range": {
        "startLine": 302,
        "startChar": 0,
        "endLine": 305,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "78537e80_1ecbdad8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 316,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tuintptr_t _mi_guard_expected \u003d 0; \\\n\tfor (bool _mi_guard_once \u003d true; \\\n\t\t_mi_guard_once \u0026\u0026 mi_atomic_cas_strong_acq_rel(guard, \u0026_mi_guard_expected, (uintptr_t)1); \\\n\t\t(mi_atomic_store_release(guard, (uintptr_t)0), _mi_guard_once \u003d false))\n```",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 316,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c83511bb_d1490c3e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 323,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\tstd::this_thread::yield();\n```",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 323,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "39bfef5a_edddd866",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 329,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\tYieldProcessor();\n```",
      "range": {
        "startLine": 328,
        "startChar": 0,
        "endLine": 329,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95be63fd_bbfc1dfd",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 338,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\t_mm_pause();\n}\n#elif (defined(__GNUC__) || defined(__clang__)) \\\n\t\t\u0026\u0026 (defined(__x86_64__) || defined(__i386__) || defined(__arm__) || defined(__armel__) \\\n\t\t\t|| defined(__ARMEL__) || defined(__aarch64__) || defined(__powerpc__) \\\n\t\t\t|| defined(__ppc__) || defined(__PPC__)) \\\n\t|| defined(__POWERPC__)\n```",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 338,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6d9e6b0e_743081d5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 341,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\t__asm__ volatile(\"pause\" ::: \"memory\");\n```",
      "range": {
        "startLine": 340,
        "startChar": 0,
        "endLine": 341,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a030334c_5553d301",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 345,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\t__asm__ volatile(\"wfe\");\n```",
      "range": {
        "startLine": 344,
        "startChar": 0,
        "endLine": 345,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "244569cc_badb4dc7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 349,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\t__asm__ volatile(\"yield\" ::: \"memory\");\n```",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 349,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8dfeb719_4f2c3d9f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 358,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\t__asm__ volatile(\"or r27,r27,r27\" ::: \"memory\");\n}\n#else\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\t__asm__ __volatile__(\"or 27,27,27\" ::: \"memory\");\n```",
      "range": {
        "startLine": 353,
        "startChar": 0,
        "endLine": 358,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5f9743f3_90ee9c30",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 363,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\t__asm__ volatile(\"nop\" ::: \"memory\");\n```",
      "range": {
        "startLine": 362,
        "startChar": 0,
        "endLine": 363,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b7c4cd0_fdd21e3c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 370,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\tsmt_pause();\n```",
      "range": {
        "startLine": 369,
        "startChar": 0,
        "endLine": 370,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25a8768d_f77fbec7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 375,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\tsched_yield();\n```",
      "range": {
        "startLine": 374,
        "startChar": 0,
        "endLine": 375,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fdacb101_ee3fb4bb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/atomic.h",
        "patchSetId": 7
      },
      "lineNbr": 380,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\nmi_atomic_yield(void)\n{\n\tsleep(0);\n```",
      "range": {
        "startLine": 379,
        "startChar": 0,
        "endLine": 380,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "741232d2_77bb235b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/track.h\"\n```",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4cd2a492_46584fd1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 21,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n#if (MI_DEBUG \u003e 0)\n#define mi_trace_message(...) _mi_trace_message(__VA_ARGS__)\n```",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 21,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "381e5eac_9d283e8c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 26,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_CACHE_LINE 64\n```",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 26,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ae83b13_3fb0ceff",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#pragma warning(disable : 4127) // suppress constant conditional warning (due to MI_SECURE paths)\n#pragma warning(disable : 26812) // unscoped enum warning\n#define mi_decl_noinline __declspec(noinline)\n#define mi_decl_thread __declspec(thread)\n#define mi_decl_cache_align __declspec(align(MI_CACHE_LINE))\n```",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "27e736ae_8d62f41a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 36,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_decl_noinline __attribute__((noinline))\n#define mi_decl_thread __thread\n#define mi_decl_cache_align __attribute__((aligned(MI_CACHE_LINE)))\n```",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 36,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "10c12296_67c54918",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_decl_thread __thread // hope for the best :-)\n```",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07ec9170_a4862132",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 48,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_decl_externc extern \"C\"\n```",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2f5491e0_e6348a3a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_USE_PTHREADS\n```",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 55,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dde20d48_c8b8f185",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 66,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_fputs(mi_output_fun* out, void* arg, const char* prefix, const char* message);\nvoid _mi_fprintf(mi_output_fun* out, void* arg, const char* fmt, ...);\nvoid _mi_warning_message(const char* fmt, ...);\nvoid _mi_verbose_message(const char* fmt, ...);\nvoid _mi_trace_message(const char* fmt, ...);\nvoid _mi_options_init(void);\nvoid _mi_error_message(int err, const char* fmt, ...);\n```",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 66,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9575f943_5b62c331",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 75,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_random_init(mi_random_ctx_t* ctx);\nvoid _mi_random_init_weak(mi_random_ctx_t* ctx);\nvoid _mi_random_reinit_if_weak(mi_random_ctx_t* ctx);\nvoid _mi_random_split(mi_random_ctx_t* ctx, mi_random_ctx_t* new_ctx);\nuintptr_t _mi_random_next(mi_random_ctx_t* ctx);\nuintptr_t _mi_heap_random_next(mi_heap_t* heap);\nuintptr_t _mi_os_random_weak(uintptr_t extra_seed);\n```",
      "range": {
        "startLine": 69,
        "startChar": 0,
        "endLine": 75,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "34fb8cd8_7e0973a4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 83,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern mi_decl_cache_align mi_stats_t _mi_stats_main;\nextern mi_decl_cache_align const mi_page_t _mi_page_empty;\nbool _mi_is_main_thread(void);\nsize_t _mi_current_thread_count(void);\nbool _mi_preloading(void); // true while the C runtime is not initialized yet\n```",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "564505e7_673f7f31",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 87,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_heap_t* _mi_heap_main_get(void); // statically allocated main backing heap\nvoid _mi_thread_done(mi_heap_t* heap);\nvoid _mi_thread_data_collect(void);\n```",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 87,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "460ab611_427949e3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 116,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_os_init(void); // called from process init\nvoid* _mi_os_alloc(size_t size, mi_memid_t* memid, mi_stats_t* stats);\nvoid _mi_os_free(void* p, size_t size, mi_memid_t memid, mi_stats_t* stats);\nvoid _mi_os_free_ex(void* p, size_t size, bool still_committed, mi_memid_t memid,\n\tmi_stats_t* stats);\n\nsize_t _mi_os_page_size(void);\nsize_t _mi_os_good_alloc_size(size_t size);\nbool _mi_os_has_overcommit(void);\nbool _mi_os_has_virtual_reserve(void);\n\nbool _mi_os_purge(void* p, size_t size, mi_stats_t* stats);\nbool _mi_os_reset(void* addr, size_t size, mi_stats_t* tld_stats);\nbool _mi_os_commit(void* p, size_t size, bool* is_zero, mi_stats_t* stats);\nbool _mi_os_decommit(void* addr, size_t size, mi_stats_t* stats);\nbool _mi_os_protect(void* addr, size_t size);\nbool _mi_os_unprotect(void* addr, size_t size);\nbool _mi_os_purge(void* p, size_t size, mi_stats_t* stats);\nbool _mi_os_purge_ex(void* p, size_t size, bool allow_reset, mi_stats_t* stats);\n\nvoid* _mi_os_alloc_aligned(size_t size, size_t alignment, bool commit, bool allow_large,\n\tmi_memid_t* memid, mi_stats_t* stats);\nvoid* _mi_os_alloc_aligned_at_offset(size_t size, size_t alignment, size_t align_offset,\n\tbool commit, bool allow_large, mi_memid_t* memid, mi_stats_t* tld_stats);\n\nvoid* _mi_os_get_aligned_hint(size_t try_alignment, size_t size);\nbool _mi_os_use_large_page(size_t size, size_t alignment);\nsize_t _mi_os_large_page_size(void);\n\nvoid* _mi_os_alloc_huge_os_pages(size_t pages, int numa_node, mi_msecs_t max_secs,\n\tsize_t* pages_reserved, size_t* psize, mi_memid_t* memid);\n```",
      "range": {
        "startLine": 90,
        "startChar": 0,
        "endLine": 116,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84266e36_f2ae5c1d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 126,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_arena_free(void* p, size_t size, size_t still_committed_size, mi_memid_t memid,\n\tmi_stats_t* stats);\nvoid* _mi_arena_alloc(size_t size, bool commit, bool allow_large, mi_arena_id_t req_arena_id,\n\tmi_memid_t* memid, mi_os_tld_t* tld);\nvoid* _mi_arena_alloc_aligned(size_t size, size_t alignment, size_t align_offset, bool commit,\n\tbool allow_large, mi_arena_id_t req_arena_id, mi_memid_t* memid, mi_os_tld_t* tld);\nbool _mi_arena_memid_is_suitable(mi_memid_t memid, mi_arena_id_t request_arena_id);\nbool _mi_arena_contains(const void* p);\nvoid _mi_arena_collect(bool force_purge, mi_stats_t* stats);\nvoid _mi_arena_unsafe_destroy_all(mi_stats_t* stats);\n```",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 126,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c38bfc4_62b3f687",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 130,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_segment_map_allocated_at(const mi_segment_t* segment);\nvoid _mi_segment_map_freed_at(const mi_segment_t* segment);\n```",
      "range": {
        "startLine": 129,
        "startChar": 0,
        "endLine": 130,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b008d5d2_af2437d2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 137,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_page_t* _mi_segment_page_alloc(mi_heap_t* heap, size_t block_size, size_t page_alignment,\n\tmi_segments_tld_t* tld, mi_os_tld_t* os_tld);\nvoid _mi_segment_page_free(mi_page_t* page, bool force, mi_segments_tld_t* tld);\nvoid _mi_segment_page_abandon(mi_page_t* page, mi_segments_tld_t* tld);\nbool _mi_segment_try_reclaim_abandoned(mi_heap_t* heap, bool try_all, mi_segments_tld_t* tld);\nvoid _mi_segment_thread_collect(mi_segments_tld_t* tld);\n```",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 137,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7e186df5_5ec44b75",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 148,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_segment_huge_page_free(mi_segment_t* segment, mi_page_t* page, mi_block_t* block);\n#else\nvoid _mi_segment_huge_page_reset(mi_segment_t* segment, mi_page_t* page, mi_block_t* block);\n#endif\n\nuint8_t* _mi_segment_page_start(const mi_segment_t* segment, const mi_page_t* page,\n\tsize_t* page_size); // page start for any page\nvoid _mi_abandoned_reclaim_all(mi_heap_t* heap, mi_segments_tld_t* tld);\nvoid _mi_abandoned_await_readers(void);\nvoid _mi_abandoned_collect(mi_heap_t* heap, bool force, mi_segments_tld_t* tld);\n```",
      "range": {
        "startLine": 140,
        "startChar": 0,
        "endLine": 148,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e553cd75_bdf6bc43",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 170,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid* _mi_malloc_generic(mi_heap_t* heap, size_t size, bool zero,\n\tsize_t huge_alignment) mi_attr_noexcept mi_attr_malloc;\n\nvoid _mi_page_retire(mi_page_t* page)\n\tmi_attr_noexcept; // free the page if there are no other pages with many free blocks\nvoid _mi_page_unfull(mi_page_t* page);\nvoid _mi_page_free(mi_page_t* page, mi_page_queue_t* pq, bool force); // free the page\nvoid _mi_page_abandon(mi_page_t* page,\n\tmi_page_queue_t* pq); // abandon the page, to be picked up by another thread...\nvoid _mi_heap_delayed_free_all(mi_heap_t* heap);\nbool _mi_heap_delayed_free_partial(mi_heap_t* heap);\nvoid _mi_heap_collect_retired(mi_heap_t* heap, bool force);\n\nvoid _mi_page_use_delayed_free(mi_page_t* page, mi_delayed_t delay, bool override_never);\nbool _mi_page_try_use_delayed_free(mi_page_t* page, mi_delayed_t delay, bool override_never);\nsize_t _mi_page_queue_append(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_queue_t* append);\nvoid _mi_deferred_free(mi_heap_t* heap, bool force);\n\nvoid _mi_page_free_collect(mi_page_t* page, bool force);\nvoid _mi_page_reclaim(mi_heap_t* heap, mi_page_t* page); // callback from segments\n\nsize_t _mi_bin_size(uint8_t bin); // for stats\nuint8_t _mi_bin(size_t size); // for stats\n```",
      "range": {
        "startLine": 151,
        "startChar": 0,
        "endLine": 170,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e3cd1fc9_bb652339",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 177,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_heap_destroy_pages(mi_heap_t* heap);\nvoid _mi_heap_collect_abandon(mi_heap_t* heap);\nvoid _mi_heap_set_default_direct(mi_heap_t* heap);\nbool _mi_heap_memid_is_suitable(mi_heap_t* heap, mi_memid_t memid);\nvoid _mi_heap_unsafe_destroy_all(void);\n```",
      "range": {
        "startLine": 173,
        "startChar": 0,
        "endLine": 177,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c909dad3_c8ac6399",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 183,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_stats_done(mi_stats_t* stats);\nmi_msecs_t _mi_clock_now(void);\nmi_msecs_t _mi_clock_end(mi_msecs_t start);\nmi_msecs_t _mi_clock_start(void);\n```",
      "range": {
        "startLine": 180,
        "startChar": 0,
        "endLine": 183,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ed61ca41_31e2500a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 189,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid* _mi_page_malloc(mi_heap_t* heap, mi_page_t* page, size_t size,\n\tbool zero) mi_attr_noexcept; // called from `_mi_malloc_generic`\nvoid* _mi_heap_malloc_zero(mi_heap_t* heap, size_t size, bool zero) mi_attr_noexcept;\nvoid* _mi_heap_malloc_zero_ex(mi_heap_t* heap, size_t size, bool zero,\n\tsize_t huge_alignment) mi_attr_noexcept; // called from `_mi_heap_malloc_aligned`\nvoid* _mi_heap_realloc_zero(mi_heap_t* heap, void* p, size_t newsize, bool zero) mi_attr_noexcept;\n```",
      "range": {
        "startLine": 186,
        "startChar": 0,
        "endLine": 189,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45573d97_fc6bdef1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 193,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool _mi_free_delayed_block(mi_block_t* block);\nvoid _mi_free_generic(const mi_segment_t* segment, mi_page_t* page, bool is_local,\n\tvoid* p) mi_attr_noexcept; // for runtime integration\nvoid _mi_padding_shrink(const mi_page_t* page, const mi_block_t* block, const size_t min_size);\n```",
      "range": {
        "startLine": 191,
        "startChar": 0,
        "endLine": 193,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5751f3e_f8259f14",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 205,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nchar _mi_toupper(char c);\nint _mi_strnicmp(const char* s, const char* t, size_t n);\nvoid _mi_strlcpy(char* dest, const char* src, size_t dest_size);\nvoid _mi_strlcat(char* dest, const char* src, size_t dest_size);\nsize_t _mi_strlen(const char* s);\nsize_t _mi_strnlen(const char* s, size_t max_len);\n\n\n#if MI_DEBUG \u003e 1\nbool _mi_page_is_valid(mi_page_t* page);\n```",
      "range": {
        "startLine": 196,
        "startChar": 0,
        "endLine": 205,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6db7b238_81970fc0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 221,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_unlikely(x) (__builtin_expect(!!(x), false))\n#define mi_likely(x) (__builtin_expect(!!(x), true))\n#elif (defined(__cplusplus) \u0026\u0026 (__cplusplus \u003e\u003d 202002L)) \\\n\t|| (defined(_MSVC_LANG) \u0026\u0026 _MSVC_LANG \u003e\u003d 202002L)\n#define mi_unlikely(x) (x) [[unlikely]]\n#define mi_likely(x) (x) [[likely]]\n#else\n#define mi_unlikely(x) (x)\n#define mi_likely(x) (x)\n```",
      "range": {
        "startLine": 214,
        "startChar": 0,
        "endLine": 221,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1e11cb7e_a5e273b3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 225,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define __has_builtin(x) 0\n```",
      "range": {
        "startLine": 225,
        "startChar": 0,
        "endLine": 225,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f6396cc5_fbd5bc43",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 236,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#ifndef EAGAIN // double free\n```",
      "range": {
        "startLine": 236,
        "startChar": 0,
        "endLine": 236,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f03cb8d_993e23b2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 239,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#ifndef ENOMEM // out of memory\n```",
      "range": {
        "startLine": 239,
        "startChar": 0,
        "endLine": 239,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2574503e_fc02d7e3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 242,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#ifndef EFAULT // corrupted free-list or meta-data\n```",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 242,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "70b7c6d9_949f44c3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 245,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#ifndef EINVAL // trying to free an invalid pointer\n```",
      "range": {
        "startLine": 245,
        "startChar": 0,
        "endLine": 245,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e03c88f1_44a4a33e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 248,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#ifndef EOVERFLOW // count*size overflow\n```",
      "range": {
        "startLine": 248,
        "startChar": 0,
        "endLine": 248,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53616fbc_b16abf17",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 257,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_UNUSED(x) (void)(x)\n#if (MI_DEBUG \u003e 0)\n```",
      "range": {
        "startLine": 256,
        "startChar": 0,
        "endLine": 257,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d4b657c_5cabe0d2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 269,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_UNUSED_RELEASE(x) MI_UNUSED(x)\n#endif\n\n#define MI_INIT4(x) x(), x(), x(), x()\n#define MI_INIT8(x) MI_INIT4(x), MI_INIT4(x)\n#define MI_INIT16(x) MI_INIT8(x), MI_INIT8(x)\n#define MI_INIT32(x) MI_INIT16(x), MI_INIT16(x)\n#define MI_INIT64(x) MI_INIT32(x), MI_INIT32(x)\n#define MI_INIT128(x) MI_INIT64(x), MI_INIT64(x)\n#define MI_INIT256(x) MI_INIT128(x), MI_INIT128(x)\n```",
      "range": {
        "startLine": 260,
        "startChar": 0,
        "endLine": 269,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d5c6564e_aa4ca27f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 274,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _mi_memzero_var(x) memset(\u0026x, 0, sizeof(x))\n```",
      "range": {
        "startLine": 274,
        "startChar": 0,
        "endLine": 274,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "504ef139_42f42878",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 278,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\n_mi_is_power_of_two(uintptr_t x)\n{\n\treturn (x \u0026 (x - 1)) \u003d\u003d 0;\n```",
      "range": {
        "startLine": 277,
        "startChar": 0,
        "endLine": 278,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b196293_a62654ce",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 284,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\n_mi_is_aligned(void* p, size_t alignment)\n{\n\tmi_assert_internal(alignment !\u003d 0);\n\treturn ((uintptr_t)p % alignment) \u003d\u003d 0;\n```",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 284,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf8118ea_357ddd7c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 296,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline uintptr_t\n_mi_align_up(uintptr_t sz, size_t alignment)\n{\n\tmi_assert_internal(alignment !\u003d 0);\n\tuintptr_t mask \u003d alignment - 1;\n\tif ((alignment \u0026 mask) \u003d\u003d 0) // power of two?\n\t\treturn (sz + mask) \u0026 ~mask;\n\telse\n\t\treturn ((sz + mask) / alignment) * alignment;\n```",
      "range": {
        "startLine": 288,
        "startChar": 0,
        "endLine": 296,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "75ddd12f_dbb72e1b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 308,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline uintptr_t\n_mi_align_down(uintptr_t sz, size_t alignment)\n{\n\tmi_assert_internal(alignment !\u003d 0);\n\tuintptr_t mask \u003d alignment - 1;\n\tif ((alignment \u0026 mask) \u003d\u003d 0) // power of two?\n\t\treturn sz \u0026 ~mask;\n\telse\n\t\treturn (sz / alignment) * alignment;\n```",
      "range": {
        "startLine": 300,
        "startChar": 0,
        "endLine": 308,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f73b32f9_b84b3f38",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 314,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline uintptr_t\n_mi_divide_up(uintptr_t size, size_t divider)\n{\n\tmi_assert_internal(divider !\u003d 0);\n\treturn divider \u003d\u003d 0 ? size : ((size + divider - 1) / divider);\n```",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 314,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "851051b2_8a3e75f6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 322,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_mem_is_zero(const void* p, size_t size)\n{\n\tfor (size_t i \u003d 0; i \u003c size; i++) {\n\t\tif (((uint8_t*)p)[i] !\u003d 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n```",
      "range": {
        "startLine": 318,
        "startChar": 0,
        "endLine": 322,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cac55fdb_69d534f8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 330,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\n_mi_wsize_from_size(size_t size)\n{\n\tmi_assert_internal(size \u003c\u003d SIZE_MAX - sizeof(uintptr_t));\n\treturn (size + sizeof(uintptr_t) - 1) / sizeof(uintptr_t);\n```",
      "range": {
        "startLine": 328,
        "startChar": 0,
        "endLine": 330,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54b75e85_c83fc65a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 336,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003climits.h\u003e // UINT_MAX, ULONG_MAX\n#if defined(_CLOCK_T) // for Illumos\n```",
      "range": {
        "startLine": 335,
        "startChar": 0,
        "endLine": 336,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a691607_112d5f11",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 346,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline bool\nmi_mul_overflow(size_t count, size_t size, size_t* total)\n{\n#if (SIZE_MAX \u003d\u003d ULONG_MAX)\n\treturn __builtin_umull_overflow(count, size, (unsigned long*)total);\n#elif (SIZE_MAX \u003d\u003d UINT_MAX)\n\treturn __builtin_umul_overflow(count, size, (unsigned int*)total);\n#else\n\treturn __builtin_umulll_overflow(count, size, (unsigned long long*)total);\n#endif\n```",
      "range": {
        "startLine": 339,
        "startChar": 0,
        "endLine": 346,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "555ca26a_c2feee7e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 353,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline bool\nmi_mul_overflow(size_t count, size_t size, size_t* total)\n{\n#define MI_MUL_NO_OVERFLOW ((size_t)1 \u003c\u003c (4 * sizeof(size_t))) // sqrt(SIZE_MAX)\n\t*total \u003d count * size;\n\t// note: gcc/clang optimize this to directly check the overflow flag\n\treturn (size \u003e\u003d MI_MUL_NO_OVERFLOW || count \u003e\u003d MI_MUL_NO_OVERFLOW) \u0026\u0026 size \u003e 0\n\t\t\u0026\u0026 (SIZE_MAX / size) \u003c count;\n```",
      "range": {
        "startLine": 349,
        "startChar": 0,
        "endLine": 353,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "771ae5e7_a0f57c37",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 370,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_count_size_overflow(size_t count, size_t size, size_t* total)\n{\n\tif (count \u003d\u003d 1) { // quick check for the case where count is one (common for C++ allocators)\n\t\t*total \u003d size;\n\t\treturn false;\n\t} else if mi_unlikely (mi_mul_overflow(count, size, total)) {\n#if MI_DEBUG \u003e 0\n\t\t_mi_error_message(EOVERFLOW, \"allocation request is too large (%zu * %zu bytes)\\n\", count,\n\t\t\tsize);\n#endif\n\t\t*total \u003d SIZE_MAX;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n```",
      "range": {
        "startLine": 358,
        "startChar": 0,
        "endLine": 370,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ebb8c585_9d28cad1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 392,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern const mi_heap_t\n\t_mi_heap_empty; // read-only empty heap, initial value of the thread local default heap\n\n\nstatic inline bool\nmi_heap_is_backing(const mi_heap_t* heap)\n{\n\treturn heap-\u003etld-\u003eheap_backing \u003d\u003d heap;\n}\n\n\nstatic inline bool\nmi_heap_is_initialized(mi_heap_t* heap)\n{\n\tmi_assert_internal(heap !\u003d NULL);\n\treturn heap !\u003d \u0026_mi_heap_empty;\n}\n\n\nstatic inline uintptr_t\n_mi_ptr_cookie(const void* p)\n{\n\textern mi_heap_t _mi_heap_main;\n\tmi_assert_internal(_mi_heap_main.cookie !\u003d 0);\n\treturn (uintptr_t)p ^ _mi_heap_main.cookie;\n```",
      "range": {
        "startLine": 378,
        "startChar": 0,
        "endLine": 392,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4d60b283_bb96f4e7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 403,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_page_t*\n_mi_heap_get_free_small_page(mi_heap_t* heap, size_t size)\n{\n\tmi_assert_internal(size \u003c\u003d (MI_SMALL_SIZE_MAX + MI_PADDING_SIZE));\n\tconst size_t idx \u003d _mi_wsize_from_size(size);\n\tmi_assert_internal(idx \u003c MI_PAGES_DIRECT);\n\treturn heap-\u003epages_free_direct[idx];\n```",
      "range": {
        "startLine": 399,
        "startChar": 0,
        "endLine": 403,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "706b9026_cd52502b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 422,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Large aligned blocks may be aligned at N*MI_SEGMENT_SIZE (inside a huge segment \u003e\n// MI_SEGMENT_SIZE), and we need align \"down\" to the segment info which is `MI_SEGMENT_SIZE` bytes\n// before it; therefore we align one byte before `p`.\nstatic inline mi_segment_t*\n_mi_ptr_segment(const void* p)\n{\n\tmi_assert_internal(p !\u003d NULL);\n\treturn (mi_segment_t*)(((uintptr_t)p - 1) \u0026 ~MI_SEGMENT_MASK);\n}\n\n\nstatic inline mi_page_t*\nmi_slice_to_page(mi_slice_t* s)\n{\n\tmi_assert_internal(s-\u003eslice_offset \u003d\u003d 0 \u0026\u0026 s-\u003eslice_count \u003e 0);\n\treturn (mi_page_t*)(s);\n}\n\n\nstatic inline mi_slice_t*\nmi_page_to_slice(mi_page_t* p)\n{\n\tmi_assert_internal(p-\u003eslice_offset \u003d\u003d 0 \u0026\u0026 p-\u003eslice_count \u003e 0);\n\treturn (mi_slice_t*)(p);\n```",
      "range": {
        "startLine": 407,
        "startChar": 0,
        "endLine": 422,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bba5bfaf_e680dfa3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 437,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_segment_t*\n_mi_page_segment(const mi_page_t* page)\n{\n\tmi_segment_t* segment \u003d _mi_ptr_segment(page);\n\tmi_assert_internal(segment \u003d\u003d NULL\n\t\t|| ((mi_slice_t*)page \u003e\u003d segment-\u003eslices\n\t\t\t\u0026\u0026 (mi_slice_t*)page \u003c segment-\u003eslices + segment-\u003eslice_entries));\n\treturn segment;\n}\n\n\nstatic inline mi_slice_t*\nmi_slice_first(const mi_slice_t* slice)\n{\n\tmi_slice_t* start \u003d (mi_slice_t*)((uint8_t*)slice - slice-\u003eslice_offset);\n\tmi_assert_internal(start \u003e\u003d _mi_ptr_segment(slice)-\u003eslices);\n\tmi_assert_internal(start-\u003eslice_offset \u003d\u003d 0);\n\tmi_assert_internal(start + start-\u003eslice_count \u003e slice);\n\treturn start;\n```",
      "range": {
        "startLine": 426,
        "startChar": 0,
        "endLine": 437,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "11dff407_16a3b302",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 451,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_page_t*\n_mi_segment_page_of(const mi_segment_t* segment, const void* p)\n{\n\tmi_assert_internal(p \u003e (void*)segment);\n\tptrdiff_t diff \u003d (uint8_t*)p - (uint8_t*)segment;\n\tmi_assert_internal(diff \u003e 0 \u0026\u0026 diff \u003c\u003d (ptrdiff_t)MI_SEGMENT_SIZE);\n\tsize_t idx \u003d (size_t)diff \u003e\u003e MI_SEGMENT_SLICE_SHIFT;\n\tmi_assert_internal(idx \u003c\u003d segment-\u003eslice_entries);\n\tmi_slice_t* slice0 \u003d (mi_slice_t*)\u0026segment-\u003eslices[idx];\n\tmi_slice_t* slice \u003d mi_slice_first(slice0); // adjust to the block that holds the page data\n\tmi_assert_internal(slice-\u003eslice_offset \u003d\u003d 0);\n\tmi_assert_internal(\n\t\tslice \u003e\u003d segment-\u003eslices \u0026\u0026 slice \u003c segment-\u003eslices + segment-\u003eslice_entries);\n\treturn mi_slice_to_page(slice);\n```",
      "range": {
        "startLine": 441,
        "startChar": 0,
        "endLine": 451,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ba0219d_fec646f0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 456,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline uint8_t*\n_mi_page_start(const mi_segment_t* segment, const mi_page_t* page, size_t* page_size)\n{\n\treturn _mi_segment_page_start(segment, page, page_size);\n```",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 456,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d086ae2_bdda3b9f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 461,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_page_t*\n_mi_ptr_page(void* p)\n{\n\treturn _mi_segment_page_of(_mi_ptr_segment(p), p);\n```",
      "range": {
        "startLine": 460,
        "startChar": 0,
        "endLine": 461,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "829e995a_5252bb56",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 479,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_page_block_size(const mi_page_t* page)\n{\n\tconst size_t bsize \u003d page-\u003exblock_size;\n\tmi_assert_internal(bsize \u003e 0);\n\tif mi_likely (bsize \u003c MI_HUGE_BLOCK_SIZE) {\n\t\treturn bsize;\n\t} else {\n\t\tsize_t psize;\n\t\t_mi_segment_page_start(_mi_page_segment(page), page, \u0026psize);\n\t\treturn psize;\n\t}\n}\n\n\nstatic inline bool\nmi_page_is_huge(const mi_page_t* page)\n{\n\treturn _mi_page_segment(page)-\u003ekind \u003d\u003d MI_SEGMENT_HUGE;\n```",
      "range": {
        "startLine": 465,
        "startChar": 0,
        "endLine": 479,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c196eb2a_f0d22ddf",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 485,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_page_usable_block_size(const mi_page_t* page)\n{\n\treturn mi_page_block_size(page) - MI_PADDING_SIZE;\n```",
      "range": {
        "startLine": 484,
        "startChar": 0,
        "endLine": 485,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c7f26d4_a8aeebc8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 494,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_segment_size(mi_segment_t* segment)\n{\n\treturn segment-\u003esegment_slices * MI_SEGMENT_SLICE_SIZE;\n}\n\n\nstatic inline uint8_t*\nmi_segment_end(mi_segment_t* segment)\n{\n\treturn (uint8_t*)segment + mi_segment_size(segment);\n```",
      "range": {
        "startLine": 489,
        "startChar": 0,
        "endLine": 494,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "88ec24a4_3e34cecb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 503,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_block_t*\nmi_page_thread_free(const mi_page_t* page)\n{\n\treturn (mi_block_t*)(mi_atomic_load_relaxed(\u0026((mi_page_t*)page)-\u003exthread_free) \u0026 ~3);\n}\n\n\nstatic inline mi_delayed_t\nmi_page_thread_free_flag(const mi_page_t* page)\n{\n\treturn (mi_delayed_t)(mi_atomic_load_relaxed(\u0026((mi_page_t*)page)-\u003exthread_free) \u0026 3);\n```",
      "range": {
        "startLine": 498,
        "startChar": 0,
        "endLine": 503,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63cec080_bd68dbac",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 513,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_heap_t*\nmi_page_heap(const mi_page_t* page)\n{\n\treturn (mi_heap_t*)(mi_atomic_load_relaxed(\u0026((mi_page_t*)page)-\u003exheap));\n}\n\n\nstatic inline void\nmi_page_set_heap(mi_page_t* page, mi_heap_t* heap)\n{\n\tmi_assert_internal(mi_page_thread_free_flag(page) !\u003d MI_DELAYED_FREEING);\n\tmi_atomic_store_release(\u0026page-\u003exheap, (uintptr_t)heap);\n```",
      "range": {
        "startLine": 507,
        "startChar": 0,
        "endLine": 513,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00738f38_3233e249",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 530,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_block_t*\nmi_tf_block(mi_thread_free_t tf)\n{\n\treturn (mi_block_t*)(tf \u0026 ~0x03);\n}\n\n\nstatic inline mi_delayed_t\nmi_tf_delayed(mi_thread_free_t tf)\n{\n\treturn (mi_delayed_t)(tf \u0026 0x03);\n}\n\n\nstatic inline mi_thread_free_t\nmi_tf_make(mi_block_t* block, mi_delayed_t delayed)\n{\n\treturn (mi_thread_free_t)((uintptr_t)block | (uintptr_t)delayed);\n}\n\n\nstatic inline mi_thread_free_t\nmi_tf_set_delayed(mi_thread_free_t tf, mi_delayed_t delayed)\n{\n\treturn mi_tf_make(mi_tf_block(tf), delayed);\n}\n\n\nstatic inline mi_thread_free_t\nmi_tf_set_block(mi_thread_free_t tf, mi_block_t* block)\n{\n\treturn mi_tf_make(block, mi_tf_delayed(tf));\n```",
      "range": {
        "startLine": 517,
        "startChar": 0,
        "endLine": 530,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a77ae3e3_a90624d0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 537,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// note: needs up-to-date used count, (as the `xthread_free` list may not be empty). see\n// `_mi_page_collect_free`.\nstatic inline bool\nmi_page_all_free(const mi_page_t* page)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\treturn page-\u003eused \u003d\u003d 0;\n```",
      "range": {
        "startLine": 534,
        "startChar": 0,
        "endLine": 537,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c52c5f30_d88996fb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 543,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_page_has_any_available(const mi_page_t* page)\n{\n\tmi_assert_internal(page !\u003d NULL \u0026\u0026 page-\u003ereserved \u003e 0);\n\treturn page-\u003eused \u003c page-\u003ereserved || (mi_page_thread_free(page) !\u003d NULL);\n```",
      "range": {
        "startLine": 541,
        "startChar": 0,
        "endLine": 543,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aa857d29_9125c15d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 549,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_page_immediate_available(const mi_page_t* page)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\treturn page-\u003efree !\u003d NULL;\n```",
      "range": {
        "startLine": 547,
        "startChar": 0,
        "endLine": 549,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49c2c6ad_bbea2759",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 562,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_page_mostly_used(const mi_page_t* page)\n{\n\tif (page \u003d\u003d NULL)\n\t\treturn true;\n\tuint16_t frac \u003d page-\u003ereserved / 8U;\n\treturn page-\u003ereserved - page-\u003eused \u003c\u003d frac;\n}\n\n\nstatic inline mi_page_queue_t*\nmi_page_queue(const mi_heap_t* heap, size_t size)\n{\n\treturn \u0026((mi_heap_t*)heap)-\u003epages[_mi_bin(size)];\n}\n```",
      "range": {
        "startLine": 553,
        "startChar": 0,
        "endLine": 562,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca24551f_9b28f981",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 581,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_page_is_in_full(const mi_page_t* page)\n{\n\treturn page-\u003eflags.x.in_full;\n}\n\n\nstatic inline void\nmi_page_set_in_full(mi_page_t* page, bool in_full)\n{\n\tpage-\u003eflags.x.in_full \u003d in_full;\n}\n\n\nstatic inline bool\nmi_page_has_aligned(const mi_page_t* page)\n{\n\treturn page-\u003eflags.x.has_aligned;\n}\n\n\nstatic inline void\nmi_page_set_has_aligned(mi_page_t* page, bool has_aligned)\n{\n\tpage-\u003eflags.x.has_aligned \u003d has_aligned;\n```",
      "range": {
        "startLine": 568,
        "startChar": 0,
        "endLine": 581,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a09ef125_de803beb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 689,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_is_in_same_segment(const void* p, const void* q)\n{\n\treturn _mi_ptr_segment(p) \u003d\u003d _mi_ptr_segment(q);\n}\n\n\nstatic inline bool\nmi_is_in_same_page(const void* p, const void* q)\n{\n\tmi_segment_t* segment \u003d _mi_ptr_segment(p);\n\tif (_mi_ptr_segment(q) !\u003d segment)\n\t\treturn false;\n\t// assume q may be invalid // return (_mi_segment_page_of(segment, p) \u003d\u003d\n\t// _mi_segment_page_of(segment, q));\n\tmi_page_t* page \u003d _mi_segment_page_of(segment, p);\n\tsize_t psize;\n\tuint8_t* start \u003d _mi_segment_page_start(segment, page, \u0026psize);\n\treturn start \u003c\u003d (uint8_t*)q \u0026\u0026 (uint8_t*)q \u003c start + psize;\n}\n\n\nstatic inline uintptr_t\nmi_rotl(uintptr_t x, uintptr_t shift)\n{\n\tshift %\u003d MI_INTPTR_BITS;\n\treturn shift \u003d\u003d 0 ? x : ((x \u003c\u003c shift) | (x \u003e\u003e (MI_INTPTR_BITS - shift)));\n}\n\n\nstatic inline uintptr_t\nmi_rotr(uintptr_t x, uintptr_t shift)\n{\n\tshift %\u003d MI_INTPTR_BITS;\n\treturn shift \u003d\u003d 0 ? x : ((x \u003e\u003e shift) | (x \u003c\u003c (MI_INTPTR_BITS - shift)));\n}\n\n\nstatic inline void*\nmi_ptr_decode(const void* null, const mi_encoded_t x, const uintptr_t* keys)\n{\n\tvoid* p \u003d (void*)(mi_rotr(x - keys[0], keys[0]) ^ keys[1]);\n\treturn p \u003d\u003d null ? NULL : p;\n}\n\n\nstatic inline mi_encoded_t\nmi_ptr_encode(const void* null, const void* p, const uintptr_t* keys)\n{\n\tuintptr_t x \u003d (uintptr_t)(p \u003d\u003d NULL ? null : p);\n\treturn mi_rotl(x ^ keys[1], keys[0]) + keys[0];\n}\n\n\nstatic inline mi_block_t*\nmi_block_nextx(const void* null, const mi_block_t* block, const uintptr_t* keys)\n{\n\tmi_track_mem_defined(block, sizeof(mi_block_t));\n\tmi_block_t* next;\n#ifdef MI_ENCODE_FREELIST\n\tnext \u003d (mi_block_t*)mi_ptr_decode(null, block-\u003enext, keys);\n#else\n\tMI_UNUSED(keys);\n\tMI_UNUSED(null);\n\tnext \u003d (mi_block_t*)block-\u003enext;\n#endif\n\tmi_track_mem_noaccess(block, sizeof(mi_block_t));\n\treturn next;\n}\n\n\nstatic inline void\nmi_block_set_nextx(const void* null, mi_block_t* block, const mi_block_t* next,\n\tconst uintptr_t* keys)\n{\n\tmi_track_mem_undefined(block, sizeof(mi_block_t));\n#ifdef MI_ENCODE_FREELIST\n\tblock-\u003enext \u003d mi_ptr_encode(null, next, keys);\n#else\n\tMI_UNUSED(keys);\n\tMI_UNUSED(null);\n\tblock-\u003enext \u003d (mi_encoded_t)next;\n#endif\n\tmi_track_mem_noaccess(block, sizeof(mi_block_t));\n}\n\n\nstatic inline mi_block_t*\nmi_block_next(const mi_page_t* page, const mi_block_t* block)\n{\n#ifdef MI_ENCODE_FREELIST\n\tmi_block_t* next \u003d mi_block_nextx(page, block, page-\u003ekeys);\n\t// check for free list corruption: is `next` at least in the same page?\n\t// TODO: check if `next` is `page-\u003eblock_size` aligned?\n\tif mi_unlikely (next !\u003d NULL \u0026\u0026 !mi_is_in_same_page(block, next)) {\n\t\t_mi_error_message(EFAULT, \"corrupted free list entry of size %zub at %p: value 0x%zx\\n\",\n\t\t\tmi_page_block_size(page), block, (uintptr_t)next);\n\t\tnext \u003d NULL;\n\t}\n\treturn next;\n#else\n\tMI_UNUSED(page);\n\treturn mi_block_nextx(page, block, NULL);\n#endif\n}\n\n\nstatic inline void\nmi_block_set_next(const mi_page_t* page, mi_block_t* block, const mi_block_t* next)\n{\n#ifdef MI_ENCODE_FREELIST\n\tmi_block_set_nextx(page, block, next, page-\u003ekeys);\n#else\n\tMI_UNUSED(page);\n\tmi_block_set_nextx(page, block, next, NULL);\n#endif\n```",
      "range": {
        "startLine": 610,
        "startChar": 0,
        "endLine": 689,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "045beece_08605a1b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 720,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline void\nmi_commit_mask_create_empty(mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++)\n\t\tcm-\u003emask[i] \u003d 0;\n}\n\n\nstatic inline void\nmi_commit_mask_create_full(mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++)\n\t\tcm-\u003emask[i] \u003d ~((size_t)0);\n}\n\n\nstatic inline bool\nmi_commit_mask_is_empty(const mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++) {\n\t\tif (cm-\u003emask[i] !\u003d 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nstatic inline bool\nmi_commit_mask_is_full(const mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++) {\n\t\tif (cm-\u003emask[i] !\u003d ~((size_t)0))\n\t\t\treturn false;\n\t}\n\treturn true;\n```",
      "range": {
        "startLine": 697,
        "startChar": 0,
        "endLine": 720,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85966af1_bb751368",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 730,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_commit_mask_foreach(cm, idx, count) \\\n\tidx \u003d 0; \\\n\twhile ((count \u003d _mi_commit_mask_next_run(cm, \u0026idx)) \u003e 0) {\n\n```",
      "range": {
        "startLine": 727,
        "startChar": 0,
        "endLine": 730,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b052b1d_c319de34",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 734,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tidx +\u003d count; \\\n\t}\n```",
      "range": {
        "startLine": 732,
        "startChar": 0,
        "endLine": 734,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "27d1f6de_ca6b1814",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 757,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_memid_t\n_mi_memid_create(mi_memkind_t memkind)\n{\n\tmi_memid_t memid;\n\t_mi_memzero_var(memid);\n\tmemid.memkind \u003d memkind;\n\treturn memid;\n}\n\n\nstatic inline mi_memid_t\n_mi_memid_none(void)\n{\n\treturn _mi_memid_create(MI_MEM_NONE);\n}\n\n\nstatic inline mi_memid_t\n_mi_memid_create_os(bool committed, bool is_zero, bool is_large)\n{\n\tmi_memid_t memid \u003d _mi_memid_create(MI_MEM_OS);\n\tmemid.initially_committed \u003d committed;\n\tmemid.initially_zero \u003d is_zero;\n\tmemid.is_pinned \u003d is_large;\n\treturn memid;\n```",
      "range": {
        "startLine": 741,
        "startChar": 0,
        "endLine": 757,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ce77a64_5d30e5e3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 782,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline uintptr_t\n_mi_random_shuffle(uintptr_t x)\n{\n\tif (x \u003d\u003d 0) {\n\t\tx \u003d 17;\n\t} // ensure we don\u0027t get stuck in generating zeros\n#if (MI_INTPTR_SIZE \u003d\u003d 8)\n\t// by Sebastiano Vigna, see: \u003chttp://xoshiro.di.unimi.it/splitmix64.c\u003e\n\tx ^\u003d x \u003e\u003e 30;\n\tx *\u003d 0xbf58476d1ce4e5b9UL;\n\tx ^\u003d x \u003e\u003e 27;\n\tx *\u003d 0x94d049bb133111ebUL;\n\tx ^\u003d x \u003e\u003e 31;\n#elif (MI_INTPTR_SIZE \u003d\u003d 4)\n\t// by Chris Wellons, see: \u003chttps://nullprogram.com/blog/2018/07/31/\u003e\n\tx ^\u003d x \u003e\u003e 16;\n\tx *\u003d 0x7feb352dUL;\n\tx ^\u003d x \u003e\u003e 15;\n\tx *\u003d 0x846ca68bUL;\n\tx ^\u003d x \u003e\u003e 16;\n#endif\n\treturn x;\n```",
      "range": {
        "startLine": 765,
        "startChar": 0,
        "endLine": 782,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f4044bca_269aa068",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 789,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint _mi_os_numa_node_get(mi_os_tld_t* tld);\n```",
      "range": {
        "startLine": 789,
        "startChar": 0,
        "endLine": 789,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6420b50_c7def3cb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 802,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline int\n_mi_os_numa_node(mi_os_tld_t* tld)\n{\n\tif mi_likely (mi_atomic_load_relaxed(\u0026_mi_numa_node_count) \u003d\u003d 1)\n\t\treturn 0;\n\telse\n\t\treturn _mi_os_numa_node_get(tld);\n}\n\n\nstatic inline size_t\n_mi_os_numa_node_count(void)\n{\n\tconst size_t count \u003d mi_atomic_load_relaxed(\u0026_mi_numa_node_count);\n\tif mi_likely (count \u003e 0)\n\t\treturn count;\n\telse\n\t\treturn _mi_os_numa_node_count_get();\n}\n```",
      "range": {
        "startLine": 793,
        "startChar": 0,
        "endLine": 802,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "444c5012_b145df25",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 811,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003climits.h\u003e // LONG_MAX\n```",
      "range": {
        "startLine": 811,
        "startChar": 0,
        "endLine": 811,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91fde8f7_95091730",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 814,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline size_t\nmi_clz(uintptr_t x)\n{\n\tif (x \u003d\u003d 0)\n\t\treturn MI_INTPTR_BITS;\n```",
      "range": {
        "startLine": 813,
        "startChar": 0,
        "endLine": 814,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "71617727_f71c373c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 822,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\treturn __builtin_clzl(x);\n#else\n\treturn __builtin_clzll(x);\n#endif\n}\n\n\nstatic inline size_t\nmi_ctz(uintptr_t x)\n{\n\tif (x \u003d\u003d 0)\n\t\treturn MI_INTPTR_BITS;\n```",
      "range": {
        "startLine": 816,
        "startChar": 0,
        "endLine": 822,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b382fae3_59d3c28f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 826,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\treturn __builtin_ctzl(x);\n#else\n\treturn __builtin_ctzll(x);\n```",
      "range": {
        "startLine": 824,
        "startChar": 0,
        "endLine": 826,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a38a663f_c7563fe7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 833,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cintrin.h\u003e // BitScanReverse64\n#include \u003climits.h\u003e // LONG_MAX\n```",
      "range": {
        "startLine": 832,
        "startChar": 0,
        "endLine": 833,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9f561bfd_5ee3a7d2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 837,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline size_t\nmi_clz(uintptr_t x)\n{\n\tif (x \u003d\u003d 0)\n\t\treturn MI_INTPTR_BITS;\n\tunsigned long idx;\n```",
      "range": {
        "startLine": 835,
        "startChar": 0,
        "endLine": 837,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e95d3a6b_41776caf",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 847,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t_BitScanReverse(\u0026idx, x);\n#else\n\t_BitScanReverse64(\u0026idx, x);\n#endif\n\treturn (MI_INTPTR_BITS - 1) - idx;\n}\n\n\nstatic inline size_t\nmi_ctz(uintptr_t x)\n{\n\tif (x \u003d\u003d 0)\n\t\treturn MI_INTPTR_BITS;\n\tunsigned long idx;\n```",
      "range": {
        "startLine": 839,
        "startChar": 0,
        "endLine": 847,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a865026d_aa886b2f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 882,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t_BitScanForward(\u0026idx, x);\n#else\n\t_BitScanForward64(\u0026idx, x);\n#endif\n\treturn idx;\n}\n\n#else\n\n\nstatic inline size_t\nmi_ctz32(uint32_t x)\n{\n\t// de Bruijn multiplication, see \u003chttp://supertech.csail.mit.edu/papers/debruijn.pdf\u003e\n\tstatic const unsigned char debruijn[32] \u003d {0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17,\n\t\t4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};\n\tif (x \u003d\u003d 0)\n\t\treturn 32;\n\treturn debruijn[((x \u0026 -(int32_t)x) * 0x077CB531UL) \u003e\u003e 27];\n}\n\n\nstatic inline size_t\nmi_clz32(uint32_t x)\n{\n\t// de Bruijn multiplication, see \u003chttp://supertech.csail.mit.edu/papers/debruijn.pdf\u003e\n\tstatic const uint8_t debruijn[32] \u003d {31, 22, 30, 21, 18, 10, 29, 2, 20, 17, 15, 13, 9, 6, 28, 1,\n\t\t23, 19, 11, 3, 16, 14, 7, 24, 12, 4, 8, 25, 5, 26, 27, 0};\n\tif (x \u003d\u003d 0)\n\t\treturn 32;\n\tx |\u003d x \u003e\u003e 1;\n\tx |\u003d x \u003e\u003e 2;\n\tx |\u003d x \u003e\u003e 4;\n\tx |\u003d x \u003e\u003e 8;\n\tx |\u003d x \u003e\u003e 16;\n\treturn debruijn[(uint32_t)(x * 0x07C4ACDDUL) \u003e\u003e 27];\n}\n\n\nstatic inline size_t\nmi_clz(uintptr_t x)\n{\n\tif (x \u003d\u003d 0)\n\t\treturn MI_INTPTR_BITS;\n```",
      "range": {
        "startLine": 849,
        "startChar": 0,
        "endLine": 882,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08cdc796_e2a938fa",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 892,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\treturn mi_clz32((uint32_t)x);\n#else\n\tsize_t count \u003d mi_clz32((uint32_t)(x \u003e\u003e 32));\n\tif (count \u003c 32)\n\t\treturn count;\n\treturn 32 + mi_clz32((uint32_t)x);\n#endif\n}\n\n\nstatic inline size_t\nmi_ctz(uintptr_t x)\n{\n\tif (x \u003d\u003d 0)\n\t\treturn MI_INTPTR_BITS;\n```",
      "range": {
        "startLine": 884,
        "startChar": 0,
        "endLine": 892,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f292ce1c_4b95c34b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 898,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\treturn mi_ctz32((uint32_t)x);\n#else\n\tsize_t count \u003d mi_ctz32((uint32_t)x);\n\tif (count \u003c 32)\n\t\treturn count;\n\treturn 32 + mi_ctz32((uint32_t)(x \u003e\u003e 32));\n```",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04902470_43f7edbf",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 906,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_bsr(uintptr_t x)\n{\n\treturn x \u003d\u003d 0 ? MI_INTPTR_BITS : MI_INTPTR_BITS - 1 - mi_clz(x);\n```",
      "range": {
        "startLine": 905,
        "startChar": 0,
        "endLine": 906,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "351794e5_2658aaee",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 942,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline void\n_mi_memcpy(void* dst, const void* src, size_t n)\n{\n\tif (_mi_cpu_has_fsrm)\n\t\t__movsb((unsigned char*)dst, (const unsigned char*)src, n);\n\telse\n\t\tmemcpy(dst, src, n);\n}\n\n\nstatic inline void\n_mi_memzero(void* dst, size_t n)\n{\n\tif (_mi_cpu_has_fsrm)\n\t\t__stosb((unsigned char*)dst, 0, n);\n\telse\n\t\tmemset(dst, 0, n);\n}\n#else\n\n\nstatic inline void\n_mi_memcpy(void* dst, const void* src, size_t n)\n{\n\tmemcpy(dst, src, n);\n}\n\n\nstatic inline void\n_mi_memzero(void* dst, size_t n)\n{\n\tmemset(dst, 0, n);\n```",
      "range": {
        "startLine": 921,
        "startChar": 0,
        "endLine": 942,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5de67327_4b50a254",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 963,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline void\n_mi_memcpy_aligned(void* dst, const void* src, size_t n)\n{\n\tmi_assert_internal(\n\t\t((uintptr_t)dst % MI_INTPTR_SIZE \u003d\u003d 0) \u0026\u0026 ((uintptr_t)src % MI_INTPTR_SIZE \u003d\u003d 0));\n\tvoid* adst \u003d __builtin_assume_aligned(dst, MI_INTPTR_SIZE);\n\tconst void* asrc \u003d __builtin_assume_aligned(src, MI_INTPTR_SIZE);\n\t_mi_memcpy(adst, asrc, n);\n}\n\n\nstatic inline void\n_mi_memzero_aligned(void* dst, size_t n)\n{\n\tmi_assert_internal((uintptr_t)dst % MI_INTPTR_SIZE \u003d\u003d 0);\n\tvoid* adst \u003d __builtin_assume_aligned(dst, MI_INTPTR_SIZE);\n\t_mi_memzero(adst, n);\n```",
      "range": {
        "startLine": 953,
        "startChar": 0,
        "endLine": 963,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d4fd9327_1abddb54",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/internal.h",
        "patchSetId": 7
      },
      "lineNbr": 979,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline void\n_mi_memcpy_aligned(void* dst, const void* src, size_t n)\n{\n\tmi_assert_internal(\n\t\t((uintptr_t)dst % MI_INTPTR_SIZE \u003d\u003d 0) \u0026\u0026 ((uintptr_t)src % MI_INTPTR_SIZE \u003d\u003d 0));\n\t_mi_memcpy(dst, src, n);\n}\n\n\nstatic inline void\n_mi_memzero_aligned(void* dst, size_t n)\n{\n\tmi_assert_internal((uintptr_t)dst % MI_INTPTR_SIZE \u003d\u003d 0);\n\t_mi_memzero(dst, n);\n}\n#endif\n\n\n#endif\n```",
      "range": {
        "startLine": 967,
        "startChar": 0,
        "endLine": 979,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "213be0d4_6172e2ce",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 30,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tsize_t page_size; // 4KiB\n\tsize_t large_page_size; // 2MiB\n\tsize_t alloc_granularity; // smallest allocation size (on Windows 64KiB)\n\tbool has_overcommit; // can we reserve more memory than can be actually committed?\n\tbool must_free_whole; // must allocated blocks be freed as a whole (false for mmap, true for\n\t\t\t\t\t\t  // VirtualAlloc)\n\tbool has_virtual_reserve; // supports virtual address space reservation? (if true we can reserve\n\t\t\t\t\t\t\t  // virtual address space without using commit or physical memory)\n```",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 30,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ec4b250e_ec8b85b1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 34,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_prim_mem_init(mi_os_mem_config_t* config);\n```",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 34,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "48478b75_e0475926",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 38,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint _mi_prim_free(void* addr, size_t size);\n\n```",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 38,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b834bf2e_429e224b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 41,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// If `commit` is false, the virtual memory range only needs to be reserved (with no access)\n```",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96f752d5_d76e1523",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint _mi_prim_alloc(size_t size, size_t try_alignment, bool commit, bool allow_large, bool* is_large,\n\tbool* is_zero, void** addr);\n```",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 46,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3272854a_c5704986",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 70,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint _mi_prim_alloc_huge_os_pages(void* hint_addr, size_t size, int numa_node, bool* is_zero,\n\tvoid** addr);\n```",
      "range": {
        "startLine": 70,
        "startChar": 0,
        "endLine": 70,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98c4d4df_483708f4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 90,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_msecs_t elapsed;\n\tmi_msecs_t utime;\n\tmi_msecs_t stime;\n\tsize_t current_rss;\n\tsize_t peak_rss;\n\tsize_t current_commit;\n\tsize_t peak_commit;\n\tsize_t page_faults;\n```",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 90,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e6f7f38_aa36f5f1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 97,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_prim_out_stderr(const char* msg);\n```",
      "range": {
        "startLine": 97,
        "startChar": 0,
        "endLine": 97,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ee31d28_7dce3714",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 108,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Called on the first thread start, and should ensure `_mi_thread_done` is called on thread\n// termination.\n```",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 108,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e7563e5_a2c0cc53",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 111,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Called on process exit and may take action to clean up resources associated with the thread auto\n// done.\n```",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 111,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5590c890_b0fe3e2c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 120,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n//\n```",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 120,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d66a7ff4_51e10261",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 130,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern mi_decl_thread mi_heap_t* _mi_heap_default; // default heap to allocate from\nextern bool _mi_process_is_initialized; // has mi_process_init been called?\n```",
      "range": {
        "startLine": 129,
        "startChar": 0,
        "endLine": 130,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a40a60d_93f69ab9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 140,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline mi_threadid_t\n_mi_prim_thread_id(void) mi_attr_noexcept\n{\n\t// Windows: works on Intel and ARM in both 32- and 64-bit\n\treturn (uintptr_t)NtCurrentTeb();\n```",
      "range": {
        "startLine": 138,
        "startChar": 0,
        "endLine": 140,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5b167c5e_74358684",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 179,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#elif defined(__GNUC__) \\\n\t\u0026\u0026 ((defined(__GLIBC__) \\\n\t\t\t\u0026\u0026 (defined(__x86_64__) || defined(__i386__) || defined(__arm__) \\\n\t\t\t\t|| defined(__aarch64__))) \\\n\t\t|| (defined(__APPLE__) \u0026\u0026 (defined(__x86_64__) || defined(__aarch64__))) \\\n\t\t|| (defined(__BIONIC__) \\\n\t\t\t\u0026\u0026 (defined(__x86_64__) || defined(__i386__) || defined(__arm__) \\\n\t\t\t\t|| defined(__aarch64__))) \\\n\t\t|| (defined(__FreeBSD__) \\\n\t\t\t\u0026\u0026 (defined(__x86_64__) || defined(__i386__) || defined(__aarch64__))) \\\n\t\t|| (defined(__OpenBSD__) \\\n\t\t\t\u0026\u0026 (defined(__x86_64__) || defined(__i386__) || defined(__aarch64__))))\n\n\nstatic inline void*\nmi_prim_tls_slot(size_t slot) mi_attr_noexcept\n{\n\tvoid* res;\n\tconst size_t ofs \u003d (slot * sizeof(void*));\n#if defined(__i386__)\n\t__asm__(\"movl %%gs:%1, %0\" : \"\u003dr\"(res) : \"m\"(*((void**)ofs)) :); // x86 32-bit always uses GS\n#elif defined(__APPLE__) \u0026\u0026 defined(__x86_64__)\n\t__asm__(\"movq %%gs:%1, %0\" : \"\u003dr\"(res) : \"m\"(*((void**)ofs)) :); // x86_64 macOSX uses GS\n#elif defined(__x86_64__) \u0026\u0026 (MI_INTPTR_SIZE \u003d\u003d 4)\n\t__asm__(\"movl %%fs:%1, %0\" : \"\u003dr\"(res) : \"m\"(*((void**)ofs)) :); // x32 ABI\n#elif defined(__x86_64__)\n\t__asm__(\"movq %%fs:%1, %0\" : \"\u003dr\"(res) : \"m\"(*((void**)ofs)) :); // x86_64 Linux, BSD uses FS\n#elif defined(__arm__)\n\tvoid** tcb;\n\tMI_UNUSED(ofs);\n\t__asm__ volatile(\"mrc p15, 0, %0, c13, c0, 3\\nbic %0, %0, #3\" : \"\u003dr\"(tcb));\n\tres \u003d tcb[slot];\n#elif defined(__aarch64__)\n\tvoid** tcb;\n\tMI_UNUSED(ofs);\n#if defined(__APPLE__) // M1, issue #343\n\t__asm__ volatile(\"mrs %0, tpidrro_el0\\nbic %0, %0, #7\" : \"\u003dr\"(tcb));\n#else\n\t__asm__ volatile(\"mrs %0, tpidr_el0\" : \"\u003dr\"(tcb));\n#endif\n\tres \u003d tcb[slot];\n#endif\n\treturn res;\n```",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 179,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c0fe62b7_51070fdd",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 220,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline void\nmi_prim_tls_slot_set(size_t slot, void* value) mi_attr_noexcept\n{\n\tconst size_t ofs \u003d (slot * sizeof(void*));\n#if defined(__i386__)\n\t__asm__(\"movl %1,%%gs:%0\" : \"\u003dm\"(*((void**)ofs)) : \"rn\"(value) :); // 32-bit always uses GS\n#elif defined(__APPLE__) \u0026\u0026 defined(__x86_64__)\n\t__asm__(\"movq %1,%%gs:%0\" : \"\u003dm\"(*((void**)ofs)) : \"rn\"(value) :); // x86_64 macOS uses GS\n#elif defined(__x86_64__) \u0026\u0026 (MI_INTPTR_SIZE \u003d\u003d 4)\n\t__asm__(\"movl %1,%%fs:%0\" : \"\u003dm\"(*((void**)ofs)) : \"rn\"(value) :); // x32 ABI\n#elif defined(__x86_64__)\n\t__asm__(\"movq %1,%%fs:%0\" : \"\u003dm\"(*((void**)ofs)) : \"rn\"(value) :); // x86_64 Linux, BSD uses FS\n#elif defined(__arm__)\n\tvoid** tcb;\n\tMI_UNUSED(ofs);\n\t__asm__ volatile(\"mrc p15, 0, %0, c13, c0, 3\\nbic %0, %0, #3\" : \"\u003dr\"(tcb));\n\ttcb[slot] \u003d value;\n#elif defined(__aarch64__)\n\tvoid** tcb;\n\tMI_UNUSED(ofs);\n#if defined(__APPLE__) // M1, issue #343\n\t__asm__ volatile(\"mrs %0, tpidrro_el0\\nbic %0, %0, #7\" : \"\u003dr\"(tcb));\n```",
      "range": {
        "startLine": 183,
        "startChar": 0,
        "endLine": 220,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c632e499_c3a06d11",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 229,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t__asm__ volatile(\"mrs %0, tpidr_el0\" : \"\u003dr\"(tcb));\n#endif\n\ttcb[slot] \u003d value;\n#endif\n}\n\n\nstatic inline mi_threadid_t\n_mi_prim_thread_id(void) mi_attr_noexcept\n{\n#if defined(__BIONIC__)\n\t// issue #384, #495: on the Bionic libc (Android), slot 1 is the thread id\n\t// see:\n\t// https://github.com/aosp-mirror/platform_bionic/blob/c44b1d0676ded732df4b3b21c5f798eacae93228/libc/platform/bionic/tls_defines.h#L86\n\treturn (uintptr_t)mi_prim_tls_slot(1);\n#else\n\t// in all our other targets, slot 0 is the thread id\n\t// glibc: https://sourceware.org/git/?p\u003dglibc.git;a\u003dblob_plain;f\u003dsysdeps/x86_64/nptl/tls.h\n\t// apple: https://github.com/apple/darwin-xnu/blob/main/libsyscall/os/tsd.h#L36\n\treturn (uintptr_t)mi_prim_tls_slot(0);\n#endif\n}\n\n#else\n\n// otherwise use portable C, taking the address of a thread local variable (this is still very fast\n// on most platforms).\nstatic inline mi_threadid_t\n_mi_prim_thread_id(void) mi_attr_noexcept\n{\n\treturn (uintptr_t)\u0026_mi_heap_default;\n}\n\n#endif\n```",
      "range": {
        "startLine": 222,
        "startChar": 0,
        "endLine": 229,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f50d0f5_f861e7f6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 244,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t   loader itself calls `malloc` even before the modules are initialized.\n```",
      "range": {
        "startLine": 244,
        "startChar": 0,
        "endLine": 244,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3e0cd9c6_f29619c4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 256,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TLS_SLOT 89 // seems unused?\n// #define MI_TLS_RECURSE_GUARD 1\n// other possible unused ones are 9, 29, __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY4 (94),\n// __PTK_FRAMEWORK_GC_KEY9 (112) and __PTK_FRAMEWORK_OLDGC_KEY9 (89) see\n// \u003chttps://github.com/rweichler/substrate/blob/master/include/pthread_machdep.h\u003e\n```",
      "range": {
        "startLine": 253,
        "startChar": 0,
        "endLine": 256,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "859f3d4f_4c377b56",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// use end bytes of a name; goes wrong if anyone uses names \u003e 23 characters (ptrhread specifies 16)\n// see \u003chttps://github.com/openbsd/src/blob/master/lib/libc/include/thread_private.h#L371\u003e\n#define MI_TLS_PTHREAD_SLOT_OFS (6 * sizeof(int) + 4 * sizeof(void*) + 24)\n// #elif defined(__DragonFly__)\n// #warning \"mimalloc is not working correctly on DragonFly yet.\"\n// #define MI_TLS_PTHREAD_SLOT_OFS   (4 + 1*sizeof(void*))  // offset `uniqueid` (also used by gdb?)\n// \u003chttps://github.com/DragonFlyBSD/DragonFlyBSD/blob/master/lib/libthread_xu/thread/thr_private.h#L458\u003e\n```",
      "range": {
        "startLine": 258,
        "startChar": 0,
        "endLine": 263,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "31d2267f_0824cfe7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 266,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// See issue #381\n#define MI_TLS_PTHREAD\n```",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f450e899_e05527b2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 281,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic inline mi_heap_t*\nmi_prim_get_default_heap(void)\n{\n\tmi_heap_t* heap \u003d (mi_heap_t*)mi_prim_tls_slot(MI_TLS_SLOT);\n\tif mi_unlikely (heap \u003d\u003d NULL) {\n#ifdef __GNUC__\n\t\t__asm(\"\"); // prevent conditional load of the address of _mi_heap_empty\n#endif\n\t\theap \u003d (mi_heap_t*)\u0026_mi_heap_empty;\n\t}\n\treturn heap;\n```",
      "range": {
        "startLine": 273,
        "startChar": 0,
        "endLine": 281,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "28b6e267_64b29913",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 299,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic inline mi_heap_t**\nmi_prim_tls_pthread_heap_slot(void)\n{\n\tpthread_t self \u003d pthread_self();\n#if defined(__DragonFly__)\n\tif (self \u003d\u003d NULL)\n\t\treturn NULL;\n#endif\n\treturn (mi_heap_t**)((uint8_t*)self + MI_TLS_PTHREAD_SLOT_OFS);\n}\n\n\nstatic inline mi_heap_t*\nmi_prim_get_default_heap(void)\n{\n\tmi_heap_t** pheap \u003d mi_prim_tls_pthread_heap_slot();\n\tif mi_unlikely (pheap \u003d\u003d NULL)\n\t\treturn _mi_heap_main_get();\n\tmi_heap_t* heap \u003d *pheap;\n\tif mi_unlikely (heap \u003d\u003d NULL)\n\t\treturn (mi_heap_t*)\u0026_mi_heap_empty;\n\treturn heap;\n```",
      "range": {
        "startLine": 286,
        "startChar": 0,
        "endLine": 299,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c06045e6_1e8639b4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 307,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic inline mi_heap_t*\nmi_prim_get_default_heap(void)\n{\n\tmi_heap_t* heap \u003d (mi_unlikely(_mi_heap_default_key \u003d\u003d (pthread_key_t)(-1))\n\t\t\t? _mi_heap_main_get()\n\t\t\t: (mi_heap_t*)pthread_getspecific(_mi_heap_default_key));\n\treturn mi_unlikely(heap \u003d\u003d NULL) ? (mi_heap_t*)\u0026_mi_heap_empty : heap;\n```",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 307,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "39631fa2_0dfbacc7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/prim.h",
        "patchSetId": 7
      },
      "lineNbr": 323,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic inline mi_heap_t*\nmi_prim_get_default_heap(void)\n{\n#if defined(MI_TLS_RECURSE_GUARD)\n\tif (mi_unlikely(!_mi_process_is_initialized))\n\t\treturn _mi_heap_main_get();\n#endif\n\treturn _mi_heap_default;\n}\n\n#endif // mi_prim_get_default_heap()\n\n\n#endif // MIMALLOC_PRIM_H\n```",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 323,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "523d59a8_54806251",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 24,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nUse `_mi_block_size_of(void* p)` to get the full block size that was allocated (including padding\netc). The `zero` parameter is `true` if the allocated block is zero initialized.\n```",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d703b280_6582497d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 35,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nThe corresponding `mi_track_free` still uses the block start pointer and original size\n(corresponding to the `mi_track_malloc`). The `mi_track_resize` is currently unused but could be\ncalled on reallocations within a block. `mi_track_init` is called at program start.\n```",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 35,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e77d321_d1afc2cd",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 37,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nThe following macros are for tools like asan and valgrind to track whether memory is\n```",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 37,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d7f6f85d_538c7236",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 51,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TRACK_ENABLED 1\n#define MI_TRACK_HEAP_DESTROY 1 // track free of individual blocks on heap_destroy\n#define MI_TRACK_TOOL \"valgrind\"\n```",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 51,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "342cf1d8_7ed03fad",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 52,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \u003cvalgrind/memcheck.h\u003e\n```",
      "range": {
        "startLine": 52,
        "startChar": 0,
        "endLine": 52,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4f0dbcf3_efaa5a5a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 54,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 54,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "828acb04_45c2a9b1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 61,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_malloc_size(p, reqsize, size, zero) \\\n\tVALGRIND_MALLOCLIKE_BLOCK(p, size, MI_PADDING_SIZE /*red zone*/, zero)\n#define mi_track_free_size(p, _size) VALGRIND_FREELIKE_BLOCK(p, MI_PADDING_SIZE /*red zone*/)\n#define mi_track_resize(p, oldsize, newsize) \\\n\tVALGRIND_RESIZEINPLACE_BLOCK(p, oldsize, newsize, MI_PADDING_SIZE /*red zone*/)\n#define mi_track_mem_defined(p, size) VALGRIND_MAKE_MEM_DEFINED(p, size)\n#define mi_track_mem_undefined(p, size) VALGRIND_MAKE_MEM_UNDEFINED(p, size)\n#define mi_track_mem_noaccess(p, size) VALGRIND_MAKE_MEM_NOACCESS(p, size)\n```",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 61,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07698bdb_16d7d890",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 66,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TRACK_ENABLED 1\n```",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 66,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "39956983_3e61283f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TRACK_TOOL \"asan\"\n```",
      "range": {
        "startLine": 68,
        "startChar": 0,
        "endLine": 68,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a81976ca_59be931a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 76,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_malloc_size(p, reqsize, size, zero) ASAN_UNPOISON_MEMORY_REGION(p, size)\n#define mi_track_free_size(p, size) ASAN_POISON_MEMORY_REGION(p, size)\n#define mi_track_mem_defined(p, size) ASAN_UNPOISON_MEMORY_REGION(p, size)\n#define mi_track_mem_undefined(p, size) ASAN_UNPOISON_MEMORY_REGION(p, size)\n#define mi_track_mem_noaccess(p, size) ASAN_POISON_MEMORY_REGION(p, size)\n```",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 76,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "008a1bc4_d596ae69",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 81,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TRACK_ENABLED 1\n```",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9c1dca6_65d0e473",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 83,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TRACK_TOOL \"ETW\"\n```",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 83,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "71ba7e21_12390fd0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 85,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"../src/prim/windows/etw.h\"\n```",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 85,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a74c7ca3_002f098a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 87,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 87,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fe84c9bd_b9a38bae",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 91,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_init() EventRegistermicrosoft_windows_mimalloc();\n#define mi_track_malloc_size(p, reqsize, size, zero) EventWriteETW_MI_ALLOC((UINT64)(p), size)\n#define mi_track_free_size(p, size) EventWriteETW_MI_FREE((UINT64)(p), size)\n```",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 91,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b00f4be5_533155a4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 98,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TRACK_ENABLED 0\n#define MI_TRACK_HEAP_DESTROY 0\n#define MI_TRACK_TOOL \"none\"\n```",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 98,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a3c8cb72_e0a4ad09",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 101,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_malloc_size(p, reqsize, size, zero)\n#define mi_track_free_size(p, _size)\n```",
      "range": {
        "startLine": 100,
        "startChar": 0,
        "endLine": 101,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d20e19de_d4c9b7c1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 109,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_resize(p, oldsize, newsize) \\\n\tmi_track_free_size(p, oldsize); \\\n\tmi_track_malloc(p, newsize, false)\n```",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 109,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5f16185_2eaf82d3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 113,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_align(p, alignedp, offset, size) mi_track_mem_noaccess(p, offset)\n```",
      "range": {
        "startLine": 113,
        "startChar": 0,
        "endLine": 113,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d37dd3d1_4fef7c91",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 121,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_mem_defined(p, size)\n```",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 121,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c840c225_dc284e51",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 125,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_mem_undefined(p, size)\n```",
      "range": {
        "startLine": 125,
        "startChar": 0,
        "endLine": 125,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25500e5a_76dd1cb9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 129,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_mem_noaccess(p, size)\n```",
      "range": {
        "startLine": 129,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5555dc20_69061f08",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 138,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_malloc(p, reqsize, zero) \\\n\tif ((p) !\u003d NULL) { \\\n\t\tmi_assert_internal(mi_usable_size(p) \u003d\u003d (reqsize)); \\\n\t\tmi_track_malloc_size(p, reqsize, reqsize, zero); \\\n\t}\n```",
      "range": {
        "startLine": 134,
        "startChar": 0,
        "endLine": 138,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "03de5306_9c8d0b89",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/track.h",
        "patchSetId": 7
      },
      "lineNbr": 144,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_track_malloc(p, reqsize, zero) \\\n\tif ((p) !\u003d NULL) { \\\n\t\tmi_assert_internal(mi_usable_size(p) \u003e\u003d (reqsize)); \\\n\t\tmi_track_malloc_size(p, reqsize, mi_usable_size(p), zero); \\\n\t}\n```",
      "range": {
        "startLine": 140,
        "startChar": 0,
        "endLine": 144,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "455162fd_8c00e40d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 24,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \"mimalloc/atomic.h\" // _Atomic\n#include \u003cstddef.h\u003e // ptrdiff_t\n#include \u003cstdint.h\u003e // uintptr_t, uint16_t, etc\n```",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 24,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2669ede7_ec1e6314",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 27,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#pragma warning(disable : 4214) // bitfield is not int\n```",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 27,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b15de2b_0dedef86",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 33,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_ALIGN_SIZE 16 // sizeof(max_align_t)\n```",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0062647_32cb2a08",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Define MI_STAT as 1 to maintain statistics; set it to 2 to have detailed statistics (but costs\n// some performance). #define MI_STAT 1\n```",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 49,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0092b5c_5fdc7cc8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// #define MI_SECURE 3  // encode free lists (detect corrupted free list (buffer overflow), and\n// invalid pointer free) #define MI_SECURE 4  // checks for double free. (may be more expensive)\n```",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 55,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4392e875_70058539",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 64,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// #define MI_DEBUG 1  // basic assertion checks and statistics, check double free, corrupted free\n// list, and invalid pointer free. #define MI_DEBUG 2  // + internal assertion checks #define\n// MI_DEBUG 3  // + extensive internal invariant checking (cmake -DMI_DEBUG_FULL\u003dON)\n```",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 64,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5eeb6dfe_bab1f572",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 80,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if !defined(MI_PADDING) \\\n\t\u0026\u0026 (MI_SECURE \u003e\u003d 3 || MI_DEBUG \u003e\u003d 1 || (MI_TRACK_VALGRIND || MI_TRACK_ASAN || MI_TRACK_ETW))\n#define MI_PADDING 1\n```",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 80,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af889eed_476456c0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 84,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if !defined(MI_PADDING_CHECK) \u0026\u0026 MI_PADDING \u0026\u0026 (MI_SECURE \u003e\u003d 3 || MI_DEBUG \u003e\u003d 1)\n```",
      "range": {
        "startLine": 84,
        "startChar": 0,
        "endLine": 84,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1258cd60_05464579",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_SECURE \u003e\u003d 3 || MI_DEBUG \u003e\u003d 1)\n#define MI_ENCODE_FREELIST 1\n```",
      "range": {
        "startLine": 91,
        "startChar": 0,
        "endLine": 92,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "697a4cb5_20921a7e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 120,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_INTPTR_SHIFT (4) // assume 128-bit  (as on arm CHERI for example)\n```",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 120,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c43aed4_6d18a5af",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 122,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_INTPTR_SHIFT (3)\n```",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 122,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b43b9f9_60a56846",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 124,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_INTPTR_SHIFT (2)\n```",
      "range": {
        "startLine": 124,
        "startChar": 0,
        "endLine": 124,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "86c560da_84c7715d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SIZE_SHIFT (3)\ntypedef int64_t mi_ssize_t;\n```",
      "range": {
        "startLine": 130,
        "startChar": 0,
        "endLine": 131,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "73c8e96d_953929c2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 134,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SIZE_SHIFT (2)\ntypedef int32_t mi_ssize_t;\n```",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 134,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eca00c67_0ec1afb0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 155,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (SIZE_MAX / 2) \u003e LONG_MAX\n#define MI_ZU(x) x##ULL\n#define MI_ZI(x) x##LL\n#else\n#define MI_ZU(x) x##UL\n#define MI_ZI(x) x##L\n#endif\n\n#define MI_INTPTR_SIZE (1 \u003c\u003c MI_INTPTR_SHIFT)\n#define MI_INTPTR_BITS (MI_INTPTR_SIZE * 8)\n\n#define MI_SIZE_SIZE (1 \u003c\u003c MI_SIZE_SHIFT)\n#define MI_SIZE_BITS (MI_SIZE_SIZE * 8)\n\n#define MI_KiB (MI_ZU(1024))\n#define MI_MiB (MI_KiB * MI_KiB)\n#define MI_GiB (MI_MiB * MI_KiB)\n```",
      "range": {
        "startLine": 139,
        "startChar": 0,
        "endLine": 155,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e3f1a320_dc94da3e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 164,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SEGMENT_SLICE_SHIFT (13 + MI_INTPTR_SHIFT) // 64KiB  (32KiB on 32-bit)\n```",
      "range": {
        "startLine": 164,
        "startChar": 0,
        "endLine": 164,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "62f35fe0_06c9f2f9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 173,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SEGMENT_SHIFT (9 + MI_SEGMENT_SLICE_SHIFT) // 32MiB\n#else\n#define MI_SEGMENT_SHIFT (7 + MI_SEGMENT_SLICE_SHIFT) // 4MiB on 32-bit\n#endif\n\n#define MI_SMALL_PAGE_SHIFT (MI_SEGMENT_SLICE_SHIFT) // 64KiB\n#define MI_MEDIUM_PAGE_SHIFT (3 + MI_SMALL_PAGE_SHIFT) // 512KiB\n```",
      "range": {
        "startLine": 167,
        "startChar": 0,
        "endLine": 173,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "051a40fb_fe02ecd7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 190,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SEGMENT_SIZE (MI_ZU(1) \u003c\u003c MI_SEGMENT_SHIFT)\n#define MI_SEGMENT_ALIGN MI_SEGMENT_SIZE\n#define MI_SEGMENT_MASK ((uintptr_t)(MI_SEGMENT_ALIGN - 1))\n#define MI_SEGMENT_SLICE_SIZE (MI_ZU(1) \u003c\u003c MI_SEGMENT_SLICE_SHIFT)\n#define MI_SLICES_PER_SEGMENT (MI_SEGMENT_SIZE / MI_SEGMENT_SLICE_SIZE) // 1024\n\n#define MI_SMALL_PAGE_SIZE (MI_ZU(1) \u003c\u003c MI_SMALL_PAGE_SHIFT)\n#define MI_MEDIUM_PAGE_SIZE (MI_ZU(1) \u003c\u003c MI_MEDIUM_PAGE_SHIFT)\n\n#define MI_SMALL_OBJ_SIZE_MAX (MI_SMALL_PAGE_SIZE / 4) // 8KiB on 64-bit\n#define MI_MEDIUM_OBJ_SIZE_MAX (MI_MEDIUM_PAGE_SIZE / 4) // 128KiB on 64-bit\n#define MI_MEDIUM_OBJ_WSIZE_MAX (MI_MEDIUM_OBJ_SIZE_MAX / MI_INTPTR_SIZE)\n#define MI_LARGE_OBJ_SIZE_MAX (MI_SEGMENT_SIZE / 2) // 32MiB on 64-bit\n#define MI_LARGE_OBJ_WSIZE_MAX (MI_LARGE_OBJ_SIZE_MAX / MI_INTPTR_SIZE)\n```",
      "range": {
        "startLine": 177,
        "startChar": 0,
        "endLine": 190,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ae8c338b_59d86e09",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 193,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_BIN_HUGE (73U)\n```",
      "range": {
        "startLine": 193,
        "startChar": 0,
        "endLine": 193,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f353c8f2_fd9afb24",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 200,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_SLICE_OFFSET ((MI_ALIGNMENT_MAX / MI_SEGMENT_SLICE_SIZE) - 1)\n```",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 200,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bab942e2_608a064a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 203,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_HUGE_BLOCK_SIZE ((uint32_t)(2 * MI_GiB))\n```",
      "range": {
        "startLine": 203,
        "startChar": 0,
        "endLine": 203,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25c6c78e_7862b670",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 206,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_ALIGN_GUARANTEE (8 * MI_MAX_ALIGN_SIZE)\n```",
      "range": {
        "startLine": 206,
        "startChar": 0,
        "endLine": 206,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a930ef29_3b90f7d0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 209,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_ALIGNMENT_MAX (MI_SEGMENT_SIZE \u003e\u003e 1)\n```",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 209,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dd740665_5431f522",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 218,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef uintptr_t mi_encoded_t;\n```",
      "range": {
        "startLine": 218,
        "startChar": 0,
        "endLine": 218,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7cb4047d_03e3a4e2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 221,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef size_t mi_threadid_t;\n```",
      "range": {
        "startLine": 221,
        "startChar": 0,
        "endLine": 221,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd825775_58de2968",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 225,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_encoded_t next;\n```",
      "range": {
        "startLine": 225,
        "startChar": 0,
        "endLine": 225,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81a0f9ad_5cc1a779",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 234,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tMI_USE_DELAYED_FREE \u003d 0, // push on the owning heap thread delayed list\n\tMI_DELAYED_FREEING \u003d 1, // temporary: another thread is accessing the owning heap\n\tMI_NO_DELAYED_FREE \u003d 2, // optimize: push on page local thread free queue if another block is\n\t\t\t\t\t\t\t// already in the heap thread delayed free list\n\tMI_NEVER_DELAYED_FREE \u003d 3 // sticky, only resets on page reclaim\n```",
      "range": {
        "startLine": 231,
        "startChar": 0,
        "endLine": 234,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "364de69c_0efeffae",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 246,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tuint8_t full_aligned;\n\tstruct {\n\t\tuint8_t in_full : 1;\n\t\tuint8_t has_aligned : 1;\n\t} x;\n```",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 246,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b1a7c42b_ec06a45a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 255,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tuint16_t full_aligned;\n\tstruct {\n\t\tuint8_t in_full;\n\t\tuint8_t has_aligned;\n\t} x;\n```",
      "range": {
        "startLine": 251,
        "startChar": 0,
        "endLine": 255,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "020448fd_d3a52cf4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 327,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// \"owned\" by the segment\n\tuint32_t slice_count; // slices in this page (0 if not a page)\n\tuint32_t slice_offset; // distance from the actual page data slice (0 if a page)\n\tuint8_t is_committed : 1; // `true` if the page virtual memory is committed\n\tuint8_t is_zero_init : 1; // `true` if the page was initially zero initialized\n\n\t// layout like this to optimize access in `mi_malloc` and `mi_free`\n\tuint16_t\n\t\tcapacity; // number of blocks committed, must be the first field, see `segment.c:page_clear`\n\tuint16_t reserved; // number of blocks reserved in memory\n\tmi_page_flags_t flags; // `in_full` and `has_aligned` flags (8 bits)\n\tuint8_t free_is_zero : 1; // `true` if the blocks in the free list are zero initialized\n\tuint8_t retire_expire : 7; // expiration count for retired blocks\n\n\tmi_block_t* free; // list of available free blocks (`malloc` allocates from this list)\n\tuint32_t used; // number of blocks in use (including blocks in `local_free` and `thread_free`)\n\tuint32_t xblock_size; // size available in each block (always `\u003e0`)\n\tmi_block_t* local_free; // list of deferred free blocks by this thread (migrates to `free`)\n\n#if (MI_ENCODE_FREELIST || MI_PADDING)\n\tuintptr_t keys[2]; // two random keys to encode the free lists (see `_mi_block_next`) or padding\n\t\t\t\t\t   // canary\n#endif\n\n\t_Atomic(mi_thread_free_t) xthread_free; // list of deferred free blocks freed by other threads\n\t_Atomic(uintptr_t) xheap;\n\n\tstruct mi_page_s* next; // next page owned by this thread with the same `block_size`\n\tstruct mi_page_s* prev; // previous page owned by this thread with the same `block_size`\n\n// 64-bit 9 words, 32-bit 12 words, (+2 for secure)\n#if MI_INTPTR_SIZE \u003d\u003d 8\n\tuintptr_t padding[1];\n#endif\n```",
      "range": {
        "startLine": 296,
        "startChar": 0,
        "endLine": 327,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "445b31d1_4deb981e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 331,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 331,
        "startChar": 0,
        "endLine": 331,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "67b4aa3f_54cb3472",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 340,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tMI_PAGE_SMALL, // small blocks go into 64KiB pages inside a segment\n\tMI_PAGE_MEDIUM, // medium blocks go into medium pages inside a segment\n\tMI_PAGE_LARGE, // larger blocks go into a page of just one block\n\tMI_PAGE_HUGE, // huge blocks (\u003e 16 MiB) are put into a single page in a single segment.\n```",
      "range": {
        "startLine": 337,
        "startChar": 0,
        "endLine": 340,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b5e8f7f3_5f71ee6f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 345,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tMI_SEGMENT_NORMAL, // MI_SEGMENT_SIZE size with pages inside.\n\tMI_SEGMENT_HUGE, // \u003e MI_LARGE_SIZE_MAX segment with just one huge page inside.\n```",
      "range": {
        "startLine": 344,
        "startChar": 0,
        "endLine": 345,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0bec4241_820595c5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 364,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MINIMAL_COMMIT_SIZE (1 * MI_SEGMENT_SLICE_SIZE)\n#define MI_COMMIT_SIZE (MI_SEGMENT_SLICE_SIZE) // 64KiB\n#define MI_COMMIT_MASK_BITS (MI_SEGMENT_SIZE / MI_COMMIT_SIZE)\n#define MI_COMMIT_MASK_FIELD_BITS MI_SIZE_BITS\n#define MI_COMMIT_MASK_FIELD_COUNT (MI_COMMIT_MASK_BITS / MI_COMMIT_MASK_FIELD_BITS)\n```",
      "range": {
        "startLine": 360,
        "startChar": 0,
        "endLine": 364,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca7f2f04_9e04ca43",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 371,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tsize_t mask[MI_COMMIT_MASK_FIELD_COUNT];\n```",
      "range": {
        "startLine": 371,
        "startChar": 0,
        "endLine": 371,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8964bc27_7b0087b7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 378,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\ntypedef mi_page_t mi_slice_t;\ntypedef int64_t mi_msecs_t;\n\n\n// Memory can reside in arena\u0027s, direct OS allocated, or statically allocated. The memid keeps track\n// of this.\n```",
      "range": {
        "startLine": 374,
        "startChar": 0,
        "endLine": 378,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8cf0fb49_4dd0107e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 386,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tMI_MEM_NONE, // not allocated\n\tMI_MEM_EXTERNAL, // not owned by mimalloc but provided externally (via `mi_manage_os_memory` for\n\t\t\t\t\t // example)\n\tMI_MEM_STATIC, // allocated in a static area and should not be freed (for arena meta data for\n\t\t\t\t   // example)\n\tMI_MEM_OS, // allocated from the OS\n\tMI_MEM_OS_HUGE, // allocated as huge os pages\n\tMI_MEM_OS_REMAP, // allocated in a remapable area (i.e. using `mremap`)\n\tMI_MEM_ARENA // allocated from an arena (the usual case)\n```",
      "range": {
        "startLine": 380,
        "startChar": 0,
        "endLine": 386,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7a90a15_00c9c2b2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 390,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic inline bool\nmi_memkind_is_os(mi_memkind_t memkind)\n{\n\treturn memkind \u003e\u003d MI_MEM_OS \u0026\u0026 memkind \u003c\u003d MI_MEM_OS_REMAP;\n```",
      "range": {
        "startLine": 389,
        "startChar": 0,
        "endLine": 390,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b0156a2_08a4926d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 395,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tvoid* base; // actual base address of the block (used for offset aligned allocations)\n\tsize_t alignment; // alignment at allocation\n```",
      "range": {
        "startLine": 394,
        "startChar": 0,
        "endLine": 395,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8675cd48_d03d1322",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 401,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tsize_t block_index; // index in the arena\n\tmi_arena_id_t id; // arena id (\u003e\u003d 1)\n\tbool is_exclusive; // the arena can only be used for specific arena allocations\n```",
      "range": {
        "startLine": 399,
        "startChar": 0,
        "endLine": 401,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "62f94154_bb2c016b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 412,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tunion {\n\t\tmi_memid_os_info_t os; // only used for MI_MEM_OS\n\t\tmi_memid_arena_info_t arena; // only used for MI_MEM_ARENA\n\t} mem;\n\tbool is_pinned; // `true` if we cannot decommit/reset/protect in this memory (e.g. when\n\t\t\t\t\t// allocated using large OS pages)\n\tbool initially_committed; // `true` if the memory was originally allocated as committed\n\tbool initially_zero; // `true` if the memory was originally zero initialized\n\tmi_memkind_t memkind;\n```",
      "range": {
        "startLine": 405,
        "startChar": 0,
        "endLine": 412,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c81bcca_8132c996",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 449,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// constant fields\n\tmi_memid_t memid; // memory id for arena allocation\n\tbool allow_decommit;\n\tbool allow_purge;\n\tsize_t segment_size;\n\n\t// segment fields\n\tmi_msecs_t purge_expire;\n\tmi_commit_mask_t purge_mask;\n\tmi_commit_mask_t commit_mask;\n\n\t_Atomic(struct mi_segment_s*) abandoned_next;\n\n\t// from here is zero initialized\n\tstruct mi_segment_s* next; // the list of freed segments in the cache (must be first field, see\n\t\t\t\t\t\t\t   // `segment.c:mi_segment_init`)\n\n\tsize_t abandoned; // abandoned pages (i.e. the original owning thread stopped) (`abandoned \u003c\u003d\n\t\t\t\t\t  // used`)\n\tsize_t abandoned_visits; // count how often this segment is visited in the abandoned list (to\n\t\t\t\t\t\t\t // force reclaim it it is too long)\n\tsize_t used; // count of pages in use\n\tuintptr_t cookie; // verify addresses in debug mode: `mi_ptr_cookie(segment) \u003d\u003d segment-\u003ecookie`\n\n\tsize_t segment_slices; // for huge segments this may be different from `MI_SLICES_PER_SEGMENT`\n\tsize_t\n\t\tsegment_info_slices; // initial slices we are using segment info and possible guard pages.\n\n\t// layout like this to optimize access in `mi_free`\n\tmi_segment_kind_t kind;\n\tsize_t slice_entries; // entries in the `slices` array, at most `MI_SLICES_PER_SEGMENT`\n\t_Atomic(mi_threadid_t) thread_id; // unique id of the thread owning this segment\n\n\tmi_slice_t slices[MI_SLICES_PER_SEGMENT + 1]; // one more for huge blocks with large alignment\n```",
      "range": {
        "startLine": 420,
        "startChar": 0,
        "endLine": 449,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "427e6bbb_554e1378",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 473,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_page_t* first;\n\tmi_page_t* last;\n\tsize_t block_size;\n```",
      "range": {
        "startLine": 471,
        "startChar": 0,
        "endLine": 473,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "867de5ed_79dadf24",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 476,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_BIN_FULL (MI_BIN_HUGE + 1)\n```",
      "range": {
        "startLine": 476,
        "startChar": 0,
        "endLine": 476,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "671cd600_0f4120e1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 483,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tuint32_t input[16];\n\tuint32_t output[16];\n\tint output_available;\n\tbool weak;\n```",
      "range": {
        "startLine": 480,
        "startChar": 0,
        "endLine": 483,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aee0d7cf_cab25df5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 491,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tuint32_t canary; // encoded block value to check validity of the padding (in case of overflow)\n\tuint32_t delta; // padding bytes before the block. (mi_usable_size(p) - delta \u003d\u003d exact allocated\n\t\t\t\t\t// bytes)\n```",
      "range": {
        "startLine": 490,
        "startChar": 0,
        "endLine": 491,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3080e7b_ecdade00",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 500,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_PADDING_SIZE (sizeof(mi_padding_t))\n#define MI_PADDING_WSIZE ((MI_PADDING_SIZE + MI_INTPTR_SIZE - 1) / MI_INTPTR_SIZE)\n#else\n#define MI_PADDING_SIZE 0\n#define MI_PADDING_WSIZE 0\n#endif\n\n#define MI_PAGES_DIRECT (MI_SMALL_WSIZE_MAX + MI_PADDING_WSIZE + 1)\n```",
      "range": {
        "startLine": 493,
        "startChar": 0,
        "endLine": 500,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2183d58e_6d7ff2b7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 522,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 522,
        "startChar": 0,
        "endLine": 522,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5cfe8706_88af8903",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 528,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_DEBUG_UNINIT (0xD0)\n```",
      "range": {
        "startLine": 528,
        "startChar": 0,
        "endLine": 528,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3e186fd_68b4781c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 531,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_DEBUG_FREED (0xDF)\n```",
      "range": {
        "startLine": 531,
        "startChar": 0,
        "endLine": 531,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19d4f6ef_71edb70b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 534,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_DEBUG_PADDING (0xDE)\n```",
      "range": {
        "startLine": 534,
        "startChar": 0,
        "endLine": 534,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3565ff45_bba2a4d1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 540,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid _mi_assert_fail(const char* assertion, const char* fname, unsigned int line, const char* func);\n#define mi_assert(expr) ((expr) ? (void)0 : _mi_assert_fail(#expr, __FILE__, __LINE__, __func__))\n```",
      "range": {
        "startLine": 539,
        "startChar": 0,
        "endLine": 540,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82e14aeb_d9f0c6e8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 546,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_DEBUG \u003e 1)\n#define mi_assert_internal mi_assert\n```",
      "range": {
        "startLine": 545,
        "startChar": 0,
        "endLine": 546,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "035045b8_6d079989",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 552,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_DEBUG \u003e 2)\n#define mi_assert_expensive mi_assert\n```",
      "range": {
        "startLine": 551,
        "startChar": 0,
        "endLine": 552,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52fea293_e07a6273",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 562,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_DEBUG \u003e 0)\n```",
      "range": {
        "startLine": 562,
        "startChar": 0,
        "endLine": 562,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "277500c8_f070136c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 573,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tint64_t allocated;\n\tint64_t freed;\n\tint64_t peak;\n\tint64_t current;\n```",
      "range": {
        "startLine": 570,
        "startChar": 0,
        "endLine": 573,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c315dfbe_8e9e4b10",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 578,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tint64_t total;\n\tint64_t count;\n```",
      "range": {
        "startLine": 577,
        "startChar": 0,
        "endLine": 578,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "190e663d_1547e90b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 608,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_stat_count_t segments;\n\tmi_stat_count_t pages;\n\tmi_stat_count_t reserved;\n\tmi_stat_count_t committed;\n\tmi_stat_count_t reset;\n\tmi_stat_count_t purged;\n\tmi_stat_count_t page_committed;\n\tmi_stat_count_t segments_abandoned;\n\tmi_stat_count_t pages_abandoned;\n\tmi_stat_count_t threads;\n\tmi_stat_count_t normal;\n\tmi_stat_count_t huge;\n\tmi_stat_count_t large;\n\tmi_stat_count_t malloc;\n\tmi_stat_count_t segments_cache;\n\tmi_stat_counter_t pages_extended;\n\tmi_stat_counter_t mmap_calls;\n\tmi_stat_counter_t commit_calls;\n\tmi_stat_counter_t reset_calls;\n\tmi_stat_counter_t purge_calls;\n\tmi_stat_counter_t page_no_retire;\n\tmi_stat_counter_t searches;\n\tmi_stat_counter_t normal_count;\n\tmi_stat_counter_t huge_count;\n\tmi_stat_counter_t large_count;\n#if MI_STAT \u003e 1\n\tmi_stat_count_t normal_bins[MI_BIN_HUGE + 1];\n```",
      "range": {
        "startLine": 582,
        "startChar": 0,
        "endLine": 608,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d04f1fa9_f729368f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 629,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define mi_stat_increase(stat, amount) _mi_stat_increase(\u0026(stat), amount)\n#define mi_stat_decrease(stat, amount) _mi_stat_decrease(\u0026(stat), amount)\n#define mi_stat_counter_increase(stat, amount) _mi_stat_counter_increase(\u0026(stat), amount)\n#else\n#define mi_stat_increase(stat, amount) (void)0\n#define mi_stat_decrease(stat, amount) (void)0\n#define mi_stat_counter_increase(stat, amount) (void)0\n#endif\n\n#define mi_heap_stat_counter_increase(heap, stat, amount) \\\n\tmi_stat_counter_increase((heap)-\u003etld-\u003estats.stat, amount)\n#define mi_heap_stat_increase(heap, stat, amount) mi_stat_increase((heap)-\u003etld-\u003estats.stat, amount)\n#define mi_heap_stat_decrease(heap, stat, amount) mi_stat_decrease((heap)-\u003etld-\u003estats.stat, amount)\n```",
      "range": {
        "startLine": 618,
        "startChar": 0,
        "endLine": 629,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a7d3aae_70eb12a8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 640,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_slice_t* first;\n\tmi_slice_t* last;\n\tsize_t slice_count;\n```",
      "range": {
        "startLine": 638,
        "startChar": 0,
        "endLine": 640,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d35330c7_c2878eea",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 643,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SEGMENT_BIN_MAX (35) // 35 \u003d\u003d mi_segment_bin(MI_SLICES_PER_SEGMENT)\n```",
      "range": {
        "startLine": 643,
        "startChar": 0,
        "endLine": 643,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "67e64e2b_17e92977",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 648,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tsize_t region_idx; // start point for next allocation\n\tmi_stats_t* stats; // points to tld stats\n```",
      "range": {
        "startLine": 647,
        "startChar": 0,
        "endLine": 648,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "053f17c8_86d2a833",
        "filename": "src/system/libroot/posix/malloc/mimalloc/mimalloc/types.h",
        "patchSetId": 7
      },
      "lineNbr": 660,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_span_queue_t spans[MI_SEGMENT_BIN_MAX + 1]; // free slice spans inside segments\n\tsize_t count; // current number of segments;\n\tsize_t peak_count; // peak number of segments\n\tsize_t current_size; // current size of all segments\n\tsize_t peak_size; // peak size of all segments\n\tmi_stats_t* stats; // points to tld stats\n\tmi_os_tld_t* os; // points to os stats\n```",
      "range": {
        "startLine": 654,
        "startChar": 0,
        "endLine": 660,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fc9f79b5_20190f49",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 7,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1c0579d1_9a60fa1c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 13,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \"mimalloc/prim.h\" // mi_prim_out_stderr\n\n```",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6813c07c_177ce5a7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 17,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cstdio.h\u003e // FILE\n#include \u003cstdlib.h\u003e // abort\n\n\nstatic long mi_max_error_count \u003d 16; // stop outputting errors after this (use \u003c 0 for no limit)\n```",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 17,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7da22683_27a71da3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 23,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nint\nmi_version(void) mi_attr_noexcept\n{\n\treturn MI_MALLOC_VERSION;\n```",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 23,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d35fa540_2233f1c6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 36,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tUNINIT, // not yet initialized\n\tDEFAULTED, // not found in the environment, use default value\n\tINITIALIZED // found in environment or set explicitly\n```",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 36,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f167e091_250d91fc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tlong value; // the value\n\tmi_init_t init; // is it initialized yet? (from the environment)\n\tmi_option_t option; // for debugging: the option index should match the option\n\tconst char* name; // option name without `mimalloc_` prefix\n\tconst char* legacy_name; // potential legacy option name\n```",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 44,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ed83ab93_8d9ad565",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 72,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_OPTION(opt) mi_option_##opt, #opt, NULL\n#define MI_OPTION_LEGACY(opt, legacy) mi_option_##opt, #opt, #legacy\n\nstatic mi_option_desc_t options[_mi_option_last] \u003d {\n// stable options\n#if MI_DEBUG || defined(MI_SHOW_ERRORS)\n\t{1, UNINIT, MI_OPTION(show_errors)},\n#else\n\t{0, UNINIT, MI_OPTION(show_errors)},\n#endif\n\t{0, UNINIT, MI_OPTION(show_stats)},\n\t{0, UNINIT, MI_OPTION(verbose)},\n\n\t// the following options are experimental and not all combinations make sense.\n\t{1, UNINIT, MI_OPTION(eager_commit)}, // commit per segment directly (4MiB)  (but see also\n\t\t\t\t\t\t\t\t\t\t  // `eager_commit_delay`)\n\t{2, UNINIT,\n\t\tMI_OPTION_LEGACY(arena_eager_commit,\n\t\t\teager_region_commit)}, // eager commit arena\u0027s? 2 is used to enable this only on an OS\n\t\t\t\t\t\t\t\t   // that has overcommit (i.e. linux)\n\t{1, UNINIT,\n\t\tMI_OPTION_LEGACY(purge_decommits,\n\t\t\treset_decommits)}, // purge decommits memory (instead of reset) (note: on linux this\n\t\t\t\t\t\t\t   // uses MADV_DONTNEED for decommit)\n\t{0, UNINIT,\n\t\tMI_OPTION_LEGACY(allow_large_os_pages,\n\t\t\tlarge_os_pages)}, // use large OS pages, use only with eager commit to prevent\n\t\t\t\t\t\t\t  // fragmentation of VMA\u0027s\n\t{0, UNINIT, MI_OPTION(reserve_huge_os_pages)}, // per 1GiB huge pages\n\t{-1, UNINIT, MI_OPTION(reserve_huge_os_pages_at)}, // reserve huge pages at node N\n\t{0, UNINIT, MI_OPTION(reserve_os_memory)},\n\t{0, UNINIT, MI_OPTION(deprecated_segment_cache)}, // cache N segments per thread\n\t{0, UNINIT, MI_OPTION(deprecated_page_reset)}, // reset page memory on free\n\t{0, UNINIT,\n\t\tMI_OPTION_LEGACY(abandoned_page_purge,\n\t\t\tabandoned_page_reset)}, // reset free page memory when a thread terminates\n\t{0, UNINIT,\n\t\tMI_OPTION(deprecated_segment_reset)}, // reset segment memory on free (needs eager commit)\n```",
      "range": {
        "startLine": 47,
        "startChar": 0,
        "endLine": 72,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7511940f_328eb339",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 74,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t{0, UNINIT,\n\t\tMI_OPTION(eager_commit_delay)}, // the first N segments per thread are not eagerly committed\n```",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 74,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b841a7a_129bae1f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t{1, UNINIT, MI_OPTION(eager_commit_delay)}, // the first N segments per thread are not eagerly\n\t\t\t\t\t\t\t\t\t\t\t\t// committed (but per page in the segment on demand)\n#endif\n\t{10, UNINIT, MI_OPTION_LEGACY(purge_delay, reset_delay)}, // purge delay in milli-seconds\n\t{0, UNINIT,\n\t\tMI_OPTION(use_numa_nodes)}, // 0 \u003d use available numa nodes, otherwise use at most N nodes.\n\t{0, UNINIT,\n\t\tMI_OPTION(\n\t\t\tlimit_os_alloc)}, // 1 \u003d do not use OS memory for allocation (but only reserved arenas)\n\t{100, UNINIT,\n\t\tMI_OPTION(\n\t\t\tos_tag)}, // only apple specific for now but might serve more or less related purpose\n\t{16, UNINIT, MI_OPTION(max_errors)}, // maximum errors that are output\n\t{16, UNINIT, MI_OPTION(max_warnings)}, // maximum warnings that are output\n\t{8, UNINIT, MI_OPTION(max_segment_reclaim)}, // max. number of segment reclaims from the\n\t\t\t\t\t\t\t\t\t\t\t\t // abandoned segments per try.\n\t{0, UNINIT, MI_OPTION(destroy_on_exit)}, // release all OS memory on process exit; careful with\n\t\t\t\t\t\t\t\t\t\t\t // dangling pointer or after-exit frees!\n#if (MI_INTPTR_SIZE \u003e 4)\n\t{1024L * 1024L, UNINIT, MI_OPTION(arena_reserve)}, // reserve memory N KiB at a time\n#else\n\t{128L * 1024L, UNINIT, MI_OPTION(arena_reserve)},\n#endif\n\t{10, UNINIT, MI_OPTION(arena_purge_mult)}, // purge delay multiplier for arena\u0027s\n\t{1, UNINIT, MI_OPTION_LEGACY(purge_extend_delay, decommit_extend_delay)},\n```",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 92,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f60539a6_192ecaf8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 178,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n_mi_options_init(void)\n{\n\t// called on process load; should not be called before the CRT is initialized!\n\t// (e.g. do not call this from process_init as that may run before CRT initialization)\n\tmi_add_stderr_output(); // now it safe to use stderr for output\n\tfor (int i \u003d 0; i \u003c _mi_option_last; i++) {\n\t\tmi_option_t option \u003d (mi_option_t)i;\n\t\tlong l \u003d mi_option_get(option);\n\t\tMI_UNUSED(l); // initialize\n\t\t// if (option !\u003d mi_option_verbose)\n\t\t{\n\t\t\tmi_option_desc_t* desc \u003d \u0026options[option];\n\t\t\t_mi_verbose_message(\"option \u0027%s\u0027: %ld\\n\", desc-\u003ename, desc-\u003evalue);\n\t\t}\n\t}\n\tmi_max_error_count \u003d mi_option_get(mi_option_max_errors);\n\tmi_max_warning_count \u003d mi_option_get(mi_option_max_warnings);\n}\n\n\nmi_decl_nodiscard long\nmi_option_get(mi_option_t option)\n{\n\tmi_assert(option \u003e\u003d 0 \u0026\u0026 option \u003c _mi_option_last);\n\tif (option \u003c 0 || option \u003e\u003d _mi_option_last)\n\t\treturn 0;\n\tmi_option_desc_t* desc \u003d \u0026options[option];\n\tmi_assert(desc-\u003eoption \u003d\u003d option); // index should match the option\n\tif mi_unlikely (desc-\u003einit \u003d\u003d UNINIT)\n\t\tmi_option_init(desc);\n\treturn desc-\u003evalue;\n}\n\n\nmi_decl_nodiscard long\nmi_option_get_clamp(mi_option_t option, long min, long max)\n{\n\tlong x \u003d mi_option_get(option);\n\treturn x \u003c min ? min : (x \u003e max ? max : x);\n}\n\n\nmi_decl_nodiscard size_t\nmi_option_get_size(mi_option_t option)\n{\n\tmi_assert_internal(option \u003d\u003d mi_option_reserve_os_memory || option \u003d\u003d mi_option_arena_reserve);\n\tlong x \u003d mi_option_get(option);\n\treturn x \u003c 0 ? 0 : (size_t)x * MI_KiB;\n}\n\n\nvoid\nmi_option_set(mi_option_t option, long value)\n{\n\tmi_assert(option \u003e\u003d 0 \u0026\u0026 option \u003c _mi_option_last);\n\tif (option \u003c 0 || option \u003e\u003d _mi_option_last)\n\t\treturn;\n\tmi_option_desc_t* desc \u003d \u0026options[option];\n\tmi_assert(desc-\u003eoption \u003d\u003d option); // index should match the option\n\tdesc-\u003evalue \u003d value;\n\tdesc-\u003einit \u003d INITIALIZED;\n}\n\n\nvoid\nmi_option_set_default(mi_option_t option, long value)\n{\n\tmi_assert(option \u003e\u003d 0 \u0026\u0026 option \u003c _mi_option_last);\n\tif (option \u003c 0 || option \u003e\u003d _mi_option_last)\n\t\treturn;\n\tmi_option_desc_t* desc \u003d \u0026options[option];\n\tif (desc-\u003einit !\u003d INITIALIZED)\n\t\tdesc-\u003evalue \u003d value;\n}\n\n\nmi_decl_nodiscard bool\nmi_option_is_enabled(mi_option_t option)\n{\n\treturn mi_option_get(option) !\u003d 0;\n}\n\n\nvoid\nmi_option_set_enabled(mi_option_t option, bool enable)\n{\n\tmi_option_set(option, (enable ? 1 : 0));\n}\n\n\nvoid\nmi_option_set_enabled_default(mi_option_t option, bool enable)\n{\n\tmi_option_set_default(option, (enable ? 1 : 0));\n}\n\n\nvoid\nmi_option_enable(mi_option_t option)\n{\n\tmi_option_set_enabled(option, true);\n}\n\n\nvoid\nmi_option_disable(mi_option_t option)\n{\n\tmi_option_set_enabled(option, false);\n}\n\n\nstatic void mi_cdecl\nmi_out_stderr(const char* msg, void* arg)\n{\n\tMI_UNUSED(arg);\n\tif (msg !\u003d NULL \u0026\u0026 msg[0] !\u003d 0)\n\t\t_mi_prim_out_stderr(msg);\n```",
      "range": {
        "startLine": 97,
        "startChar": 0,
        "endLine": 178,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f8726f53_f687b8a5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 188,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_DELAY_OUTPUT ((size_t)(32 * 1024))\n#endif\nstatic char out_buf[MI_MAX_DELAY_OUTPUT + 1];\n```",
      "range": {
        "startLine": 186,
        "startChar": 0,
        "endLine": 188,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "46499052_7a6dc995",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 217,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void mi_cdecl\nmi_out_buf(const char* msg, void* arg)\n{\n\tMI_UNUSED(arg);\n\tif (msg \u003d\u003d NULL)\n\t\treturn;\n\tif (mi_atomic_load_relaxed(\u0026out_len) \u003e\u003d MI_MAX_DELAY_OUTPUT)\n\t\treturn;\n\tsize_t n \u003d _mi_strlen(msg);\n\tif (n \u003d\u003d 0)\n\t\treturn;\n\t// claim space\n\tsize_t start \u003d mi_atomic_add_acq_rel(\u0026out_len, n);\n\tif (start \u003e\u003d MI_MAX_DELAY_OUTPUT)\n\t\treturn;\n\t// check bound\n\tif (start + n \u003e\u003d MI_MAX_DELAY_OUTPUT)\n\t\tn \u003d MI_MAX_DELAY_OUTPUT - start - 1;\n\t_mi_memcpy(\u0026out_buf[start], msg, n);\n}\n\n\nstatic void\nmi_out_buf_flush(mi_output_fun* out, bool no_more_buf, void* arg)\n{\n\tif (out \u003d\u003d NULL)\n\t\treturn;\n\t// claim (if `no_more_buf \u003d\u003d true`, no more output will be added after this point)\n\tsize_t count \u003d mi_atomic_add_acq_rel(\u0026out_len, (no_more_buf ? MI_MAX_DELAY_OUTPUT : 1));\n\t// and output the current contents\n\tif (count \u003e MI_MAX_DELAY_OUTPUT)\n\t\tcount \u003d MI_MAX_DELAY_OUTPUT;\n\tout_buf[count] \u003d 0;\n\tout(out_buf, arg);\n\tif (!no_more_buf)\n\t\tout_buf[count] \u003d \u0027\\n\u0027; // if continue with the buffer, insert a newline\n```",
      "range": {
        "startLine": 191,
        "startChar": 0,
        "endLine": 217,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07090f84_ede94fff",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 227,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void mi_cdecl\nmi_out_buf_stderr(const char* msg, void* arg)\n{\n\tmi_out_stderr(msg, arg);\n\tmi_out_buf(msg, arg);\n}\n```",
      "range": {
        "startLine": 223,
        "startChar": 0,
        "endLine": 227,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8de7d98c_2501936a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 235,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Should be atomic but gives errors on many platforms as generally we cannot cast a function\n// pointer to a uintptr_t. For now, don\u0027t register output from multiple threads.\n```",
      "range": {
        "startLine": 234,
        "startChar": 0,
        "endLine": 235,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b1197042_74057f8d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 248,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic mi_output_fun*\nmi_out_get_default(void** parg)\n{\n\tif (parg !\u003d NULL)\n\t\t*parg \u003d mi_atomic_load_ptr_acquire(void, \u0026mi_out_arg);\n\tmi_output_fun* out \u003d mi_out_default;\n\treturn out \u003d\u003d NULL ? \u0026mi_out_buf : out;\n}\n\n\nvoid\nmi_register_output(mi_output_fun* out, void* arg) mi_attr_noexcept\n{\n\tmi_out_default \u003d (out \u003d\u003d NULL ? \u0026mi_out_stderr : out); // stop using the delayed output buffer\n\tmi_atomic_store_ptr_release(void, \u0026mi_out_arg, arg);\n\tif (out !\u003d NULL)\n\t\tmi_out_buf_flush(out, true, arg); // output all the delayed output now\n```",
      "range": {
        "startLine": 239,
        "startChar": 0,
        "endLine": 248,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b5cd1cef_d591346d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 255,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_add_stderr_output(void)\n{\n\tmi_assert_internal(mi_out_default \u003d\u003d NULL);\n\tmi_out_buf_flush(\u0026mi_out_stderr, false, NULL); // flush current contents to stderr\n\tmi_out_default \u003d \u0026mi_out_buf_stderr; // and add stderr to the delayed output\n```",
      "range": {
        "startLine": 252,
        "startChar": 0,
        "endLine": 255,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e7c8137_64d507b2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 261,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic _Atomic(size_t) error_count; // \u003d 0;  // when \u003e\u003d max_error_count stop emitting errors\n```",
      "range": {
        "startLine": 261,
        "startChar": 0,
        "endLine": 261,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa9f2f87_ffaa886a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 310,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic mi_decl_noinline bool\nmi_recurse_enter_prim(void)\n{\n\tif (recurse)\n\t\treturn false;\n\trecurse \u003d true;\n\treturn true;\n}\n\n\nstatic mi_decl_noinline void\nmi_recurse_exit_prim(void)\n{\n\trecurse \u003d false;\n}\n\n\nstatic bool\nmi_recurse_enter(void)\n{\n#if defined(__APPLE__) || defined(MI_TLS_RECURSE_GUARD)\n\tif (_mi_preloading())\n\t\treturn false;\n#endif\n\treturn mi_recurse_enter_prim();\n}\n\n\nstatic void\nmi_recurse_exit(void)\n{\n#if defined(__APPLE__) || defined(MI_TLS_RECURSE_GUARD)\n\tif (_mi_preloading())\n\t\treturn;\n#endif\n\tmi_recurse_exit_prim();\n}\n\n\nvoid\n_mi_fputs(mi_output_fun* out, void* arg, const char* prefix, const char* message)\n{\n\tif (out \u003d\u003d NULL || (void*)out \u003d\u003d (void*)stdout\n\t\t|| (void*)out \u003d\u003d (void*)stderr) { // TODO: use mi_out_stderr for stderr?\n\t\tif (!mi_recurse_enter())\n\t\t\treturn;\n\t\tout \u003d mi_out_get_default(\u0026arg);\n\t\tif (prefix !\u003d NULL)\n\t\t\tout(prefix, arg);\n\t\tout(message, arg);\n\t\tmi_recurse_exit();\n\t} else {\n\t\tif (prefix !\u003d NULL)\n\t\t\tout(prefix, arg);\n\t\tout(message, arg);\n\t}\n```",
      "range": {
        "startLine": 275,
        "startChar": 0,
        "endLine": 310,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "934398ac_6fbab42a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 374,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_vfprintf(mi_output_fun* out, void* arg, const char* prefix, const char* fmt, va_list args)\n{\n\tchar buf[512];\n\tif (fmt \u003d\u003d NULL)\n\t\treturn;\n\tif (!mi_recurse_enter())\n\t\treturn;\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n\tmi_recurse_exit();\n\t_mi_fputs(out, arg, prefix, buf);\n}\n\n\nvoid\n_mi_fprintf(mi_output_fun* out, void* arg, const char* fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tmi_vfprintf(out, arg, NULL, fmt, args);\n\tva_end(args);\n}\n\n\nstatic void\nmi_vfprintf_thread(mi_output_fun* out, void* arg, const char* prefix, const char* fmt, va_list args)\n{\n\tif (prefix !\u003d NULL \u0026\u0026 _mi_strnlen(prefix, 33) \u003c\u003d 32 \u0026\u0026 !_mi_is_main_thread()) {\n\t\tchar tprefix[64];\n\t\tsnprintf(tprefix, sizeof(tprefix), \"%sthread 0x%llx: \", prefix,\n\t\t\t(unsigned long long)_mi_thread_id());\n\t\tmi_vfprintf(out, arg, tprefix, fmt, args);\n\t} else {\n\t\tmi_vfprintf(out, arg, prefix, fmt, args);\n\t}\n}\n\n\nvoid\n_mi_trace_message(const char* fmt, ...)\n{\n\tif (mi_option_get(mi_option_verbose) \u003c\u003d 1)\n\t\treturn; // only with verbose level 2 or higher\n\tva_list args;\n\tva_start(args, fmt);\n\tmi_vfprintf_thread(NULL, NULL, \"mimalloc: \", fmt, args);\n\tva_end(args);\n}\n\n\nvoid\n_mi_verbose_message(const char* fmt, ...)\n{\n\tif (!mi_option_is_enabled(mi_option_verbose))\n\t\treturn;\n\tva_list args;\n\tva_start(args, fmt);\n\tmi_vfprintf(NULL, NULL, \"mimalloc: \", fmt, args);\n\tva_end(args);\n}\n\n\nstatic void\nmi_show_error_message(const char* fmt, va_list args)\n{\n\tif (!mi_option_is_enabled(mi_option_verbose)) {\n\t\tif (!mi_option_is_enabled(mi_option_show_errors))\n\t\t\treturn;\n\t\tif (mi_max_error_count \u003e\u003d 0\n\t\t\t\u0026\u0026 (long)mi_atomic_increment_acq_rel(\u0026error_count) \u003e mi_max_error_count) {\n\t\t\treturn;\n\t\t}\n\t}\n\tmi_vfprintf_thread(NULL, NULL, \"mimalloc: error: \", fmt, args);\n}\n\n\nvoid\n_mi_warning_message(const char* fmt, ...)\n{\n\tif (!mi_option_is_enabled(mi_option_verbose)) {\n\t\tif (!mi_option_is_enabled(mi_option_show_errors))\n\t\t\treturn;\n\t\tif (mi_max_warning_count \u003e\u003d 0\n\t\t\t\u0026\u0026 (long)mi_atomic_increment_acq_rel(\u0026warning_count) \u003e mi_max_warning_count) {\n\t\t\treturn;\n\t\t}\n\t}\n\tva_list args;\n\tva_start(args, fmt);\n\tmi_vfprintf_thread(NULL, NULL, \"mimalloc: warning: \", fmt, args);\n\tva_end(args);\n```",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 374,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40f68ab5_6dcbfd2f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 381,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nvoid\n_mi_assert_fail(const char* assertion, const char* fname, unsigned line, const char* func)\n{\n\t_mi_fprintf(NULL, NULL, \"mimalloc: assertion failed: at \\\"%s\\\":%u, %s\\n  assertion: \\\"%s\\\"\\n\",\n\t\tfname, line, (func \u003d\u003d NULL ? \"\" : func), assertion);\n\tabort();\n```",
      "range": {
        "startLine": 379,
        "startChar": 0,
        "endLine": 381,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "37145a5e_f24d38aa",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 405,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_error_fun* volatile mi_error_handler; // \u003d NULL\nstatic _Atomic(void*) mi_error_arg; // \u003d NULL\n\n\nstatic void\nmi_error_default(int err)\n{\n\tMI_UNUSED(err);\n#if (MI_DEBUG \u003e 0)\n\tif (err \u003d\u003d EFAULT) {\n#ifdef _MSC_VER\n\t\t__debugbreak();\n#endif\n\t\tabort();\n\t}\n#endif\n#if (MI_SECURE \u003e 0)\n\tif (err \u003d\u003d EFAULT) // abort on serious errors in secure mode (corrupted meta-data)\n\t\tabort();\n```",
      "range": {
        "startLine": 389,
        "startChar": 0,
        "endLine": 405,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9aee3274_fb21426e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 431,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tif (err \u003d\u003d ENOMEM || err \u003d\u003d EOVERFLOW) // abort on memory allocation fails in xmalloc mode\n\t\tabort();\n#endif\n}\n\n\nvoid\nmi_register_error(mi_error_fun* fun, void* arg)\n{\n\tmi_error_handler \u003d fun; // can be NULL\n\tmi_atomic_store_ptr_release(void, \u0026mi_error_arg, arg);\n}\n\n\nvoid\n_mi_error_message(int err, const char* fmt, ...)\n{\n\t// show detailed error message\n\tva_list args;\n\tva_start(args, fmt);\n\tmi_show_error_message(fmt, args);\n\tva_end(args);\n\t// and call the error handler which may abort (or return normally)\n\tif (mi_error_handler !\u003d NULL)\n\t\tmi_error_handler(err, mi_atomic_load_ptr_acquire(void, \u0026mi_error_arg));\n\telse\n\t\tmi_error_default(err);\n```",
      "range": {
        "startLine": 408,
        "startChar": 0,
        "endLine": 431,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7bd7c2a_2787f26e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 483,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nchar\n_mi_toupper(char c)\n{\n\tif (c \u003e\u003d \u0027a\u0027 \u0026\u0026 c \u003c\u003d \u0027z\u0027)\n\t\treturn c - \u0027a\u0027 + \u0027A\u0027;\n\telse\n\t\treturn c;\n}\n\n\nint\n_mi_strnicmp(const char* s, const char* t, size_t n)\n{\n\tif (n \u003d\u003d 0)\n\t\treturn 0;\n\tfor (; *s !\u003d 0 \u0026\u0026 *t !\u003d 0 \u0026\u0026 n \u003e 0; s++, t++, n--) {\n\t\tif (_mi_toupper(*s) !\u003d _mi_toupper(*t))\n\t\t\tbreak;\n\t}\n\treturn n \u003d\u003d 0 ? 0 : *s - *t;\n}\n\n\nvoid\n_mi_strlcpy(char* dest, const char* src, size_t dest_size)\n{\n\tif (dest \u003d\u003d NULL || src \u003d\u003d NULL || dest_size \u003d\u003d 0)\n\t\treturn;\n\t// copy until end of src, or when dest is (almost) full\n\twhile (*src !\u003d 0 \u0026\u0026 dest_size \u003e 1) {\n\t\t*dest++ \u003d *src++;\n\t\tdest_size--;\n\t}\n\t// always zero terminate\n\t*dest \u003d 0;\n}\n\n\nvoid\n_mi_strlcat(char* dest, const char* src, size_t dest_size)\n{\n\tif (dest \u003d\u003d NULL || src \u003d\u003d NULL || dest_size \u003d\u003d 0)\n\t\treturn;\n\t// find end of string in the dest buffer\n\twhile (*dest !\u003d 0 \u0026\u0026 dest_size \u003e 1) {\n\t\tdest++;\n\t\tdest_size--;\n\t}\n\t// and catenate\n\t_mi_strlcpy(dest, src, dest_size);\n}\n\n\nsize_t\n_mi_strlen(const char* s)\n{\n\tif (s \u003d\u003d NULL)\n\t\treturn 0;\n\tsize_t len \u003d 0;\n\twhile (s[len] !\u003d 0)\n\t\tlen++;\n\treturn len;\n}\n\n\nsize_t\n_mi_strnlen(const char* s, size_t max_len)\n{\n\tif (s \u003d\u003d NULL)\n\t\treturn 0;\n\tsize_t len \u003d 0;\n\twhile (s[len] !\u003d 0 \u0026\u0026 len \u003c max_len)\n\t\tlen++;\n\treturn len;\n```",
      "range": {
        "startLine": 437,
        "startChar": 0,
        "endLine": 483,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df4fca9b_0e4066c8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 491,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic bool\nmi_getenv(const char* name, char* result, size_t result_size)\n{\n\tMI_UNUSED(name);\n\tMI_UNUSED(result);\n\tMI_UNUSED(result_size);\n\treturn false;\n```",
      "range": {
        "startLine": 487,
        "startChar": 0,
        "endLine": 491,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fe8f545c_8fa96b31",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 496,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic bool\nmi_getenv(const char* name, char* result, size_t result_size)\n{\n\tif (name \u003d\u003d NULL || result \u003d\u003d NULL || result_size \u003c 64)\n\t\treturn false;\n\treturn _mi_prim_getenv(name, result, result_size);\n```",
      "range": {
        "startLine": 494,
        "startChar": 0,
        "endLine": 496,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "178d4838_84e153ae",
        "filename": "src/system/libroot/posix/malloc/mimalloc/options.c",
        "patchSetId": 7
      },
      "lineNbr": 571,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_option_init(mi_option_desc_t* desc)\n{\n\t// Read option value from the environment\n\tchar s[64 + 1];\n\tchar buf[64 + 1];\n\t_mi_strlcpy(buf, \"mimalloc_\", sizeof(buf));\n\t_mi_strlcat(buf, desc-\u003ename, sizeof(buf));\n\tbool found \u003d mi_getenv(buf, s, sizeof(s));\n\tif (!found \u0026\u0026 desc-\u003elegacy_name !\u003d NULL) {\n\t\t_mi_strlcpy(buf, \"mimalloc_\", sizeof(buf));\n\t\t_mi_strlcat(buf, desc-\u003elegacy_name, sizeof(buf));\n\t\tfound \u003d mi_getenv(buf, s, sizeof(s));\n\t\tif (found) {\n\t\t\t_mi_warning_message(\"environment option \\\"mimalloc_%s\\\" is deprecated -- use \"\n\t\t\t\t\t\t\t\t\"\\\"mimalloc_%s\\\" instead.\\n\",\n\t\t\t\tdesc-\u003elegacy_name, desc-\u003ename);\n\t\t}\n\t}\n\n\tif (found) {\n\t\tsize_t len \u003d _mi_strnlen(s, sizeof(buf) - 1);\n\t\tfor (size_t i \u003d 0; i \u003c len; i++)\n\t\t\tbuf[i] \u003d _mi_toupper(s[i]);\n\t\tbuf[len] \u003d 0;\n\t\tif (buf[0] \u003d\u003d 0 || strstr(\"1;TRUE;YES;ON\", buf) !\u003d NULL) {\n\t\t\tdesc-\u003evalue \u003d 1;\n\t\t\tdesc-\u003einit \u003d INITIALIZED;\n\t\t} else if (strstr(\"0;FALSE;NO;OFF\", buf) !\u003d NULL) {\n\t\t\tdesc-\u003evalue \u003d 0;\n\t\t\tdesc-\u003einit \u003d INITIALIZED;\n\t\t} else {\n\t\t\tchar* end \u003d buf;\n\t\t\tlong value \u003d strtol(buf, \u0026end, 10);\n\t\t\tif (desc-\u003eoption \u003d\u003d mi_option_reserve_os_memory\n\t\t\t\t|| desc-\u003eoption \u003d\u003d mi_option_arena_reserve) {\n\t\t\t\t// this option is interpreted in KiB to prevent overflow of `long`\n\t\t\t\tif (*end \u003d\u003d \u0027K\u0027) {\n\t\t\t\t\tend++;\n\t\t\t\t} else if (*end \u003d\u003d \u0027M\u0027) {\n\t\t\t\t\tvalue *\u003d MI_KiB;\n\t\t\t\t\tend++;\n\t\t\t\t} else if (*end \u003d\u003d \u0027G\u0027) {\n\t\t\t\t\tvalue *\u003d MI_MiB;\n\t\t\t\t\tend++;\n\t\t\t\t} else {\n\t\t\t\t\tvalue \u003d (value + MI_KiB - 1) / MI_KiB;\n\t\t\t\t}\n\t\t\t\tif (end[0] \u003d\u003d \u0027I\u0027 \u0026\u0026 end[1] \u003d\u003d \u0027B\u0027)\n\t\t\t\t\tend +\u003d 2;\n\t\t\t\telse if (*end \u003d\u003d \u0027B\u0027)\n\t\t\t\t\tend++;\n\t\t\t}\n\t\t\tif (*end \u003d\u003d 0) {\n\t\t\t\tdesc-\u003evalue \u003d value;\n\t\t\t\tdesc-\u003einit \u003d INITIALIZED;\n\t\t\t} else {\n\t\t\t\t// set `init` first to avoid recursion through _mi_warning_message on\n\t\t\t\t// mimalloc_verbose.\n\t\t\t\tdesc-\u003einit \u003d DEFAULTED;\n\t\t\t\tif (desc-\u003eoption \u003d\u003d mi_option_verbose \u0026\u0026 desc-\u003evalue \u003d\u003d 0) {\n\t\t\t\t\t// if the \u0027mimalloc_verbose\u0027 env var has a bogus value we\u0027d never know\n\t\t\t\t\t// (since the value defaults to \u0027off\u0027) so in that case briefly enable verbose\n\t\t\t\t\tdesc-\u003evalue \u003d 1;\n\t\t\t\t\t_mi_warning_message(\"environment option mimalloc_%s has an invalid value.\\n\",\n\t\t\t\t\t\tdesc-\u003ename);\n\t\t\t\t\tdesc-\u003evalue \u003d 0;\n\t\t\t\t} else {\n\t\t\t\t\t_mi_warning_message(\"environment option mimalloc_%s has an invalid value.\\n\",\n\t\t\t\t\t\tdesc-\u003ename);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi_assert_internal(desc-\u003einit !\u003d UNINIT);\n\t} else if (!_mi_preloading()) {\n\t\tdesc-\u003einit \u003d DEFAULTED;\n\t}\n}\n```",
      "range": {
        "startLine": 505,
        "startChar": 0,
        "endLine": 571,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "86c44cf2_931822be",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 7,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "615b0af1_764627a8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 9,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 9,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce0db27e_ba2cd64d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 25,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t4096, // page size\n\t0, // large page size (usually 2MiB)\n\t4096, // allocation granularity\n\ttrue, // has overcommit?  (if true we use MAP_NORESERVE on mmap systems)\n\tfalse, // must free whole? (on mmap systems we can free anywhere in a mapped range, but on\n\t\t   // Windows we must free the entire span)\n\ttrue // has virtual reserve? (if true we can reserve virtual address space without using commit\n\t\t // or physical memory)\n```",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 25,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "67fb3c29_cf1f56cd",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 33,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nbool\n_mi_os_has_overcommit(void)\n{\n\treturn mi_os_mem_config.has_overcommit;\n}\n\n\nbool\n_mi_os_has_virtual_reserve(void)\n{\n\treturn mi_os_mem_config.has_virtual_reserve;\n```",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 33,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66bb9714_21702886",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 50,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nsize_t\n_mi_os_page_size(void)\n{\n\treturn mi_os_mem_config.page_size;\n}\n\n// if large OS pages are supported (2 or 4MiB), then return the size, otherwise return the small\n// page size (4KiB)\nsize_t\n_mi_os_large_page_size(void)\n{\n\treturn mi_os_mem_config.large_page_size !\u003d 0 ? mi_os_mem_config.large_page_size\n\t\t\t\t\t\t\t\t\t\t\t\t : _mi_os_page_size();\n}\n\n\nbool\n_mi_os_use_large_page(size_t size, size_t alignment)\n{\n\t// if we have access, check the size and alignment requirements\n\tif (mi_os_mem_config.large_page_size \u003d\u003d 0\n\t\t|| !mi_option_is_enabled(mi_option_allow_large_os_pages)) {\n\t\treturn false;\n\t}\n\treturn (size % mi_os_mem_config.large_page_size) \u003d\u003d 0\n\t\t\u0026\u0026 (alignment % mi_os_mem_config.large_page_size) \u003d\u003d 0;\n```",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 50,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d26f92bc_b8018f29",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 66,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nsize_t\n_mi_os_good_alloc_size(size_t size)\n{\n\tsize_t align_size;\n\tif (size \u003c 512 * MI_KiB)\n\t\talign_size \u003d _mi_os_page_size();\n\telse if (size \u003c 2 * MI_MiB)\n\t\talign_size \u003d 64 * MI_KiB;\n\telse if (size \u003c 8 * MI_MiB)\n\t\talign_size \u003d 256 * MI_KiB;\n\telse if (size \u003c 32 * MI_MiB)\n\t\talign_size \u003d 1 * MI_MiB;\n\telse\n\t\talign_size \u003d 4 * MI_MiB;\n\tif mi_unlikely (size \u003e\u003d (SIZE_MAX - align_size))\n\t\treturn size; // possible overflow?\n\treturn _mi_align_up(size, align_size);\n}\n\n\nvoid\n_mi_os_init(void)\n{\n\t_mi_prim_mem_init(\u0026mi_os_mem_config);\n```",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 66,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "41eb04f7_60d910fc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 81,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void*\nmi_align_up_ptr(void* p, size_t alignment)\n{\n\treturn (void*)_mi_align_up((uintptr_t)p, alignment);\n}\n\n\nstatic void*\nmi_align_down_ptr(void* p, size_t alignment)\n{\n\treturn (void*)_mi_align_down((uintptr_t)p, alignment);\n```",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 81,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5d23412_2daa03ea",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_cache_align _Atomic(uintptr_t) aligned_base;\n```",
      "range": {
        "startLine": 92,
        "startChar": 0,
        "endLine": 92,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63508420_e419275d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 126,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_HINT_BASE ((uintptr_t)2 \u003c\u003c 40) // 2TiB start\n#define MI_HINT_AREA \\\n\t((uintptr_t)4 \\\n\t\t\u003c\u003c 40) // upto 6TiB   (since before win8 there is \"only\" 8TiB available to processes)\n#define MI_HINT_MAX \\\n\t((uintptr_t)30 \u003c\u003c 40) // wrap after 30TiB (area after 32TiB is used for huge OS pages)\n\n\nvoid*\n_mi_os_get_aligned_hint(size_t try_alignment, size_t size)\n{\n\tif (try_alignment \u003c\u003d 1 || try_alignment \u003e MI_SEGMENT_SIZE)\n\t\treturn NULL;\n\tsize \u003d _mi_align_up(size, MI_SEGMENT_SIZE);\n\tif (size \u003e 1 * MI_GiB) {\n\t\treturn NULL; // guarantee the chance of fixed valid address is at most 1/(MI_HINT_AREA /\n\t\t\t\t\t // 1\u003c\u003c30) \u003d 1/4096.\n\t}\n#if (MI_SECURE \u003e 0)\n\tsize +\u003d MI_SEGMENT_SIZE; // put in `MI_SEGMENT_SIZE` virtual gaps between hinted blocks; this\n\t\t\t\t\t\t\t // splits VLA\u0027s but increases guarded areas.\n#endif\n\n\tuintptr_t hint \u003d mi_atomic_add_acq_rel(\u0026aligned_base, size);\n\tif (hint \u003d\u003d 0 || hint \u003e MI_HINT_MAX) { // wrap or initialize\n\t\tuintptr_t init \u003d MI_HINT_BASE;\n#if (MI_SECURE \u003e 0 \\\n\t|| MI_DEBUG \u003d\u003d 0) // security: randomize start of aligned allocations unless in debug mode\n\t\tuintptr_t r \u003d _mi_heap_random_next(mi_prim_get_default_heap());\n\t\tinit \u003d init\n\t\t\t+ ((MI_SEGMENT_SIZE * ((r \u003e\u003e 17) \u0026 0xFFFFF))\n\t\t\t\t% MI_HINT_AREA); // (randomly 20 bits)*4MiB \u003d\u003d 0 to 4TiB\n#endif\n\t\tuintptr_t expected \u003d hint + size;\n\t\tmi_atomic_cas_strong_acq_rel(\u0026aligned_base, \u0026expected, init);\n\t\thint \u003d mi_atomic_add_acq_rel(\u0026aligned_base,\n\t\t\tsize); // this may still give 0 or \u003e MI_HINT_MAX but that is ok, it is a hint after all\n\t}\n\tif (hint % try_alignment !\u003d 0)\n\t\treturn NULL;\n\treturn (void*)hint;\n```",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 126,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7fb0f723_13313da1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nvoid*\n_mi_os_get_aligned_hint(size_t try_alignment, size_t size)\n{\n\tMI_UNUSED(try_alignment);\n\tMI_UNUSED(size);\n\treturn NULL;\n```",
      "range": {
        "startLine": 129,
        "startChar": 0,
        "endLine": 131,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "64aded36_60bd78c1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 182,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void\nmi_os_prim_free(void* addr, size_t size, bool still_committed, mi_stats_t* tld_stats)\n{\n\tMI_UNUSED(tld_stats);\n\tmi_assert_internal((size % _mi_os_page_size()) \u003d\u003d 0);\n\tif (addr \u003d\u003d NULL || size \u003d\u003d 0)\n\t\treturn; // || _mi_os_is_huge_reserved(addr)\n\tint err \u003d _mi_prim_free(addr, size);\n\tif (err !\u003d 0) {\n\t\t_mi_warning_message(\n\t\t\t\"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\\n\", err,\n\t\t\terr, size, addr);\n\t}\n\tmi_stats_t* stats \u003d \u0026_mi_stats_main;\n\tif (still_committed)\n\t\t_mi_stat_decrease(\u0026stats-\u003ecommitted, size);\n\t_mi_stat_decrease(\u0026stats-\u003ereserved, size);\n}\n\n\nvoid\n_mi_os_free_ex(void* addr, size_t size, bool still_committed, mi_memid_t memid,\n\tmi_stats_t* tld_stats)\n{\n\tif (mi_memkind_is_os(memid.memkind)) {\n\t\tsize_t csize \u003d _mi_os_good_alloc_size(size);\n\t\tvoid* base \u003d addr;\n\t\t// different base? (due to alignment)\n\t\tif (memid.mem.os.base !\u003d NULL) {\n\t\t\tmi_assert(memid.mem.os.base \u003c\u003d addr);\n\t\t\tmi_assert((uint8_t*)memid.mem.os.base + memid.mem.os.alignment \u003e\u003d (uint8_t*)addr);\n\t\t\tbase \u003d memid.mem.os.base;\n\t\t\tcsize +\u003d ((uint8_t*)addr - (uint8_t*)memid.mem.os.base);\n\t\t}\n\t\t// free it\n\t\tif (memid.memkind \u003d\u003d MI_MEM_OS_HUGE) {\n\t\t\tmi_assert(memid.is_pinned);\n\t\t\tmi_os_free_huge_os_pages(base, csize, tld_stats);\n\t\t} else {\n\t\t\tmi_os_prim_free(base, csize, still_committed, tld_stats);\n\t\t}\n\t} else {\n\t\t// nothing to do\n\t\tmi_assert(memid.memkind \u003c MI_MEM_OS);\n\t}\n}\n\n\nvoid\n_mi_os_free(void* p, size_t size, mi_memid_t memid, mi_stats_t* tld_stats)\n{\n\t_mi_os_free_ex(p, size, true, memid, tld_stats);\n```",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 182,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "065f69ec_b9b3dacc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 217,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// Note: the `try_alignment` is just a hint and the returned pointer is not guaranteed to be\n// aligned.\nstatic void*\nmi_os_prim_alloc(size_t size, size_t try_alignment, bool commit, bool allow_large, bool* is_large,\n\tbool* is_zero, mi_stats_t* stats)\n{\n\tmi_assert_internal(size \u003e 0 \u0026\u0026 (size % _mi_os_page_size()) \u003d\u003d 0);\n\tmi_assert_internal(is_zero !\u003d NULL);\n\tmi_assert_internal(is_large !\u003d NULL);\n\tif (size \u003d\u003d 0)\n\t\treturn NULL;\n\tif (!commit)\n\t\tallow_large \u003d false;\n\tif (try_alignment \u003d\u003d 0) {\n\t\ttry_alignment \u003d 1;\n\t} // avoid 0 to ensure there will be no divide by zero when aligning\n\n\t*is_zero \u003d false;\n\tvoid* p \u003d NULL;\n\tint err \u003d _mi_prim_alloc(size, try_alignment, commit, allow_large, is_large, is_zero, \u0026p);\n\tif (err !\u003d 0) {\n\t\t_mi_warning_message(\"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, \"\n\t\t\t\t\t\t\t\"align: 0x%zx, commit: %d, allow large: %d)\\n\",\n\t\t\terr, err, size, try_alignment, commit, allow_large);\n\t}\n\tmi_stat_counter_increase(stats-\u003emmap_calls, 1);\n\tif (p !\u003d NULL) {\n\t\t_mi_stat_increase(\u0026stats-\u003ereserved, size);\n\t\tif (commit) {\n\t\t\t_mi_stat_increase(\u0026stats-\u003ecommitted, size);\n// seems needed for asan (or `mimalloc-test-api` fails)\n#ifdef MI_TRACK_ASAN\n\t\t\tif (*is_zero)\n\t\t\t\tmi_track_mem_defined(p, size);\n\t\t\telse\n\t\t\t\tmi_track_mem_undefined(p, size);\n#endif\n\t\t}\n\t}\n\treturn p;\n```",
      "range": {
        "startLine": 190,
        "startChar": 0,
        "endLine": 217,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ac4015d_388c0494",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 242,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void*\nmi_os_prim_alloc_aligned(size_t size, size_t alignment, bool commit, bool allow_large,\n\tbool* is_large, bool* is_zero, void** base, mi_stats_t* stats)\n{\n\tmi_assert_internal(alignment \u003e\u003d _mi_os_page_size() \u0026\u0026 ((alignment \u0026 (alignment - 1)) \u003d\u003d 0));\n\tmi_assert_internal(size \u003e 0 \u0026\u0026 (size % _mi_os_page_size()) \u003d\u003d 0);\n\tmi_assert_internal(is_large !\u003d NULL);\n\tmi_assert_internal(is_zero !\u003d NULL);\n\tmi_assert_internal(base !\u003d NULL);\n\tif (!commit)\n\t\tallow_large \u003d false;\n\tif (!(alignment \u003e\u003d _mi_os_page_size() \u0026\u0026 ((alignment \u0026 (alignment - 1)) \u003d\u003d 0)))\n\t\treturn NULL;\n\tsize \u003d _mi_align_up(size, _mi_os_page_size());\n\n\t// try first with a hint (this will be aligned directly on Win 10+ or BSD)\n\tvoid* p \u003d mi_os_prim_alloc(size, alignment, commit, allow_large, is_large, is_zero, stats);\n\tif (p \u003d\u003d NULL)\n\t\treturn NULL;\n\n\t// aligned already?\n\tif (((uintptr_t)p % alignment) \u003d\u003d 0) {\n\t\t*base \u003d p;\n\t} else {\n\t\t// if not aligned, free it, overallocate, and unmap around it\n```",
      "range": {
        "startLine": 223,
        "startChar": 0,
        "endLine": 242,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "404acdc5_d225fcb2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 286,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t_mi_warning_message(\n\t\t\t\"unable to allocate aligned OS memory directly, fall back to over-allocation (size: \"\n\t\t\t\"0x%zx bytes, address: %p, alignment: 0x%zx, commit: %d)\\n\",\n\t\t\tsize, p, alignment, commit);\n#endif\n\t\tmi_os_prim_free(p, size, commit, stats);\n\t\tif (size \u003e\u003d (SIZE_MAX - alignment))\n\t\t\treturn NULL; // overflow\n\t\tconst size_t over_size \u003d size + alignment;\n\n\t\tif (mi_os_mem_config\n\t\t\t\t.must_free_whole) { // win32 virtualAlloc cannot free parts of an allocate block\n\t\t\t// over-allocate uncommitted (virtual) memory\n\t\t\tp \u003d mi_os_prim_alloc(over_size, 1 /*alignment*/, false /* commit? */,\n\t\t\t\tfalse /* allow_large */, is_large, is_zero, stats);\n\t\t\tif (p \u003d\u003d NULL)\n\t\t\t\treturn NULL;\n\n\t\t\t// set p to the aligned part in the full region\n\t\t\t// note: this is dangerous on Windows as VirtualFree needs the actual base pointer\n\t\t\t// this is handled though by having the `base` field in the memid\u0027s\n\t\t\t*base \u003d p; // remember the base\n\t\t\tp \u003d mi_align_up_ptr(p, alignment);\n\n\t\t\t// explicitly commit only the aligned part\n\t\t\tif (commit)\n\t\t\t\t_mi_os_commit(p, size, NULL, stats);\n\t\t} else { // mmap can free inside an allocation\n\t\t\t// overallocate...\n\t\t\tp \u003d mi_os_prim_alloc(over_size, 1, commit, false, is_large, is_zero, stats);\n\t\t\tif (p \u003d\u003d NULL)\n\t\t\t\treturn NULL;\n\n\t\t\t// and selectively unmap parts around the over-allocated area. (noop on sbrk)\n\t\t\tvoid* aligned_p \u003d mi_align_up_ptr(p, alignment);\n\t\t\tsize_t pre_size \u003d (uint8_t*)aligned_p - (uint8_t*)p;\n\t\t\tsize_t mid_size \u003d _mi_align_up(size, _mi_os_page_size());\n\t\t\tsize_t post_size \u003d over_size - pre_size - mid_size;\n\t\t\tmi_assert_internal(pre_size \u003c over_size \u0026\u0026 post_size \u003c over_size \u0026\u0026 mid_size \u003e\u003d size);\n\t\t\tif (pre_size \u003e 0)\n\t\t\t\tmi_os_prim_free(p, pre_size, commit, stats);\n\t\t\tif (post_size \u003e 0)\n\t\t\t\tmi_os_prim_free((uint8_t*)aligned_p + mid_size, post_size, commit, stats);\n\t\t\t// we can return the aligned pointer on `mmap` (and sbrk) systems\n\t\t\tp \u003d aligned_p;\n\t\t\t*base \u003d aligned_p; // since we freed the pre part, `*base \u003d\u003d p`.\n\t\t}\n\t}\n\n\tmi_assert_internal(\n\t\tp \u003d\u003d NULL || (p !\u003d NULL \u0026\u0026 *base !\u003d NULL \u0026\u0026 ((uintptr_t)p % alignment) \u003d\u003d 0));\n\treturn p;\n```",
      "range": {
        "startLine": 244,
        "startChar": 0,
        "endLine": 286,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1cd54c4a_690f87c0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 327,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid*\n_mi_os_alloc(size_t size, mi_memid_t* memid, mi_stats_t* tld_stats)\n{\n\tMI_UNUSED(tld_stats);\n\t*memid \u003d _mi_memid_none();\n\tmi_stats_t* stats \u003d \u0026_mi_stats_main;\n\tif (size \u003d\u003d 0)\n\t\treturn NULL;\n\tsize \u003d _mi_os_good_alloc_size(size);\n\tbool os_is_large \u003d false;\n\tbool os_is_zero \u003d false;\n\tvoid* p \u003d mi_os_prim_alloc(size, 0, true, false, \u0026os_is_large, \u0026os_is_zero, stats);\n\tif (p !\u003d NULL)\n\t\t*memid \u003d _mi_memid_create_os(true, os_is_zero, os_is_large);\n\treturn p;\n}\n\n\nvoid*\n_mi_os_alloc_aligned(size_t size, size_t alignment, bool commit, bool allow_large,\n\tmi_memid_t* memid, mi_stats_t* tld_stats)\n{\n\tMI_UNUSED(\u0026_mi_os_get_aligned_hint); // suppress unused warnings\n\tMI_UNUSED(tld_stats);\n\t*memid \u003d _mi_memid_none();\n\tif (size \u003d\u003d 0)\n\t\treturn NULL;\n\tsize \u003d _mi_os_good_alloc_size(size);\n\talignment \u003d _mi_align_up(alignment, _mi_os_page_size());\n\n\tbool os_is_large \u003d false;\n\tbool os_is_zero \u003d false;\n\tvoid* os_base \u003d NULL;\n\tvoid* p \u003d mi_os_prim_alloc_aligned(size, alignment, commit, allow_large, \u0026os_is_large,\n\t\t\u0026os_is_zero, \u0026os_base, \u0026_mi_stats_main /*tld-\u003estats*/);\n\tif (p !\u003d NULL) {\n\t\t*memid \u003d _mi_memid_create_os(commit, os_is_zero, os_is_large);\n\t\tmemid-\u003emem.os.base \u003d os_base;\n\t\tmemid-\u003emem.os.alignment \u003d alignment;\n\t}\n\treturn p;\n```",
      "range": {
        "startLine": 294,
        "startChar": 0,
        "endLine": 327,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf0adcec_62a046c0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 362,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid*\n_mi_os_alloc_aligned_at_offset(size_t size, size_t alignment, size_t offset, bool commit,\n\tbool allow_large, mi_memid_t* memid, mi_stats_t* tld_stats)\n{\n\tmi_assert(offset \u003c\u003d MI_SEGMENT_SIZE);\n\tmi_assert(offset \u003c\u003d size);\n\tmi_assert((alignment % _mi_os_page_size()) \u003d\u003d 0);\n\t*memid \u003d _mi_memid_none();\n\tif (offset \u003e MI_SEGMENT_SIZE)\n\t\treturn NULL;\n\tif (offset \u003d\u003d 0) {\n\t\t// regular aligned allocation\n\t\treturn _mi_os_alloc_aligned(size, alignment, commit, allow_large, memid, tld_stats);\n\t} else {\n\t\t// overallocate to align at an offset\n\t\tconst size_t extra \u003d _mi_align_up(offset, alignment) - offset;\n\t\tconst size_t oversize \u003d size + extra;\n\t\tvoid* const start\n\t\t\t\u003d _mi_os_alloc_aligned(oversize, alignment, commit, allow_large, memid, tld_stats);\n\t\tif (start \u003d\u003d NULL)\n\t\t\treturn NULL;\n\n\t\tvoid* const p \u003d (uint8_t*)start + extra;\n\t\tmi_assert(_mi_is_aligned((uint8_t*)p + offset, alignment));\n\t\t// decommit the overallocation at the start\n\t\tif (commit \u0026\u0026 extra \u003e _mi_os_page_size())\n\t\t\t_mi_os_decommit(start, extra, tld_stats);\n\t\treturn p;\n\t}\n```",
      "range": {
        "startLine": 338,
        "startChar": 0,
        "endLine": 362,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "31a941cd_06284d54",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 447,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void*\nmi_os_page_align_areax(bool conservative, void* addr, size_t size, size_t* newsize)\n{\n\tmi_assert(addr !\u003d NULL \u0026\u0026 size \u003e 0);\n\tif (newsize !\u003d NULL)\n\t\t*newsize \u003d 0;\n\tif (size \u003d\u003d 0 || addr \u003d\u003d NULL)\n\t\treturn NULL;\n\n\t// page align conservatively within the range\n\tvoid* start \u003d (conservative ? mi_align_up_ptr(addr, _mi_os_page_size())\n\t\t\t\t\t\t\t\t: mi_align_down_ptr(addr, _mi_os_page_size()));\n\tvoid* end \u003d (conservative ? mi_align_down_ptr((uint8_t*)addr + size, _mi_os_page_size())\n\t\t\t\t\t\t\t  : mi_align_up_ptr((uint8_t*)addr + size, _mi_os_page_size()));\n\tptrdiff_t diff \u003d (uint8_t*)end - (uint8_t*)start;\n\tif (diff \u003c\u003d 0)\n\t\treturn NULL;\n\n\tmi_assert_internal(\n\t\t(conservative \u0026\u0026 (size_t)diff \u003c\u003d size) || (!conservative \u0026\u0026 (size_t)diff \u003e\u003d size));\n\tif (newsize !\u003d NULL)\n\t\t*newsize \u003d (size_t)diff;\n\treturn start;\n}\n\n\nstatic void*\nmi_os_page_align_area_conservative(void* addr, size_t size, size_t* newsize)\n{\n\treturn mi_os_page_align_areax(true, addr, size, newsize);\n}\n\n\nbool\n_mi_os_commit(void* addr, size_t size, bool* is_zero, mi_stats_t* tld_stats)\n{\n\tMI_UNUSED(tld_stats);\n\tmi_stats_t* stats \u003d \u0026_mi_stats_main;\n\tif (is_zero !\u003d NULL)\n\t\t*is_zero \u003d false;\n\t_mi_stat_increase(\u0026stats-\u003ecommitted, size); // use size for precise commit vs. decommit\n\t_mi_stat_counter_increase(\u0026stats-\u003ecommit_calls, 1);\n\n\t// page align range\n\tsize_t csize;\n\tvoid* start \u003d mi_os_page_align_areax(false /* conservative? */, addr, size, \u0026csize);\n\tif (csize \u003d\u003d 0)\n\t\treturn true;\n\n\t// commit\n\tbool os_is_zero \u003d false;\n\tint err \u003d _mi_prim_commit(start, csize, \u0026os_is_zero);\n\tif (err !\u003d 0) {\n\t\t_mi_warning_message(\n\t\t\t\"cannot commit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", err,\n\t\t\terr, start, csize);\n\t\treturn false;\n\t}\n\tif (os_is_zero \u0026\u0026 is_zero !\u003d NULL) {\n\t\t*is_zero \u003d true;\n\t\tmi_assert_expensive(mi_mem_is_zero(start, csize));\n\t}\n// note: the following seems required for asan (otherwise `mimalloc-test-stress` fails)\n#ifdef MI_TRACK_ASAN\n\tif (os_is_zero)\n\t\tmi_track_mem_defined(start, csize);\n\telse\n\t\tmi_track_mem_undefined(start, csize);\n#endif\n\treturn true;\n}\n\n\nstatic bool\nmi_os_decommit_ex(void* addr, size_t size, bool* needs_recommit, mi_stats_t* tld_stats)\n{\n\tMI_UNUSED(tld_stats);\n\tmi_stats_t* stats \u003d \u0026_mi_stats_main;\n\tmi_assert_internal(needs_recommit !\u003d NULL);\n\t_mi_stat_decrease(\u0026stats-\u003ecommitted, size);\n\n\t// page align\n\tsize_t csize;\n\tvoid* start \u003d mi_os_page_align_area_conservative(addr, size, \u0026csize);\n\tif (csize \u003d\u003d 0)\n\t\treturn true;\n\n\t// decommit\n\t*needs_recommit \u003d true;\n\tint err \u003d _mi_prim_decommit(start, csize, needs_recommit);\n\tif (err !\u003d 0) {\n\t\t_mi_warning_message(\n\t\t\t\"cannot decommit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", err,\n\t\t\terr, start, csize);\n\t}\n\tmi_assert_internal(err \u003d\u003d 0);\n\treturn err \u003d\u003d 0;\n}\n\n\nbool\n_mi_os_decommit(void* addr, size_t size, mi_stats_t* tld_stats)\n{\n\tbool needs_recommit;\n\treturn mi_os_decommit_ex(addr, size, \u0026needs_recommit, tld_stats);\n```",
      "range": {
        "startLine": 371,
        "startChar": 0,
        "endLine": 447,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1527eead_974dca81",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 471,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_os_reset(void* addr, size_t size, mi_stats_t* stats)\n{\n\t// page align conservatively within the range\n\tsize_t csize;\n\tvoid* start \u003d mi_os_page_align_area_conservative(addr, size, \u0026csize);\n\tif (csize \u003d\u003d 0)\n\t\treturn true; // || _mi_os_is_huge_reserved(addr)\n\t_mi_stat_increase(\u0026stats-\u003ereset, csize);\n\t_mi_stat_counter_increase(\u0026stats-\u003ereset_calls, 1);\n\n#if (MI_DEBUG \u003e 1) \u0026\u0026 !MI_SECURE \u0026\u0026 !MI_TRACK_ENABLED // \u0026\u0026 !MI_TSAN\n\tmemset(start, 0, csize); // pretend it is eagerly reset\n#endif\n\n\tint err \u003d _mi_prim_reset(start, csize);\n\tif (err !\u003d 0) {\n\t\t_mi_warning_message(\n\t\t\t\"cannot reset OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", err, err,\n\t\t\tstart, csize);\n\t}\n\treturn err \u003d\u003d 0;\n```",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 471,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7201a824_817c749a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 495,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_os_purge_ex(void* p, size_t size, bool allow_reset, mi_stats_t* stats)\n{\n\tif (mi_option_get(mi_option_purge_delay) \u003c 0)\n\t\treturn false; // is purging allowed?\n\t_mi_stat_counter_increase(\u0026stats-\u003epurge_calls, 1);\n\t_mi_stat_increase(\u0026stats-\u003epurged, size);\n\n\tif (mi_option_is_enabled(mi_option_purge_decommits) \u0026\u0026 // should decommit?\n\t\t!_mi_preloading()) // don\u0027t decommit during preloading (unsafe)\n\t{\n\t\tbool needs_recommit \u003d true;\n\t\tmi_os_decommit_ex(p, size, \u0026needs_recommit, stats);\n\t\treturn needs_recommit;\n\t} else {\n\t\tif (allow_reset) // this can sometimes be not allowed if the range is not fully committed\n\t\t\t_mi_os_reset(p, size, stats);\n\t\treturn false; // needs no recommit\n\t}\n```",
      "range": {
        "startLine": 477,
        "startChar": 0,
        "endLine": 495,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a359887_3b2a225c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 501,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_os_purge(void* p, size_t size, mi_stats_t* stats)\n{\n\treturn _mi_os_purge_ex(p, size, true, stats);\n```",
      "range": {
        "startLine": 500,
        "startChar": 0,
        "endLine": 501,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "60c38876_248232e5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 529,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_os_protectx(void* addr, size_t size, bool protect)\n{\n\t// page align conservatively within the range\n\tsize_t csize \u003d 0;\n\tvoid* start \u003d mi_os_page_align_area_conservative(addr, size, \u0026csize);\n\tif (csize \u003d\u003d 0)\n\t\treturn false;\n\t/*\n\tif (_mi_os_is_huge_reserved(addr)) {\n\t\t_mi_warning_message(\"cannot mprotect memory allocated in huge OS pages\\n\");\n\t}\n\t*/\n\tint err \u003d _mi_prim_protect(start, csize, protect);\n\tif (err !\u003d 0) {\n\t\t_mi_warning_message(\n\t\t\t\"cannot %s OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\",\n\t\t\t(protect ? \"protect\" : \"unprotect\"), err, err, start, csize);\n\t}\n\treturn err \u003d\u003d 0;\n}\n\n\nbool\n_mi_os_protect(void* addr, size_t size)\n{\n\treturn mi_os_protectx(addr, size, true);\n}\n\n\nbool\n_mi_os_unprotect(void* addr, size_t size)\n{\n\treturn mi_os_protectx(addr, size, false);\n}\n```",
      "range": {
        "startLine": 505,
        "startChar": 0,
        "endLine": 529,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40a94430_435b3b4f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 536,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_HUGE_OS_PAGE_SIZE (MI_GiB)\n```",
      "range": {
        "startLine": 536,
        "startChar": 0,
        "endLine": 536,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "68a084ce_87651906",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 541,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_cache_align _Atomic(uintptr_t) mi_huge_start; // \u003d 0\n```",
      "range": {
        "startLine": 541,
        "startChar": 0,
        "endLine": 541,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26f2d80e_3d762a77",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 566,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic uint8_t*\nmi_os_claim_huge_pages(size_t pages, size_t* total_size)\n{\n\tif (total_size !\u003d NULL)\n\t\t*total_size \u003d 0;\n\tconst size_t size \u003d pages * MI_HUGE_OS_PAGE_SIZE;\n\n\tuintptr_t start \u003d 0;\n\tuintptr_t end \u003d 0;\n\tuintptr_t huge_start \u003d mi_atomic_load_relaxed(\u0026mi_huge_start);\n\tdo {\n\t\tstart \u003d huge_start;\n\t\tif (start \u003d\u003d 0) {\n\t\t\t// Initialize the start address after the 32TiB area\n\t\t\tstart \u003d ((uintptr_t)32 \u003c\u003c 40); // 32TiB virtual start address\n#if (MI_SECURE \u003e 0 || MI_DEBUG \u003d\u003d 0) // security: randomize start of huge pages unless in debug mode\n\t\t\tuintptr_t r \u003d _mi_heap_random_next(mi_prim_get_default_heap());\n\t\t\tstart \u003d start\n\t\t\t\t+ ((uintptr_t)MI_HUGE_OS_PAGE_SIZE\n\t\t\t\t\t* ((r \u003e\u003e 17) \u0026 0x0FFF)); // (randomly 12bits)*1GiB \u003d\u003d between 0 to 4TiB\n#endif\n\t\t}\n\t\tend \u003d start + size;\n\t\tmi_assert_internal(end % MI_SEGMENT_SIZE \u003d\u003d 0);\n\t} while (!mi_atomic_cas_strong_acq_rel(\u0026mi_huge_start, \u0026huge_start, end));\n\n\tif (total_size !\u003d NULL)\n\t\t*total_size \u003d size;\n\treturn (uint8_t*)start;\n```",
      "range": {
        "startLine": 544,
        "startChar": 0,
        "endLine": 566,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a100806_cf4c5de3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 572,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic uint8_t*\nmi_os_claim_huge_pages(size_t pages, size_t* total_size)\n{\n\tMI_UNUSED(pages);\n\tif (total_size !\u003d NULL)\n\t\t*total_size \u003d 0;\n\treturn NULL;\n```",
      "range": {
        "startLine": 569,
        "startChar": 0,
        "endLine": 572,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8fb98cd5_df5a065b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 645,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid*\n_mi_os_alloc_huge_os_pages(size_t pages, int numa_node, mi_msecs_t max_msecs,\n\tsize_t* pages_reserved, size_t* psize, mi_memid_t* memid)\n{\n\t*memid \u003d _mi_memid_none();\n\tif (psize !\u003d NULL)\n\t\t*psize \u003d 0;\n\tif (pages_reserved !\u003d NULL)\n\t\t*pages_reserved \u003d 0;\n\tsize_t size \u003d 0;\n\tuint8_t* start \u003d mi_os_claim_huge_pages(pages, \u0026size);\n\tif (start \u003d\u003d NULL)\n\t\treturn NULL; // or 32-bit systems\n\n\t// Allocate one page at the time but try to place them contiguously\n\t// We allocate one page at the time to be able to abort if it takes too long\n\t// or to at least allocate as many as available on the system.\n\tmi_msecs_t start_t \u003d _mi_clock_start();\n\tsize_t page \u003d 0;\n\tbool all_zero \u003d true;\n\twhile (page \u003c pages) {\n\t\t// allocate a page\n\t\tbool is_zero \u003d false;\n\t\tvoid* addr \u003d start + (page * MI_HUGE_OS_PAGE_SIZE);\n\t\tvoid* p \u003d NULL;\n\t\tint err \u003d _mi_prim_alloc_huge_os_pages(addr, MI_HUGE_OS_PAGE_SIZE, numa_node, \u0026is_zero, \u0026p);\n\t\tif (!is_zero)\n\t\t\tall_zero \u003d false;\n\t\tif (err !\u003d 0) {\n\t\t\t_mi_warning_message(\"unable to allocate huge OS page (error: %d (0x%x), address: %p, \"\n\t\t\t\t\t\t\t\t\"size: %zx bytes)\\n\",\n\t\t\t\terr, err, addr, MI_HUGE_OS_PAGE_SIZE);\n\t\t\tbreak;\n\t\t}\n\n\t\t// Did we succeed at a contiguous address?\n\t\tif (p !\u003d addr) {\n\t\t\t// no success, issue a warning and break\n\t\t\tif (p !\u003d NULL) {\n\t\t\t\t_mi_warning_message(\"could not allocate contiguous huge OS page %zu at %p\\n\", page,\n\t\t\t\t\taddr);\n\t\t\t\tmi_os_prim_free(p, MI_HUGE_OS_PAGE_SIZE, true, \u0026_mi_stats_main);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// success, record it\n\t\tpage++; // increase before timeout check (see issue #711)\n\t\t_mi_stat_increase(\u0026_mi_stats_main.committed, MI_HUGE_OS_PAGE_SIZE);\n\t\t_mi_stat_increase(\u0026_mi_stats_main.reserved, MI_HUGE_OS_PAGE_SIZE);\n\n\t\t// check for timeout\n\t\tif (max_msecs \u003e 0) {\n\t\t\tmi_msecs_t elapsed \u003d _mi_clock_end(start_t);\n\t\t\tif (page \u003e\u003d 1) {\n\t\t\t\tmi_msecs_t estimate \u003d ((elapsed / (page + 1)) * pages);\n\t\t\t\tif (estimate \u003e 2 * max_msecs) // seems like we are going to timeout, break\n\t\t\t\t\telapsed \u003d max_msecs + 1;\n\t\t\t}\n\t\t\tif (elapsed \u003e max_msecs) {\n\t\t\t\t_mi_warning_message(\n\t\t\t\t\t\"huge OS page allocation timed out (after allocating %zu page(s))\\n\", page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmi_assert_internal(page * MI_HUGE_OS_PAGE_SIZE \u003c\u003d size);\n\tif (pages_reserved !\u003d NULL)\n\t\t*pages_reserved \u003d page;\n\tif (psize !\u003d NULL)\n\t\t*psize \u003d page * MI_HUGE_OS_PAGE_SIZE;\n\tif (page !\u003d 0) {\n\t\tmi_assert(start !\u003d NULL);\n\t\t*memid \u003d _mi_memid_create_os(true /* is committed */, all_zero, true /* is_large */);\n\t\tmemid-\u003ememkind \u003d MI_MEM_OS_HUGE;\n\t\tmi_assert(memid-\u003eis_pinned);\n#ifdef MI_TRACK_ASAN\n\t\tif (all_zero)\n\t\t\tmi_track_mem_defined(start, size);\n#endif\n\t}\n\treturn page \u003d\u003d 0 ? NULL : start;\n```",
      "range": {
        "startLine": 577,
        "startChar": 0,
        "endLine": 645,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ffcc23d2_2c249522",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 657,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_os_free_huge_os_pages(void* p, size_t size, mi_stats_t* stats)\n{\n\tif (p \u003d\u003d NULL || size \u003d\u003d 0)\n\t\treturn;\n\tuint8_t* base \u003d (uint8_t*)p;\n\twhile (size \u003e\u003d MI_HUGE_OS_PAGE_SIZE) {\n\t\tmi_os_prim_free(base, MI_HUGE_OS_PAGE_SIZE, true, stats);\n\t\tsize -\u003d MI_HUGE_OS_PAGE_SIZE;\n\t\tbase +\u003d MI_HUGE_OS_PAGE_SIZE;\n\t}\n```",
      "range": {
        "startLine": 650,
        "startChar": 0,
        "endLine": 657,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6da4e65a_3c233bf5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/os.c",
        "patchSetId": 7
      },
      "lineNbr": 691,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n_Atomic(size_t) _mi_numa_node_count; // \u003d 0   // cache the node count\n\n\nsize_t\n_mi_os_numa_node_count_get(void)\n{\n\tsize_t count \u003d mi_atomic_load_acquire(\u0026_mi_numa_node_count);\n\tif (count \u003c\u003d 0) {\n\t\tlong ncount \u003d mi_option_get(mi_option_use_numa_nodes); // given explicitly?\n\t\tif (ncount \u003e 0) {\n\t\t\tcount \u003d (size_t)ncount;\n\t\t} else {\n\t\t\tcount \u003d _mi_prim_numa_node_count(); // or detect dynamically\n\t\t\tif (count \u003d\u003d 0)\n\t\t\t\tcount \u003d 1;\n\t\t}\n\t\tmi_atomic_store_release(\u0026_mi_numa_node_count, count); // save it\n\t\t_mi_verbose_message(\"using %zd numa regions\\n\", count);\n\t}\n\treturn count;\n}\n\n\nint\n_mi_os_numa_node_get(mi_os_tld_t* tld)\n{\n\tMI_UNUSED(tld);\n\tsize_t numa_count \u003d _mi_os_numa_node_count();\n\tif (numa_count \u003c\u003d 1)\n\t\treturn 0; // optimize on single numa node systems: always node 0\n\t// never more than the node count and \u003e\u003d 0\n\tsize_t numa_node \u003d _mi_prim_numa_node();\n\tif (numa_node \u003e\u003d numa_count)\n\t\tnuma_node \u003d numa_node % numa_count;\n\treturn (int)numa_node;\n}\n```",
      "range": {
        "startLine": 664,
        "startChar": 0,
        "endLine": 691,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d79edb90_7ad922bb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 23,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_MAX_ALIGN_SIZE \u003e 4 * MI_INTPTR_SIZE)\n#error \"define alignment for more than 4x word size for this platform\"\n#elif (MI_MAX_ALIGN_SIZE \u003e 2 * MI_INTPTR_SIZE)\n#define MI_ALIGN4W // 4 machine words minimal alignment\n```",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 23,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b4f4d04_7ede5c09",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 25,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_ALIGN2W // 2 machine words minimal alignment\n```",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "87a3df59_4b16c3e7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 27,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// ok, default alignment is 1 word\n```",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 27,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff0b0cf3_98566766",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 45,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline bool\nmi_page_queue_is_huge(const mi_page_queue_t* pq)\n{\n\treturn pq-\u003eblock_size \u003d\u003d (MI_MEDIUM_OBJ_SIZE_MAX + sizeof(uintptr_t));\n}\n\n\nstatic inline bool\nmi_page_queue_is_full(const mi_page_queue_t* pq)\n{\n\treturn pq-\u003eblock_size \u003d\u003d (MI_MEDIUM_OBJ_SIZE_MAX + (2 * sizeof(uintptr_t)));\n}\n\n\nstatic inline bool\nmi_page_queue_is_special(const mi_page_queue_t* pq)\n{\n\treturn pq-\u003eblock_size \u003e MI_MEDIUM_OBJ_SIZE_MAX;\n```",
      "range": {
        "startLine": 36,
        "startChar": 0,
        "endLine": 45,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bfd7d91b_e18687f4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 94,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline uint8_t\nmi_bin(size_t size)\n{\n\tsize_t wsize \u003d _mi_wsize_from_size(size);\n\tuint8_t bin;\n\tif (wsize \u003c\u003d 1) {\n\t\tbin \u003d 1;\n\t}\n#if defined(MI_ALIGN4W)\n\telse if (wsize \u003c\u003d 4) {\n\t\tbin \u003d (uint8_t)((wsize + 1) \u0026 ~1); // round to double word sizes\n\t}\n#elif defined(MI_ALIGN2W)\n\telse if (wsize \u003c\u003d 8) {\n\t\tbin \u003d (uint8_t)((wsize + 1) \u0026 ~1); // round to double word sizes\n\t}\n#else\n\telse if (wsize \u003c\u003d 8) {\n\t\tbin \u003d (uint8_t)wsize;\n\t}\n#endif\n\telse if (wsize \u003e MI_MEDIUM_OBJ_WSIZE_MAX) {\n\t\tbin \u003d MI_BIN_HUGE;\n\t} else {\n#if defined(MI_ALIGN4W)\n\t\tif (wsize \u003c\u003d 16) {\n\t\t\twsize \u003d (wsize + 3) \u0026 ~3;\n\t\t} // round to 4x word sizes\n#endif\n\t\twsize--;\n\t\t// find the highest bit\n\t\tuint8_t b \u003d (uint8_t)mi_bsr(wsize); // note: wsize !\u003d 0\n\t\t// and use the top 3 bits to determine the bin (~12.5% worst internal fragmentation).\n\t\t// - adjust with 3 because we use do not round the first 8 sizes\n\t\t//   which each get an exact bin\n\t\tbin \u003d ((b \u003c\u003c 2) + (uint8_t)((wsize \u003e\u003e (b - 2)) \u0026 0x03)) - 3;\n\t\tmi_assert_internal(bin \u003c MI_BIN_HUGE);\n\t}\n\tmi_assert_internal(bin \u003e 0 \u0026\u0026 bin \u003c\u003d MI_BIN_HUGE);\n\treturn bin;\n}\n```",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 94,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7332bb58_5dfd8ebb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 106,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nuint8_t\n_mi_bin(size_t size)\n{\n\treturn mi_bin(size);\n}\n\n\nsize_t\n_mi_bin_size(uint8_t bin)\n{\n\treturn _mi_heap_empty.pages[bin].block_size;\n```",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 106,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cb44f121_cb69bfb7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 155,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nsize_t\nmi_good_size(size_t size) mi_attr_noexcept\n{\n\tif (size \u003c\u003d MI_MEDIUM_OBJ_SIZE_MAX)\n\t\treturn _mi_bin_size(mi_bin(size));\n\telse\n\t\treturn _mi_align_up(size, _mi_os_page_size());\n}\n\n#if (MI_DEBUG \u003e 1)\n\n\nstatic bool\nmi_page_queue_contains(mi_page_queue_t* queue, const mi_page_t* page)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_page_t* list \u003d queue-\u003efirst;\n\twhile (list !\u003d NULL) {\n\t\tmi_assert_internal(list-\u003enext \u003d\u003d NULL || list-\u003enext-\u003eprev \u003d\u003d list);\n\t\tmi_assert_internal(list-\u003eprev \u003d\u003d NULL || list-\u003eprev-\u003enext \u003d\u003d list);\n\t\tif (list \u003d\u003d page)\n\t\t\tbreak;\n\t\tlist \u003d list-\u003enext;\n\t}\n\treturn list \u003d\u003d page;\n}\n\n#endif\n\n#if (MI_DEBUG \u003e 1)\n\n\nstatic bool\nmi_heap_contains_queue(const mi_heap_t* heap, const mi_page_queue_t* pq)\n{\n\treturn pq \u003e\u003d \u0026heap-\u003epages[0] \u0026\u0026 pq \u003c\u003d \u0026heap-\u003epages[MI_BIN_FULL];\n}\n#endif\n\n\nstatic mi_page_queue_t*\nmi_page_queue_of(const mi_page_t* page)\n{\n\tuint8_t bin \u003d (mi_page_is_in_full(page) ? MI_BIN_FULL : mi_bin(page-\u003exblock_size));\n\tmi_heap_t* heap \u003d mi_page_heap(page);\n\tmi_assert_internal(heap !\u003d NULL \u0026\u0026 bin \u003c\u003d MI_BIN_FULL);\n\tmi_page_queue_t* pq \u003d \u0026heap-\u003epages[bin];\n\tmi_assert_internal(bin \u003e\u003d MI_BIN_HUGE || page-\u003exblock_size \u003d\u003d pq-\u003eblock_size);\n\tmi_assert_expensive(mi_page_queue_contains(pq, page));\n\treturn pq;\n}\n\n\nstatic mi_page_queue_t*\nmi_heap_page_queue_of(mi_heap_t* heap, const mi_page_t* page)\n{\n\tuint8_t bin \u003d (mi_page_is_in_full(page) ? MI_BIN_FULL : mi_bin(page-\u003exblock_size));\n\tmi_assert_internal(bin \u003c\u003d MI_BIN_FULL);\n\tmi_page_queue_t* pq \u003d \u0026heap-\u003epages[bin];\n\tmi_assert_internal(mi_page_is_in_full(page) || page-\u003exblock_size \u003d\u003d pq-\u003eblock_size);\n\treturn pq;\n```",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 155,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e6f9a30_841397c9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 197,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline void\nmi_heap_queue_first_update(mi_heap_t* heap, const mi_page_queue_t* pq)\n{\n\tmi_assert_internal(mi_heap_contains_queue(heap, pq));\n\tsize_t size \u003d pq-\u003eblock_size;\n\tif (size \u003e MI_SMALL_SIZE_MAX)\n\t\treturn;\n\n\tmi_page_t* page \u003d pq-\u003efirst;\n\tif (pq-\u003efirst \u003d\u003d NULL)\n\t\tpage \u003d (mi_page_t*)\u0026_mi_page_empty;\n\n\t// find index in the right direct page array\n\tsize_t start;\n\tsize_t idx \u003d _mi_wsize_from_size(size);\n\tmi_page_t** pages_free \u003d heap-\u003epages_free_direct;\n\n\tif (pages_free[idx] \u003d\u003d page)\n\t\treturn; // already set\n\n\t// find start slot\n\tif (idx \u003c\u003d 1) {\n\t\tstart \u003d 0;\n\t} else {\n\t\t// find previous size; due to minimal alignment upto 3 previous bins may need to be skipped\n\t\tuint8_t bin \u003d mi_bin(size);\n\t\tconst mi_page_queue_t* prev \u003d pq - 1;\n\t\twhile (bin \u003d\u003d mi_bin(prev-\u003eblock_size) \u0026\u0026 prev \u003e \u0026heap-\u003epages[0])\n\t\t\tprev--;\n\t\tstart \u003d 1 + _mi_wsize_from_size(prev-\u003eblock_size);\n\t\tif (start \u003e idx)\n\t\t\tstart \u003d idx;\n\t}\n\n\t// set size range to the right page\n\tmi_assert(start \u003c\u003d idx);\n\tfor (size_t sz \u003d start; sz \u003c\u003d idx; sz++)\n\t\tpages_free[sz] \u003d page;\n```",
      "range": {
        "startLine": 163,
        "startChar": 0,
        "endLine": 197,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad1f762c_d9681f09",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 293,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_page_queue_remove(mi_page_queue_t* queue, mi_page_t* page)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_assert_expensive(mi_page_queue_contains(queue, page));\n\tmi_assert_internal(page-\u003exblock_size \u003d\u003d queue-\u003eblock_size\n\t\t|| (page-\u003exblock_size \u003e MI_MEDIUM_OBJ_SIZE_MAX \u0026\u0026 mi_page_queue_is_huge(queue))\n\t\t|| (mi_page_is_in_full(page) \u0026\u0026 mi_page_queue_is_full(queue)));\n\tmi_heap_t* heap \u003d mi_page_heap(page);\n\n\tif (page-\u003eprev !\u003d NULL)\n\t\tpage-\u003eprev-\u003enext \u003d page-\u003enext;\n\tif (page-\u003enext !\u003d NULL)\n\t\tpage-\u003enext-\u003eprev \u003d page-\u003eprev;\n\tif (page \u003d\u003d queue-\u003elast)\n\t\tqueue-\u003elast \u003d page-\u003eprev;\n\tif (page \u003d\u003d queue-\u003efirst) {\n\t\tqueue-\u003efirst \u003d page-\u003enext;\n\t\t// update first\n\t\tmi_assert_internal(mi_heap_contains_queue(heap, queue));\n\t\tmi_heap_queue_first_update(heap, queue);\n\t}\n\theap-\u003epage_count--;\n\tpage-\u003enext \u003d NULL;\n\tpage-\u003eprev \u003d NULL;\n\t// mi_atomic_store_ptr_release(mi_atomic_cast(void*, \u0026page-\u003eheap), NULL);\n\tmi_page_set_in_full(page, false);\n}\n\n\nstatic void\nmi_page_queue_push(mi_heap_t* heap, mi_page_queue_t* queue, mi_page_t* page)\n{\n\tmi_assert_internal(mi_page_heap(page) \u003d\u003d heap);\n\tmi_assert_internal(!mi_page_queue_contains(queue, page));\n#if MI_HUGE_PAGE_ABANDON\n\tmi_assert_internal(_mi_page_segment(page)-\u003ekind !\u003d MI_SEGMENT_HUGE);\n#endif\n\tmi_assert_internal(page-\u003exblock_size \u003d\u003d queue-\u003eblock_size\n\t\t|| (page-\u003exblock_size \u003e MI_MEDIUM_OBJ_SIZE_MAX)\n\t\t|| (mi_page_is_in_full(page) \u0026\u0026 mi_page_queue_is_full(queue)));\n\n\tmi_page_set_in_full(page, mi_page_queue_is_full(queue));\n\t// mi_atomic_store_ptr_release(mi_atomic_cast(void*, \u0026page-\u003eheap), heap);\n\tpage-\u003enext \u003d queue-\u003efirst;\n\tpage-\u003eprev \u003d NULL;\n\tif (queue-\u003efirst !\u003d NULL) {\n\t\tmi_assert_internal(queue-\u003efirst-\u003eprev \u003d\u003d NULL);\n\t\tqueue-\u003efirst-\u003eprev \u003d page;\n\t\tqueue-\u003efirst \u003d page;\n\t} else {\n\t\tqueue-\u003efirst \u003d queue-\u003elast \u003d page;\n\t}\n\n\t// update direct\n\tmi_heap_queue_first_update(heap, queue);\n\theap-\u003epage_count++;\n}\n\n\nstatic void\nmi_page_queue_enqueue_from(mi_page_queue_t* to, mi_page_queue_t* from, mi_page_t* page)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_assert_expensive(mi_page_queue_contains(from, page));\n\tmi_assert_expensive(!mi_page_queue_contains(to, page));\n\n\tmi_assert_internal(\n\t\t(page-\u003exblock_size \u003d\u003d to-\u003eblock_size \u0026\u0026 page-\u003exblock_size \u003d\u003d from-\u003eblock_size)\n\t\t|| (page-\u003exblock_size \u003d\u003d to-\u003eblock_size \u0026\u0026 mi_page_queue_is_full(from))\n\t\t|| (page-\u003exblock_size \u003d\u003d from-\u003eblock_size \u0026\u0026 mi_page_queue_is_full(to))\n\t\t|| (page-\u003exblock_size \u003e MI_LARGE_OBJ_SIZE_MAX \u0026\u0026 mi_page_queue_is_huge(to))\n\t\t|| (page-\u003exblock_size \u003e MI_LARGE_OBJ_SIZE_MAX \u0026\u0026 mi_page_queue_is_full(to)));\n\n\tmi_heap_t* heap \u003d mi_page_heap(page);\n\tif (page-\u003eprev !\u003d NULL)\n\t\tpage-\u003eprev-\u003enext \u003d page-\u003enext;\n\tif (page-\u003enext !\u003d NULL)\n\t\tpage-\u003enext-\u003eprev \u003d page-\u003eprev;\n\tif (page \u003d\u003d from-\u003elast)\n\t\tfrom-\u003elast \u003d page-\u003eprev;\n\tif (page \u003d\u003d from-\u003efirst) {\n\t\tfrom-\u003efirst \u003d page-\u003enext;\n\t\t// update first\n\t\tmi_assert_internal(mi_heap_contains_queue(heap, from));\n\t\tmi_heap_queue_first_update(heap, from);\n\t}\n\n\tpage-\u003eprev \u003d to-\u003elast;\n\tpage-\u003enext \u003d NULL;\n\tif (to-\u003elast !\u003d NULL) {\n\t\tmi_assert_internal(heap \u003d\u003d mi_page_heap(to-\u003elast));\n\t\tto-\u003elast-\u003enext \u003d page;\n\t\tto-\u003elast \u003d page;\n\t} else {\n\t\tto-\u003efirst \u003d page;\n\t\tto-\u003elast \u003d page;\n\t\tmi_heap_queue_first_update(heap, to);\n\t}\n\n\tmi_page_set_in_full(page, mi_page_queue_is_full(to));\n```",
      "range": {
        "startLine": 206,
        "startChar": 0,
        "endLine": 293,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e3310759_0ea0d5c9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page-queue.c",
        "patchSetId": 7
      },
      "lineNbr": 332,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nsize_t\n_mi_page_queue_append(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_queue_t* append)\n{\n\tmi_assert_internal(mi_heap_contains_queue(heap, pq));\n\tmi_assert_internal(pq-\u003eblock_size \u003d\u003d append-\u003eblock_size);\n\n\tif (append-\u003efirst \u003d\u003d NULL)\n\t\treturn 0;\n\n\t// set append pages to new heap and count\n\tsize_t count \u003d 0;\n\tfor (mi_page_t* page \u003d append-\u003efirst; page !\u003d NULL; page \u003d page-\u003enext) {\n\t\t// inline `mi_page_set_heap` to avoid wrong assertion during absorption;\n\t\t// in this case it is ok to be delayed freeing since both \"to\" and \"from\" heap are still\n\t\t// alive.\n\t\tmi_atomic_store_release(\u0026page-\u003exheap, (uintptr_t)heap);\n\t\t// set the flag to delayed free (not overriding NEVER_DELAYED_FREE) which has as a\n\t\t// side effect that it spins until any DELAYED_FREEING is finished. This ensures\n\t\t// that after appending only the new heap will be used for delayed free operations.\n\t\t_mi_page_use_delayed_free(page, MI_USE_DELAYED_FREE, false);\n\t\tcount++;\n\t}\n\n\tif (pq-\u003elast \u003d\u003d NULL) {\n\t\t// take over afresh\n\t\tmi_assert_internal(pq-\u003efirst \u003d\u003d NULL);\n\t\tpq-\u003efirst \u003d append-\u003efirst;\n\t\tpq-\u003elast \u003d append-\u003elast;\n\t\tmi_heap_queue_first_update(heap, pq);\n\t} else {\n\t\t// append to end\n\t\tmi_assert_internal(pq-\u003elast !\u003d NULL);\n\t\tmi_assert_internal(append-\u003efirst !\u003d NULL);\n\t\tpq-\u003elast-\u003enext \u003d append-\u003efirst;\n\t\tappend-\u003efirst-\u003eprev \u003d pq-\u003elast;\n\t\tpq-\u003elast \u003d append-\u003elast;\n\t}\n\treturn count;\n}\n```",
      "range": {
        "startLine": 297,
        "startChar": 0,
        "endLine": 332,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af2feca0_79a9588b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 14,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "294d87fc_0ff629eb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a886b3d8_3f15424d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 36,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_block_t*\nmi_page_block_at(const mi_page_t* page, void* page_start, size_t block_size, size_t i)\n{\n\tMI_UNUSED(page);\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_assert_internal(i \u003c\u003d page-\u003ereserved);\n\treturn (mi_block_t*)((uint8_t*)page_start + (i * block_size));\n```",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 36,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dcf49575_5b0f7684",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 50,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_DEBUG \u003e\u003d 3)\n\n\nstatic size_t\nmi_page_list_count(mi_page_t* page, mi_block_t* head)\n{\n\tsize_t count \u003d 0;\n\twhile (head !\u003d NULL) {\n\t\tmi_assert_internal(page \u003d\u003d _mi_ptr_page(head));\n\t\tcount++;\n\t\thead \u003d mi_block_next(page, head);\n\t}\n\treturn count;\n```",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 50,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b07be1aa_99761fae",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 171,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_page_list_is_valid(mi_page_t* page, mi_block_t* p)\n{\n\tsize_t psize;\n\tuint8_t* page_area \u003d _mi_page_start(_mi_page_segment(page), page, \u0026psize);\n\tmi_block_t* start \u003d (mi_block_t*)page_area;\n\tmi_block_t* end \u003d (mi_block_t*)(page_area + psize);\n\twhile (p !\u003d NULL) {\n\t\tif (p \u003c start || p \u003e\u003d end)\n\t\t\treturn false;\n\t\tp \u003d mi_block_next(page, p);\n\t}\n#if MI_DEBUG \u003e 3 // generally too expensive to check this\n\tif (page-\u003efree_is_zero) {\n\t\tconst size_t ubsize \u003d mi_page_usable_block_size(page);\n\t\tfor (mi_block_t* block \u003d page-\u003efree; block !\u003d NULL; block \u003d mi_block_next(page, block))\n\t\t\tmi_assert_expensive(mi_mem_is_zero(block + 1, ubsize - sizeof(mi_block_t)));\n\t}\n#endif\n\treturn true;\n}\n\n\nstatic bool\nmi_page_is_valid_init(mi_page_t* page)\n{\n\tmi_assert_internal(page-\u003exblock_size \u003e 0);\n\tmi_assert_internal(page-\u003eused \u003c\u003d page-\u003ecapacity);\n\tmi_assert_internal(page-\u003ecapacity \u003c\u003d page-\u003ereserved);\n\n\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\tuint8_t* start \u003d _mi_page_start(segment, page, NULL);\n\tmi_assert_internal(start \u003d\u003d _mi_segment_page_start(segment, page, NULL));\n\t// const size_t bsize \u003d mi_page_block_size(page);\n\t// mi_assert_internal(start + page-\u003ecapacity*page-\u003eblock_size \u003d\u003d page-\u003etop);\n\n\tmi_assert_internal(mi_page_list_is_valid(page, page-\u003efree));\n\tmi_assert_internal(mi_page_list_is_valid(page, page-\u003elocal_free));\n\n#if MI_DEBUG \u003e 3 // generally too expensive to check this\n\tif (page-\u003efree_is_zero) {\n\t\tconst size_t ubsize \u003d mi_page_usable_block_size(page);\n\t\tfor (mi_block_t* block \u003d page-\u003efree; block !\u003d NULL; block \u003d mi_block_next(page, block))\n\t\t\tmi_assert_expensive(mi_mem_is_zero(block + 1, ubsize - sizeof(mi_block_t)));\n\t}\n#endif\n\n#if !MI_TRACK_ENABLED \u0026\u0026 !MI_TSAN\n\tmi_block_t* tfree \u003d mi_page_thread_free(page);\n\tmi_assert_internal(mi_page_list_is_valid(page, tfree));\n// size_t tfree_count \u003d mi_page_list_count(page, tfree);\n// mi_assert_internal(tfree_count \u003c\u003d page-\u003ethread_freed + 1);\n#endif\n\n\tsize_t free_count\n\t\t\u003d mi_page_list_count(page, page-\u003efree) + mi_page_list_count(page, page-\u003elocal_free);\n\tmi_assert_internal(page-\u003eused + free_count \u003d\u003d page-\u003ecapacity);\n\n\treturn true;\n}\n\nextern bool _mi_process_is_initialized; // has mi_process_init been called?\n\n\nbool\n_mi_page_is_valid(mi_page_t* page)\n{\n\tmi_assert_internal(mi_page_is_valid_init(page));\n#if MI_SECURE\n\tmi_assert_internal(page-\u003ekeys[0] !\u003d 0);\n#endif\n\tif (mi_page_heap(page) !\u003d NULL) {\n\t\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\n\t\tmi_assert_internal(!_mi_process_is_initialized || segment-\u003ethread_id \u003d\u003d 0\n\t\t\t|| segment-\u003ethread_id \u003d\u003d mi_page_heap(page)-\u003ethread_id);\n#if MI_HUGE_PAGE_ABANDON\n\t\tif (segment-\u003ekind !\u003d MI_SEGMENT_HUGE)\n#endif\n\t\t{\n\t\t\tmi_page_queue_t* pq \u003d mi_page_queue_of(page);\n\t\t\tmi_assert_internal(mi_page_queue_contains(pq, page));\n\t\t\tmi_assert_internal(pq-\u003eblock_size \u003d\u003d mi_page_block_size(page)\n\t\t\t\t|| mi_page_block_size(page) \u003e MI_MEDIUM_OBJ_SIZE_MAX || mi_page_is_in_full(page));\n\t\t\tmi_assert_internal(mi_heap_contains_queue(mi_page_heap(page), pq));\n\t\t}\n\t}\n\treturn true;\n}\n#endif\n\n\nvoid\n_mi_page_use_delayed_free(mi_page_t* page, mi_delayed_t delay, bool override_never)\n{\n\twhile (!_mi_page_try_use_delayed_free(page, delay, override_never))\n\t\tmi_atomic_yield();\n}\n\n\nbool\n_mi_page_try_use_delayed_free(mi_page_t* page, mi_delayed_t delay, bool override_never)\n{\n\tmi_thread_free_t tfreex;\n\tmi_delayed_t old_delay;\n\tmi_thread_free_t tfree;\n\tsize_t yield_count \u003d 0;\n\tdo {\n\t\ttfree \u003d mi_atomic_load_acquire(\n\t\t\t\u0026page-\u003exthread_free); // note: must acquire as we can break/repeat this loop and not do\n\t\t\t\t\t\t\t\t  // a CAS;\n\t\ttfreex \u003d mi_tf_set_delayed(tfree, delay);\n\t\told_delay \u003d mi_tf_delayed(tfree);\n\t\tif mi_unlikely (old_delay \u003d\u003d MI_DELAYED_FREEING) {\n\t\t\tif (yield_count \u003e\u003d 4)\n\t\t\t\treturn false; // give up after 4 tries\n\t\t\tyield_count++;\n\t\t\tmi_atomic_yield(); // delay until outstanding MI_DELAYED_FREEING are done.\n\t\t\t// tfree \u003d mi_tf_set_delayed(tfree, MI_NO_DELAYED_FREE); // will cause CAS to busy fail\n\t\t} else if (delay \u003d\u003d old_delay) {\n\t\t\tbreak; // avoid atomic operation if already equal\n\t\t} else if (!override_never \u0026\u0026 old_delay \u003d\u003d MI_NEVER_DELAYED_FREE) {\n\t\t\tbreak; // leave never-delayed flag set\n\t\t}\n\t} while ((old_delay \u003d\u003d MI_DELAYED_FREEING)\n\t\t|| !mi_atomic_cas_weak_release(\u0026page-\u003exthread_free, \u0026tfree, tfreex));\n\n\treturn true; // success\n```",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 171,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1b08f4f1_c337740f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 250,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\n_mi_page_thread_free_collect(mi_page_t* page)\n{\n\tmi_block_t* head;\n\tmi_thread_free_t tfreex;\n\tmi_thread_free_t tfree \u003d mi_atomic_load_relaxed(\u0026page-\u003exthread_free);\n\tdo {\n\t\thead \u003d mi_tf_block(tfree);\n\t\ttfreex \u003d mi_tf_set_block(tfree, NULL);\n\t} while (!mi_atomic_cas_weak_acq_rel(\u0026page-\u003exthread_free, \u0026tfree, tfreex));\n\n\t// return if the list is empty\n\tif (head \u003d\u003d NULL)\n\t\treturn;\n\n\t// find the tail -- also to get a proper count (without data races)\n\tuint32_t max_count \u003d page-\u003ecapacity; // cannot collect more than capacity\n\tuint32_t count \u003d 1;\n\tmi_block_t* tail \u003d head;\n\tmi_block_t* next;\n\twhile ((next \u003d mi_block_next(page, tail)) !\u003d NULL \u0026\u0026 count \u003c\u003d max_count) {\n\t\tcount++;\n\t\ttail \u003d next;\n\t}\n\t// if `count \u003e max_count` there was a memory corruption (possibly infinite list due to double\n\t// multi-threaded free)\n\tif (count \u003e max_count) {\n\t\t_mi_error_message(EFAULT, \"corrupted thread-free list\\n\");\n\t\treturn; // the thread-free items cannot be freed\n\t}\n\n\t// and append the current local free list\n\tmi_block_set_next(page, tail, page-\u003elocal_free);\n\tpage-\u003elocal_free \u003d head;\n\n\t// update counts now\n\tpage-\u003eused -\u003d count;\n}\n\n\nvoid\n_mi_page_free_collect(mi_page_t* page, bool force)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\n\t// collect the thread free list\n\tif (force || mi_page_thread_free(page) !\u003d NULL) // quick test to avoid an atomic operation\n\t\t_mi_page_thread_free_collect(page);\n\n\t// and the local free list\n\tif (page-\u003elocal_free !\u003d NULL) {\n\t\tif mi_likely (page-\u003efree \u003d\u003d NULL) {\n\t\t\t// usual case\n\t\t\tpage-\u003efree \u003d page-\u003elocal_free;\n\t\t\tpage-\u003elocal_free \u003d NULL;\n\t\t\tpage-\u003efree_is_zero \u003d false;\n\t\t} else if (force) {\n\t\t\t// append -- only on shutdown (force) as this is a linear operation\n\t\t\tmi_block_t* tail \u003d page-\u003elocal_free;\n\t\t\tmi_block_t* next;\n\t\t\twhile ((next \u003d mi_block_next(page, tail)) !\u003d NULL)\n\t\t\t\ttail \u003d next;\n\t\t\tmi_block_set_next(page, tail, page-\u003efree);\n\t\t\tpage-\u003efree \u003d page-\u003elocal_free;\n\t\t\tpage-\u003elocal_free \u003d NULL;\n\t\t\tpage-\u003efree_is_zero \u003d false;\n\t\t}\n\t}\n\n\tmi_assert_internal(!force || page-\u003elocal_free \u003d\u003d NULL);\n}\n```",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 250,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3a17837b_4a28f4dd",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 270,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_page_reclaim(mi_heap_t* heap, mi_page_t* page)\n{\n\tmi_assert_expensive(mi_page_is_valid_init(page));\n\n\tmi_assert_internal(mi_page_heap(page) \u003d\u003d heap);\n\tmi_assert_internal(mi_page_thread_free_flag(page) !\u003d MI_NEVER_DELAYED_FREE);\n#if MI_HUGE_PAGE_ABANDON\n\tmi_assert_internal(_mi_page_segment(page)-\u003ekind !\u003d MI_SEGMENT_HUGE);\n#endif\n\n\t// TODO: push on full queue immediately if it is full?\n\tmi_page_queue_t* pq \u003d mi_page_queue(heap, mi_page_block_size(page));\n\tmi_page_queue_push(heap, pq, page);\n\tmi_assert_expensive(_mi_page_is_valid(page));\n```",
      "range": {
        "startLine": 258,
        "startChar": 0,
        "endLine": 270,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17e3e28c_b218775d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 295,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_page_fresh_alloc(mi_heap_t* heap, mi_page_queue_t* pq, size_t block_size, size_t page_alignment)\n{\n#if !MI_HUGE_PAGE_ABANDON\n\tmi_assert_internal(pq !\u003d NULL);\n\tmi_assert_internal(mi_heap_contains_queue(heap, pq));\n\tmi_assert_internal(\n\t\tpage_alignment \u003e 0 || block_size \u003e MI_MEDIUM_OBJ_SIZE_MAX || block_size \u003d\u003d pq-\u003eblock_size);\n#endif\n\tmi_page_t* page \u003d _mi_segment_page_alloc(heap, block_size, page_alignment, \u0026heap-\u003etld-\u003esegments,\n\t\t\u0026heap-\u003etld-\u003eos);\n\tif (page \u003d\u003d NULL) {\n\t\t// this may be out-of-memory, or an abandoned page was reclaimed (and in our queue)\n\t\treturn NULL;\n\t}\n\tmi_assert_internal(page_alignment \u003e 0 || block_size \u003e MI_MEDIUM_OBJ_SIZE_MAX\n\t\t|| _mi_page_segment(page)-\u003ekind !\u003d MI_SEGMENT_HUGE);\n\tmi_assert_internal(pq !\u003d NULL || page-\u003exblock_size !\u003d 0);\n\tmi_assert_internal(pq !\u003d NULL || mi_page_block_size(page) \u003e\u003d block_size);\n\t// a fresh page was found, initialize it\n\tconst size_t full_block_size \u003d ((pq \u003d\u003d NULL || mi_page_queue_is_huge(pq))\n\t\t\t? mi_page_block_size(page)\n\t\t\t: block_size); // see also: mi_segment_huge_page_alloc\n\tmi_assert_internal(full_block_size \u003e\u003d block_size);\n\tmi_page_init(heap, page, full_block_size, heap-\u003etld);\n\tmi_heap_stat_increase(heap, pages, 1);\n\tif (pq !\u003d NULL)\n\t\tmi_page_queue_push(heap, pq, page);\n\tmi_assert_expensive(_mi_page_is_valid(page));\n\treturn page;\n```",
      "range": {
        "startLine": 274,
        "startChar": 0,
        "endLine": 295,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "61ebc3cd_a19682c3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 305,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_page_fresh(mi_heap_t* heap, mi_page_queue_t* pq)\n{\n\tmi_assert_internal(mi_heap_contains_queue(heap, pq));\n\tmi_page_t* page \u003d mi_page_fresh_alloc(heap, pq, pq-\u003eblock_size, 0);\n\tif (page \u003d\u003d NULL)\n\t\treturn NULL;\n\tmi_assert_internal(pq-\u003eblock_size \u003d\u003d mi_page_block_size(page));\n\tmi_assert_internal(pq \u003d\u003d mi_page_queue(heap, mi_page_block_size(page)));\n\treturn page;\n```",
      "range": {
        "startLine": 299,
        "startChar": 0,
        "endLine": 305,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06902614_92f558cb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 315,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_heap_delayed_free_all(mi_heap_t* heap)\n{\n\twhile (!_mi_heap_delayed_free_partial(heap))\n\t\tmi_atomic_yield();\n```",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 315,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e3575b11_341f8175",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 341,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_heap_delayed_free_partial(mi_heap_t* heap)\n{\n\t// take over the list (note: no atomic exchange since it is often NULL)\n\tmi_block_t* block \u003d mi_atomic_load_ptr_relaxed(mi_block_t, \u0026heap-\u003ethread_delayed_free);\n\twhile (block !\u003d NULL\n\t\t\u0026\u0026 !mi_atomic_cas_ptr_weak_acq_rel(mi_block_t, \u0026heap-\u003ethread_delayed_free, \u0026block,\n\t\t\tNULL)) { /* nothing */\n\t};\n\tbool all_freed \u003d true;\n\n\t// and free them all\n\twhile (block !\u003d NULL) {\n\t\tmi_block_t* next \u003d mi_block_nextx(heap, block, heap-\u003ekeys);\n\t\t// use internal free instead of regular one to keep stats etc correct\n\t\tif (!_mi_free_delayed_block(block)) {\n\t\t\t// we might already start delayed freeing while another thread has not yet\n\t\t\t// reset the delayed_freeing flag; in that case delay it further by reinserting the\n\t\t\t// current block into the delayed free list\n\t\t\tall_freed \u003d false;\n\t\t\tmi_block_t* dfree \u003d mi_atomic_load_ptr_relaxed(mi_block_t, \u0026heap-\u003ethread_delayed_free);\n\t\t\tdo {\n\t\t\t\tmi_block_set_nextx(heap, block, dfree, heap-\u003ekeys);\n\t\t\t} while (!mi_atomic_cas_ptr_weak_release(mi_block_t, \u0026heap-\u003ethread_delayed_free, \u0026dfree,\n\t\t\t\tblock));\n\t\t}\n\t\tblock \u003d next;\n\t}\n\treturn all_freed;\n```",
      "range": {
        "startLine": 319,
        "startChar": 0,
        "endLine": 341,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "326213a1_82e39cab",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 370,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_page_unfull(mi_page_t* page)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_assert_expensive(_mi_page_is_valid(page));\n\tmi_assert_internal(mi_page_is_in_full(page));\n\tif (!mi_page_is_in_full(page))\n\t\treturn;\n\n\tmi_heap_t* heap \u003d mi_page_heap(page);\n\tmi_page_queue_t* pqfull \u003d \u0026heap-\u003epages[MI_BIN_FULL];\n\tmi_page_set_in_full(page, false); // to get the right queue\n\tmi_page_queue_t* pq \u003d mi_heap_page_queue_of(heap, page);\n\tmi_page_set_in_full(page, true);\n\tmi_page_queue_enqueue_from(pq, pqfull, page);\n}\n\n\nstatic void\nmi_page_to_full(mi_page_t* page, mi_page_queue_t* pq)\n{\n\tmi_assert_internal(pq \u003d\u003d mi_page_queue_of(page));\n\tmi_assert_internal(!mi_page_immediate_available(page));\n\tmi_assert_internal(!mi_page_is_in_full(page));\n\n\tif (mi_page_is_in_full(page))\n\t\treturn;\n\tmi_page_queue_enqueue_from(\u0026mi_page_heap(page)-\u003epages[MI_BIN_FULL], pq, page);\n\t_mi_page_free_collect(page, false); // try to collect right away in case another thread freed\n\t\t\t\t\t\t\t\t\t\t// just before MI_USE_DELAYED_FREE was set\n```",
      "range": {
        "startLine": 349,
        "startChar": 0,
        "endLine": 370,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff5aec0e_4f890b42",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 403,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_page_abandon(mi_page_t* page, mi_page_queue_t* pq)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_assert_expensive(_mi_page_is_valid(page));\n\tmi_assert_internal(pq \u003d\u003d mi_page_queue_of(page));\n\tmi_assert_internal(mi_page_heap(page) !\u003d NULL);\n\n\tmi_heap_t* pheap \u003d mi_page_heap(page);\n\n\t// remove from our page list\n\tmi_segments_tld_t* segments_tld \u003d \u0026pheap-\u003etld-\u003esegments;\n\tmi_page_queue_remove(pq, page);\n\n\t// page is no longer associated with our heap\n\tmi_assert_internal(mi_page_thread_free_flag(page) \u003d\u003d MI_NEVER_DELAYED_FREE);\n\tmi_page_set_heap(page, NULL);\n\n#if (MI_DEBUG \u003e 1) \u0026\u0026 !MI_TRACK_ENABLED\n\t// check there are no references left..\n\tfor (mi_block_t* block \u003d (mi_block_t*)pheap-\u003ethread_delayed_free; block !\u003d NULL;\n\t\tblock \u003d mi_block_nextx(pheap, block, pheap-\u003ekeys)) {\n\t\tmi_assert_internal(_mi_ptr_page(block) !\u003d page);\n\t}\n#endif\n\n\t// and abandon it\n\tmi_assert_internal(mi_page_heap(page) \u003d\u003d NULL);\n\t_mi_segment_page_abandon(page, segments_tld);\n```",
      "range": {
        "startLine": 378,
        "startChar": 0,
        "endLine": 403,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f062dd62_5f7ccf8c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 427,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_page_free(mi_page_t* page, mi_page_queue_t* pq, bool force)\n{\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_assert_expensive(_mi_page_is_valid(page));\n\tmi_assert_internal(pq \u003d\u003d mi_page_queue_of(page));\n\tmi_assert_internal(mi_page_all_free(page));\n\tmi_assert_internal(mi_page_thread_free_flag(page) !\u003d MI_DELAYED_FREEING);\n\n\t// no more aligned blocks in here\n\tmi_page_set_has_aligned(page, false);\n\n\tmi_heap_t* heap \u003d mi_page_heap(page);\n\n\t// remove from the page list\n\t// (no need to do _mi_heap_delayed_free first as all blocks are already free)\n\tmi_segments_tld_t* segments_tld \u003d \u0026heap-\u003etld-\u003esegments;\n\tmi_page_queue_remove(pq, page);\n\n\t// and free it\n\tmi_page_set_heap(page, NULL);\n\t_mi_segment_page_free(page, force, segments_tld);\n```",
      "range": {
        "startLine": 408,
        "startChar": 0,
        "endLine": 427,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a53d7895_17aca693",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 432,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_RETIRE_SIZE (MI_MEDIUM_OBJ_SIZE_MAX)\n#define MI_RETIRE_CYCLES (16)\n```",
      "range": {
        "startLine": 431,
        "startChar": 0,
        "endLine": 432,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6f0fabcf_8a839d94",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 468,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_page_retire(mi_page_t* page) mi_attr_noexcept\n{\n\tmi_assert_internal(page !\u003d NULL);\n\tmi_assert_expensive(_mi_page_is_valid(page));\n\tmi_assert_internal(mi_page_all_free(page));\n\n\tmi_page_set_has_aligned(page, false);\n\n\t// don\u0027t retire too often..\n\t// (or we end up retiring and re-allocating most of the time)\n\t// NOTE: refine this more: we should not retire if this\n\t// is the only page left with free blocks. It is not clear\n\t// how to check this efficiently though...\n\t// for now, we don\u0027t retire if it is the only page left of this size class.\n\tmi_page_queue_t* pq \u003d mi_page_queue_of(page);\n\tif mi_likely (page-\u003exblock_size \u003c\u003d MI_MAX_RETIRE_SIZE\n\t\t\u0026\u0026 !mi_page_queue_is_special(pq)) { // not too large \u0026\u0026 not full or huge queue?\n\t\tif (pq-\u003elast \u003d\u003d page \u0026\u0026 pq-\u003efirst \u003d\u003d page) { // the only page in the queue?\n\t\t\tmi_stat_counter_increase(_mi_stats_main.page_no_retire, 1);\n\t\t\tpage-\u003eretire_expire \u003d 1\n\t\t\t\t+ (page-\u003exblock_size \u003c\u003d MI_SMALL_OBJ_SIZE_MAX ? MI_RETIRE_CYCLES\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  : MI_RETIRE_CYCLES / 4);\n\t\t\tmi_heap_t* heap \u003d mi_page_heap(page);\n\t\t\tmi_assert_internal(pq \u003e\u003d heap-\u003epages);\n\t\t\tconst size_t index \u003d pq - heap-\u003epages;\n\t\t\tmi_assert_internal(index \u003c MI_BIN_FULL \u0026\u0026 index \u003c MI_BIN_HUGE);\n\t\t\tif (index \u003c heap-\u003epage_retired_min)\n\t\t\t\theap-\u003epage_retired_min \u003d index;\n\t\t\tif (index \u003e heap-\u003epage_retired_max)\n\t\t\t\theap-\u003epage_retired_max \u003d index;\n\t\t\tmi_assert_internal(mi_page_all_free(page));\n\t\t\treturn; // dont\u0027t free after all\n\t\t}\n\t}\n\t_mi_page_free(page, pq, false);\n```",
      "range": {
        "startLine": 440,
        "startChar": 0,
        "endLine": 468,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3a6a467b_d99f55e2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 497,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_heap_collect_retired(mi_heap_t* heap, bool force)\n{\n\tsize_t min \u003d MI_BIN_FULL;\n\tsize_t max \u003d 0;\n\tfor (size_t bin \u003d heap-\u003epage_retired_min; bin \u003c\u003d heap-\u003epage_retired_max; bin++) {\n\t\tmi_page_queue_t* pq \u003d \u0026heap-\u003epages[bin];\n\t\tmi_page_t* page \u003d pq-\u003efirst;\n\t\tif (page !\u003d NULL \u0026\u0026 page-\u003eretire_expire !\u003d 0) {\n\t\t\tif (mi_page_all_free(page)) {\n\t\t\t\tpage-\u003eretire_expire--;\n\t\t\t\tif (force || page-\u003eretire_expire \u003d\u003d 0) {\n\t\t\t\t\t_mi_page_free(pq-\u003efirst, pq, force);\n\t\t\t\t} else {\n\t\t\t\t\t// keep retired, update min/max\n\t\t\t\t\tif (bin \u003c min)\n\t\t\t\t\t\tmin \u003d bin;\n\t\t\t\t\tif (bin \u003e max)\n\t\t\t\t\t\tmax \u003d bin;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpage-\u003eretire_expire \u003d 0;\n\t\t\t}\n\t\t}\n\t}\n\theap-\u003epage_retired_min \u003d min;\n\theap-\u003epage_retired_max \u003d max;\n```",
      "range": {
        "startLine": 473,
        "startChar": 0,
        "endLine": 497,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "180e09a9_4a9b2ce2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 591,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_SLICE_SHIFT (6) // at most 64 slices\n#define MI_MAX_SLICES (1UL \u003c\u003c MI_MAX_SLICE_SHIFT)\n#define MI_MIN_SLICES (2)\n\n\nstatic void\nmi_page_free_list_extend_secure(mi_heap_t* const heap, mi_page_t* const page, const size_t bsize,\n\tconst size_t extend, mi_stats_t* const stats)\n{\n\tMI_UNUSED(stats);\n#if (MI_SECURE \u003c\u003d 2)\n\tmi_assert_internal(page-\u003efree \u003d\u003d NULL);\n\tmi_assert_internal(page-\u003elocal_free \u003d\u003d NULL);\n#endif\n\tmi_assert_internal(page-\u003ecapacity + extend \u003c\u003d page-\u003ereserved);\n\tmi_assert_internal(bsize \u003d\u003d mi_page_block_size(page));\n\tvoid* const page_area \u003d _mi_page_start(_mi_page_segment(page), page, NULL);\n\n\t// initialize a randomized free list\n\t// set up `slice_count` slices to alternate between\n\tsize_t shift \u003d MI_MAX_SLICE_SHIFT;\n\twhile ((extend \u003e\u003e shift) \u003d\u003d 0)\n\t\tshift--;\n\tconst size_t slice_count \u003d (size_t)1U \u003c\u003c shift;\n\tconst size_t slice_extend \u003d extend / slice_count;\n\tmi_assert_internal(slice_extend \u003e\u003d 1);\n\tmi_block_t* blocks[MI_MAX_SLICES]; // current start of the slice\n\tsize_t counts[MI_MAX_SLICES]; // available objects in the slice\n\tfor (size_t i \u003d 0; i \u003c slice_count; i++) {\n\t\tblocks[i] \u003d mi_page_block_at(page, page_area, bsize, page-\u003ecapacity + i * slice_extend);\n\t\tcounts[i] \u003d slice_extend;\n\t}\n\tcounts[slice_count - 1]\n\t\t+\u003d (extend % slice_count); // final slice holds the modulus too (todo: distribute evenly?)\n\n\t// and initialize the free list by randomly threading through them\n\t// set up first element\n\tconst uintptr_t r \u003d _mi_heap_random_next(heap);\n\tsize_t current \u003d r % slice_count;\n\tcounts[current]--;\n\tmi_block_t* const free_start \u003d blocks[current];\n\t// and iterate through the rest; use `random_shuffle` for performance\n\tuintptr_t rnd \u003d _mi_random_shuffle(r | 1); // ensure not 0\n\tfor (size_t i \u003d 1; i \u003c extend; i++) {\n\t\t// call random_shuffle only every INTPTR_SIZE rounds\n\t\tconst size_t round \u003d i % MI_INTPTR_SIZE;\n\t\tif (round \u003d\u003d 0)\n\t\t\trnd \u003d _mi_random_shuffle(rnd);\n\t\t// select a random next slice index\n\t\tsize_t next \u003d ((rnd \u003e\u003e 8 * round) \u0026 (slice_count - 1));\n\t\twhile (counts[next] \u003d\u003d 0) { // ensure it still has space\n\t\t\tnext++;\n\t\t\tif (next \u003d\u003d slice_count)\n\t\t\t\tnext \u003d 0;\n\t\t}\n\t\t// and link the current block to it\n\t\tcounts[next]--;\n\t\tmi_block_t* const block \u003d blocks[current];\n\t\tblocks[current] \u003d (mi_block_t*)((uint8_t*)block + bsize); // bump to the following block\n\t\tmi_block_set_next(page, block,\n\t\t\tblocks[next]); // and set next; note: we may have `current \u003d\u003d next`\n\t\tcurrent \u003d next;\n\t}\n\t// prepend to the free list (usually NULL)\n\tmi_block_set_next(page, blocks[current], page-\u003efree); // end of the list\n\tpage-\u003efree \u003d free_start;\n}\n\n\nstatic mi_decl_noinline void\nmi_page_free_list_extend(mi_page_t* const page, const size_t bsize, const size_t extend,\n\tmi_stats_t* const stats)\n{\n\tMI_UNUSED(stats);\n#if (MI_SECURE \u003c\u003d 2)\n\tmi_assert_internal(page-\u003efree \u003d\u003d NULL);\n\tmi_assert_internal(page-\u003elocal_free \u003d\u003d NULL);\n#endif\n\tmi_assert_internal(page-\u003ecapacity + extend \u003c\u003d page-\u003ereserved);\n\tmi_assert_internal(bsize \u003d\u003d mi_page_block_size(page));\n\tvoid* const page_area \u003d _mi_page_start(_mi_page_segment(page), page, NULL);\n\n\tmi_block_t* const start \u003d mi_page_block_at(page, page_area, bsize, page-\u003ecapacity);\n\n\t// initialize a sequential free list\n\tmi_block_t* const last \u003d mi_page_block_at(page, page_area, bsize, page-\u003ecapacity + extend - 1);\n\tmi_block_t* block \u003d start;\n\twhile (block \u003c\u003d last) {\n\t\tmi_block_t* next \u003d (mi_block_t*)((uint8_t*)block + bsize);\n\t\tmi_block_set_next(page, block, next);\n\t\tblock \u003d next;\n\t}\n\t// prepend to free list (usually `NULL`)\n\tmi_block_set_next(page, last, page-\u003efree);\n\tpage-\u003efree \u003d start;\n```",
      "range": {
        "startLine": 507,
        "startChar": 0,
        "endLine": 591,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bcb9dd31_7d9c977e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 600,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_EXTEND_SIZE (4 * 1024) // heuristic, one OS page seems to work well.\n#if (MI_SECURE \u003e 0)\n#define MI_MIN_EXTEND (8 * MI_SECURE) // extend at least by this many\n```",
      "range": {
        "startLine": 598,
        "startChar": 0,
        "endLine": 600,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bc8a672b_d89bc06e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 602,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MIN_EXTEND (4)\n```",
      "range": {
        "startLine": 602,
        "startChar": 0,
        "endLine": 602,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2cc6f46_a96155e7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 652,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_page_extend_free(mi_heap_t* heap, mi_page_t* page, mi_tld_t* tld)\n{\n\tMI_UNUSED(tld);\n\tmi_assert_expensive(mi_page_is_valid_init(page));\n#if (MI_SECURE \u003c\u003d 2)\n\tmi_assert(page-\u003efree \u003d\u003d NULL);\n\tmi_assert(page-\u003elocal_free \u003d\u003d NULL);\n\tif (page-\u003efree !\u003d NULL)\n\t\treturn;\n#endif\n\tif (page-\u003ecapacity \u003e\u003d page-\u003ereserved)\n\t\treturn;\n\n\tsize_t page_size;\n\t_mi_page_start(_mi_page_segment(page), page, \u0026page_size);\n\tmi_stat_counter_increase(tld-\u003estats.pages_extended, 1);\n\n\t// calculate the extend count\n\tconst size_t bsize \u003d (page-\u003exblock_size \u003c MI_HUGE_BLOCK_SIZE ? page-\u003exblock_size : page_size);\n\tsize_t extend \u003d page-\u003ereserved - page-\u003ecapacity;\n\tmi_assert_internal(extend \u003e 0);\n\n\tsize_t max_extend\n\t\t\u003d (bsize \u003e\u003d MI_MAX_EXTEND_SIZE ? MI_MIN_EXTEND : MI_MAX_EXTEND_SIZE / (uint32_t)bsize);\n\tif (max_extend \u003c MI_MIN_EXTEND)\n\t\tmax_extend \u003d MI_MIN_EXTEND;\n\tmi_assert_internal(max_extend \u003e 0);\n\n\tif (extend \u003e max_extend) {\n\t\t// ensure we don\u0027t touch memory beyond the page to reduce page commit.\n\t\t// the `lean` benchmark tests this. Going from 1 to 8 increases rss by 50%.\n\t\textend \u003d max_extend;\n\t}\n\n\tmi_assert_internal(extend \u003e 0 \u0026\u0026 extend + page-\u003ecapacity \u003c\u003d page-\u003ereserved);\n\tmi_assert_internal(extend \u003c (1UL \u003c\u003c 16));\n\n\t// and append the extend the free list\n\tif (extend \u003c MI_MIN_SLICES || MI_SECURE \u003d\u003d 0) //! mi_option_is_enabled(mi_option_secure)) {\n\t\tmi_page_free_list_extend(page, bsize, extend, \u0026tld-\u003estats);\n\telse\n\t\tmi_page_free_list_extend_secure(heap, page, bsize, extend, \u0026tld-\u003estats);\n\t// enable the new free list\n\tpage-\u003ecapacity +\u003d (uint16_t)extend;\n\tmi_stat_increase(tld-\u003estats.page_committed, extend * bsize);\n\tmi_assert_expensive(mi_page_is_valid_init(page));\n```",
      "range": {
        "startLine": 610,
        "startChar": 0,
        "endLine": 652,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dc8c7dc8_16d85352",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 702,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_page_init(mi_heap_t* heap, mi_page_t* page, size_t block_size, mi_tld_t* tld)\n{\n\tmi_assert(page !\u003d NULL);\n\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\tmi_assert(segment !\u003d NULL);\n\tmi_assert_internal(block_size \u003e 0);\n\t// set fields\n\tmi_page_set_heap(page, heap);\n\tpage-\u003exblock_size \u003d (block_size \u003c MI_HUGE_BLOCK_SIZE\n\t\t\t? (uint32_t)block_size\n\t\t\t: MI_HUGE_BLOCK_SIZE); // initialize before _mi_segment_page_start\n\tsize_t page_size;\n\tconst void* page_start \u003d _mi_segment_page_start(segment, page, \u0026page_size);\n\tMI_UNUSED(page_start);\n\tmi_track_mem_noaccess(page_start, page_size);\n\tmi_assert_internal(mi_page_block_size(page) \u003c\u003d page_size);\n\tmi_assert_internal(page_size \u003c\u003d page-\u003eslice_count * MI_SEGMENT_SLICE_SIZE);\n\tmi_assert_internal(page_size / block_size \u003c (1L \u003c\u003c 16));\n\tpage-\u003ereserved \u003d (uint16_t)(page_size / block_size);\n\tmi_assert_internal(page-\u003ereserved \u003e 0);\n#if (MI_PADDING || MI_ENCODE_FREELIST)\n\tpage-\u003ekeys[0] \u003d _mi_heap_random_next(heap);\n\tpage-\u003ekeys[1] \u003d _mi_heap_random_next(heap);\n#endif\n\tpage-\u003efree_is_zero \u003d page-\u003eis_zero_init;\n#if MI_DEBUG \u003e 2\n\tif (page-\u003eis_zero_init) {\n\t\tmi_track_mem_defined(page_start, page_size);\n\t\tmi_assert_expensive(mi_mem_is_zero(page_start, page_size));\n\t}\n#endif\n\n\tmi_assert_internal(page-\u003eis_committed);\n\tmi_assert_internal(page-\u003ecapacity \u003d\u003d 0);\n\tmi_assert_internal(page-\u003efree \u003d\u003d NULL);\n\tmi_assert_internal(page-\u003eused \u003d\u003d 0);\n\tmi_assert_internal(page-\u003exthread_free \u003d\u003d 0);\n\tmi_assert_internal(page-\u003enext \u003d\u003d NULL);\n\tmi_assert_internal(page-\u003eprev \u003d\u003d NULL);\n\tmi_assert_internal(page-\u003eretire_expire \u003d\u003d 0);\n\tmi_assert_internal(!mi_page_has_aligned(page));\n#if (MI_PADDING || MI_ENCODE_FREELIST)\n\tmi_assert_internal(page-\u003ekeys[0] !\u003d 0);\n\tmi_assert_internal(page-\u003ekeys[1] !\u003d 0);\n#endif\n\tmi_assert_expensive(mi_page_is_valid_init(page));\n\n\t// initialize an initial free list\n\tmi_page_extend_free(heap, page, tld);\n\tmi_assert(mi_page_immediate_available(page));\n```",
      "range": {
        "startLine": 656,
        "startChar": 0,
        "endLine": 702,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "984fe7c3_711e6c79",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 765,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_page_queue_find_free_ex(mi_heap_t* heap, mi_page_queue_t* pq, bool first_try)\n{\n// search through the pages in \"next fit\" order\n#if MI_STAT\n\tsize_t count \u003d 0;\n#endif\n\tmi_page_t* page \u003d pq-\u003efirst;\n\twhile (page !\u003d NULL) {\n\t\tmi_page_t* next \u003d page-\u003enext; // remember next\n#if MI_STAT\n\t\tcount++;\n#endif\n\n\t\t// 0. collect freed blocks by us and other threads\n\t\t_mi_page_free_collect(page, false);\n\n\t\t// 1. if the page contains free blocks, we are done\n\t\tif (mi_page_immediate_available(page))\n\t\t\tbreak; // pick this one\n\n\t\t// 2. Try to extend\n\t\tif (page-\u003ecapacity \u003c page-\u003ereserved) {\n\t\t\tmi_page_extend_free(heap, page, heap-\u003etld);\n\t\t\tmi_assert_internal(mi_page_immediate_available(page));\n\t\t\tbreak;\n\t\t}\n\n\t\t// 3. If the page is completely full, move it to the `mi_pages_full`\n\t\t// queue so we don\u0027t visit long-lived pages too often.\n\t\tmi_assert_internal(!mi_page_is_in_full(page) \u0026\u0026 !mi_page_immediate_available(page));\n\t\tmi_page_to_full(page, pq);\n\n\t\tpage \u003d next;\n\t} // for each page\n\n\tmi_heap_stat_counter_increase(heap, searches, count);\n\n\tif (page \u003d\u003d NULL) {\n\t\t_mi_heap_collect_retired(heap, false); // perhaps make a page available?\n\t\tpage \u003d mi_page_fresh(heap, pq);\n\t\tif (page \u003d\u003d NULL \u0026\u0026 first_try) {\n\t\t\t// out-of-memory _or_ an abandoned page with free blocks was reclaimed, try once again\n\t\t\tpage \u003d mi_page_queue_find_free_ex(heap, pq, false);\n\t\t}\n\t} else {\n\t\tmi_assert(pq-\u003efirst \u003d\u003d page);\n\t\tpage-\u003eretire_expire \u003d 0;\n\t}\n\tmi_assert_internal(page \u003d\u003d NULL || mi_page_immediate_available(page));\n\treturn page;\n}\n```",
      "range": {
        "startLine": 711,
        "startChar": 0,
        "endLine": 765,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "70965873_2f142bc1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 789,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline mi_page_t*\nmi_find_free_page(mi_heap_t* heap, size_t size)\n{\n\tmi_page_queue_t* pq \u003d mi_page_queue(heap, size);\n\tmi_page_t* page \u003d pq-\u003efirst;\n\tif (page !\u003d NULL) {\n#if (MI_SECURE \u003e\u003d 3) // in secure mode, we extend half the time to increase randomness\n\t\tif (page-\u003ecapacity \u003c page-\u003ereserved \u0026\u0026 ((_mi_heap_random_next(heap) \u0026 1) \u003d\u003d 1)) {\n\t\t\tmi_page_extend_free(heap, page, heap-\u003etld);\n\t\t\tmi_assert_internal(mi_page_immediate_available(page));\n\t\t} else\n#endif\n\t\t{\n\t\t\t_mi_page_free_collect(page, false);\n\t\t}\n\n\t\tif (mi_page_immediate_available(page)) {\n\t\t\tpage-\u003eretire_expire \u003d 0;\n\t\t\treturn page; // fast path\n\t\t}\n\t}\n\treturn mi_page_queue_find_free_ex(heap, pq, true);\n```",
      "range": {
        "startLine": 769,
        "startChar": 0,
        "endLine": 789,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "28825004_ab2dc5f0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 814,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n_mi_deferred_free(mi_heap_t* heap, bool force)\n{\n\theap-\u003etld-\u003eheartbeat++;\n\tif (deferred_free !\u003d NULL \u0026\u0026 !heap-\u003etld-\u003erecurse) {\n\t\theap-\u003etld-\u003erecurse \u003d true;\n\t\tdeferred_free(force, heap-\u003etld-\u003eheartbeat, mi_atomic_load_ptr_relaxed(void, \u0026deferred_arg));\n\t\theap-\u003etld-\u003erecurse \u003d false;\n\t}\n}\n\n\nvoid\nmi_register_deferred_free(mi_deferred_free_fun* fn, void* arg) mi_attr_noexcept\n{\n\tdeferred_free \u003d fn;\n\tmi_atomic_store_ptr_release(void, \u0026deferred_arg, arg);\n```",
      "range": {
        "startLine": 803,
        "startChar": 0,
        "endLine": 814,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a27674bd_53504831",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 864,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_large_huge_page_alloc(mi_heap_t* heap, size_t size, size_t page_alignment)\n{\n\tsize_t block_size \u003d _mi_os_good_alloc_size(size);\n\tmi_assert_internal(mi_bin(block_size) \u003d\u003d MI_BIN_HUGE || page_alignment \u003e 0);\n\tbool is_huge \u003d (block_size \u003e MI_LARGE_OBJ_SIZE_MAX || page_alignment \u003e 0);\n#if MI_HUGE_PAGE_ABANDON\n\tmi_page_queue_t* pq \u003d (is_huge ? NULL : mi_page_queue(heap, block_size));\n#else\n\tmi_page_queue_t* pq \u003d mi_page_queue(heap,\n\t\tis_huge ? MI_HUGE_BLOCK_SIZE\n\t\t\t\t: block_size); // not block_size as that can be low if the page_alignment \u003e 0\n\tmi_assert_internal(!is_huge || mi_page_queue_is_huge(pq));\n#endif\n\tmi_page_t* page \u003d mi_page_fresh_alloc(heap, pq, block_size, page_alignment);\n\tif (page !\u003d NULL) {\n\t\tmi_assert_internal(mi_page_immediate_available(page));\n\n\t\tif (is_huge) {\n\t\t\tmi_assert_internal(_mi_page_segment(page)-\u003ekind \u003d\u003d MI_SEGMENT_HUGE);\n\t\t\tmi_assert_internal(_mi_page_segment(page)-\u003eused \u003d\u003d 1);\n#if MI_HUGE_PAGE_ABANDON\n\t\t\tmi_assert_internal(\n\t\t\t\t_mi_page_segment(page)-\u003ethread_id \u003d\u003d 0); // abandoned, not in the huge queue\n\t\t\tmi_page_set_heap(page, NULL);\n#endif\n\t\t} else {\n\t\t\tmi_assert_internal(_mi_page_segment(page)-\u003ekind !\u003d MI_SEGMENT_HUGE);\n\t\t}\n\n\t\tconst size_t bsize \u003d mi_page_usable_block_size(\n\t\t\tpage); // note: not `mi_page_block_size` to account for padding\n\t\tif (bsize \u003c\u003d MI_LARGE_OBJ_SIZE_MAX) {\n\t\t\tmi_heap_stat_increase(heap, large, bsize);\n\t\t\tmi_heap_stat_counter_increase(heap, large_count, 1);\n\t\t} else {\n\t\t\tmi_heap_stat_increase(heap, huge, bsize);\n\t\t\tmi_heap_stat_counter_increase(heap, huge_count, 1);\n\t\t}\n\t}\n\treturn page;\n```",
      "range": {
        "startLine": 828,
        "startChar": 0,
        "endLine": 864,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eef1c75a_ce0c8f11",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 888,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_find_page(mi_heap_t* heap, size_t size, size_t huge_alignment) mi_attr_noexcept\n{\n\t// huge allocation?\n\tconst size_t req_size\n\t\t\u003d size - MI_PADDING_SIZE; // correct for padding_size in case of an overflow on `size`\n\tif mi_unlikely (req_size \u003e (MI_MEDIUM_OBJ_SIZE_MAX - MI_PADDING_SIZE) || huge_alignment \u003e 0) {\n\t\tif mi_unlikely (req_size\n\t\t\t\u003e PTRDIFF_MAX) { // we don\u0027t allocate more than PTRDIFF_MAX (see\n\t\t\t\t\t\t\t // \u003chttps://sourceware.org/ml/libc-announce/2019/msg00001.html\u003e)\n\t\t\t_mi_error_message(EOVERFLOW, \"allocation request is too large (%zu bytes)\\n\", req_size);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\treturn mi_large_huge_page_alloc(heap, size, huge_alignment);\n\t\t}\n\t} else {\n// otherwise find a page with free blocks in our size segregated queues\n#if MI_PADDING\n\t\tmi_assert_internal(size \u003e\u003d MI_PADDING_SIZE);\n#endif\n\t\treturn mi_find_free_page(heap, size);\n\t}\n```",
      "range": {
        "startLine": 870,
        "startChar": 0,
        "endLine": 888,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30c1ea00_9000ee99",
        "filename": "src/system/libroot/posix/malloc/mimalloc/page.c",
        "patchSetId": 7
      },
      "lineNbr": 939,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid*\n_mi_malloc_generic(mi_heap_t* heap, size_t size, bool zero, size_t huge_alignment) mi_attr_noexcept\n{\n\tmi_assert_internal(heap !\u003d NULL);\n\n\t// initialize if necessary\n\tif mi_unlikely (!mi_heap_is_initialized(heap)) {\n\t\theap \u003d mi_heap_get_default(); // calls mi_thread_init\n\t\tif mi_unlikely (!mi_heap_is_initialized(heap))\n\t\t\treturn NULL;\n\t}\n\tmi_assert_internal(mi_heap_is_initialized(heap));\n\n\t// call potential deferred free routines\n\t_mi_deferred_free(heap, false);\n\n\t// free delayed frees from other threads (but skip contended ones)\n\t_mi_heap_delayed_free_partial(heap);\n\n\t// find (or allocate) a page of the right size\n\tmi_page_t* page \u003d mi_find_page(heap, size, huge_alignment);\n\tif mi_unlikely (page\n\t\t\u003d\u003d NULL) { // first time out of memory, try to collect and retry the allocation once more\n\t\tmi_heap_collect(heap, true /* force */);\n\t\tpage \u003d mi_find_page(heap, size, huge_alignment);\n\t}\n\n\tif mi_unlikely (page \u003d\u003d NULL) { // out of memory\n\t\tconst size_t req_size\n\t\t\t\u003d size - MI_PADDING_SIZE; // correct for padding_size in case of an overflow on `size`\n\t\t_mi_error_message(ENOMEM, \"unable to allocate memory (%zu bytes)\\n\", req_size);\n\t\treturn NULL;\n\t}\n\n\tmi_assert_internal(mi_page_immediate_available(page));\n\tmi_assert_internal(mi_page_block_size(page) \u003e\u003d size);\n\n\t// and try again, this time succeeding! (i.e. this should never recurse through _mi_page_malloc)\n\tif mi_unlikely (zero \u0026\u0026 page-\u003exblock_size \u003d\u003d 0) {\n\t\t// note: we cannot call _mi_page_malloc with zeroing for huge blocks; we zero it afterwards\n\t\t// in that case.\n\t\tvoid* p \u003d _mi_page_malloc(heap, page, size, false);\n\t\tmi_assert_internal(p !\u003d NULL);\n\t\t_mi_memzero_aligned(p, mi_page_usable_block_size(page));\n\t\treturn p;\n\t} else {\n\t\treturn _mi_page_malloc(heap, page, size, zero);\n\t}\n}\n```",
      "range": {
        "startLine": 895,
        "startChar": 0,
        "endLine": 939,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c4ffae1d_62b75dd6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 11,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define _DEFAULT_SOURCE // ensure mmap flags and syscall are defined\n```",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 11,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "886abe27_81353d2a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 23,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 23,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d717a010_edec025b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 25,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1626da97_12847ffe",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 29,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003csys/mman.h\u003e // mmap\n#include \u003cunistd.h\u003e // sysconf\n```",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5f27b2be_d1145d44",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 38,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cfcntl.h\u003e\n#include \u003cfeatures.h\u003e\n#if defined(__GLIBC__)\n#include \u003clinux/mman.h\u003e // linux mmap flags\n#else\n#include \u003csys/mman.h\u003e\n#endif\n```",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 38,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63b2233b_b593b7ab",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 43,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cTargetConditionals.h\u003e\n#if !TARGET_IOS_IPHONE \u0026\u0026 !TARGET_IOS_SIMULATOR\n#include \u003cmach/vm_statistics.h\u003e\n#endif\n```",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 43,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3621f00b_2e4767b5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 50,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003csys/param.h\u003e\n#if __FreeBSD_version \u003e\u003d 1200000\n#include \u003csys/cpuset.h\u003e\n#include \u003csys/domainset.h\u003e\n#endif\n#include \u003csys/sysctl.h\u003e\n```",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 50,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21520299_379480d3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_HAS_SYSCALL_H\n#include \u003csys/syscall.h\u003e\n```",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 55,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "02bb687a_e1b56489",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 95,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if defined(MI_HAS_SYSCALL_H) \u0026\u0026 defined(SYS_open) \u0026\u0026 defined(SYS_close) \u0026\u0026 defined(SYS_read) \\\n\t\u0026\u0026 defined(SYS_access)\n\n\nstatic int\nmi_prim_open(const char* fpath, int open_flags)\n{\n\treturn syscall(SYS_open, fpath, open_flags, 0);\n}\n\n\nstatic ssize_t\nmi_prim_read(int fd, void* buf, size_t bufsize)\n{\n\treturn syscall(SYS_read, fd, buf, bufsize);\n}\n\n\nstatic int\nmi_prim_close(int fd)\n{\n\treturn syscall(SYS_close, fd);\n}\n\n\nstatic int\nmi_prim_access(const char* fpath, int mode)\n{\n\treturn syscall(SYS_access, fpath, mode);\n}\n\n#elif !defined(__APPLE__) // avoid unused warnings\n\n\nstatic int\nmi_prim_open(const char* fpath, int open_flags)\n{\n\treturn open(fpath, open_flags);\n}\n\n\nstatic ssize_t\nmi_prim_read(int fd, void* buf, size_t bufsize)\n{\n\treturn read(fd, buf, bufsize);\n}\n\n\nstatic int\nmi_prim_close(int fd)\n{\n\treturn close(fd);\n}\n\n\nstatic int\nmi_prim_access(const char* fpath, int mode)\n{\n\treturn access(fpath, mode);\n}\n\n#endif\n```",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 95,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "36f541ef_c0824d4b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 103,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nunix_detect_overcommit(void)\n{\n\tbool os_overcommit \u003d true;\n```",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 103,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c6d831f_eedfeb2f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 105,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tint fd \u003d mi_prim_open(\"/proc/sys/vm/overcommit_memory\", O_RDONLY);\n```",
      "range": {
        "startLine": 105,
        "startChar": 0,
        "endLine": 105,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dc019ed0_2976cbd2",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 115,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\tchar buf[32];\n\t\tssize_t nread \u003d mi_prim_read(fd, \u0026buf, sizeof(buf));\n\t\tmi_prim_close(fd);\n\t\t// \u003chttps://www.kernel.org/doc/Documentation/vm/overcommit-accounting\u003e\n\t\t// 0: heuristic overcommit, 1: always overcommit, 2: never overcommit (ignore NORESERVE)\n\t\tif (nread \u003e\u003d 1)\n\t\t\tos_overcommit \u003d (buf[0] \u003d\u003d \u00270\u0027 || buf[0] \u003d\u003d \u00271\u0027);\n\t}\n```",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 115,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2338ca1b_49020915",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 121,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tint val \u003d 0;\n\tsize_t olen \u003d sizeof(val);\n\tif (sysctlbyname(\"vm.overcommit\", \u0026val, \u0026olen, NULL, 0) \u003d\u003d 0)\n\t\tos_overcommit \u003d (val !\u003d 0);\n```",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 121,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c29b42f6_300246a9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 139,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tos_overcommit \u003d false;\n#else\n\t// default: overcommit is true\n#endif\n\treturn os_overcommit;\n}\n\n\nvoid\n_mi_prim_mem_init(mi_os_mem_config_t* config)\n{\n\tlong psize \u003d sysconf(_SC_PAGESIZE);\n\tif (psize \u003e 0) {\n\t\tconfig-\u003epage_size \u003d (size_t)psize;\n\t\tconfig-\u003ealloc_granularity \u003d (size_t)psize;\n\t}\n\tconfig-\u003elarge_page_size \u003d 2 * MI_MiB; // TODO: can we query the OS for this?\n\tconfig-\u003ehas_overcommit \u003d unix_detect_overcommit();\n\tconfig-\u003emust_free_whole \u003d false; // mmap can free in parts\n\tconfig-\u003ehas_virtual_reserve\n\t\t\u003d true; // todo: check if this true for NetBSD?  (for anonymous mmap with PROT_NONE)\n```",
      "range": {
        "startLine": 123,
        "startChar": 0,
        "endLine": 139,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "13326b0c_069e7553",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 149,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nint\n_mi_prim_free(void* addr, size_t size)\n{\n\tbool err \u003d (munmap(addr, size) \u003d\u003d -1);\n\treturn err ? errno : 0;\n```",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 149,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a17edf40_101dce83",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 336,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic int\nunix_madvise(void* addr, size_t size, int advice)\n{\n#if defined(__sun)\n\treturn madvise((caddr_t)addr, size, advice); // Solaris needs cast (issue #520)\n#else\n\treturn madvise(addr, size, advice);\n#endif\n}\n\n\nstatic void*\nunix_mmap_prim(void* addr, size_t size, size_t try_alignment, int protect_flags, int flags, int fd)\n{\n\tMI_UNUSED(try_alignment);\n\tvoid* p \u003d NULL;\n#if defined(MAP_ALIGNED) // BSD\n\tif (addr \u003d\u003d NULL \u0026\u0026 try_alignment \u003e 1 \u0026\u0026 (try_alignment % _mi_os_page_size()) \u003d\u003d 0) {\n\t\tsize_t n \u003d mi_bsr(try_alignment);\n\t\tif (((size_t)1 \u003c\u003c n) \u003d\u003d try_alignment \u0026\u0026 n \u003e\u003d 12\n\t\t\t\u0026\u0026 n \u003c\u003d 30) { // alignment is a power of 2 and 4096 \u003c\u003d alignment \u003c\u003d 1GiB\n\t\t\tp \u003d mmap(addr, size, protect_flags, flags | MAP_ALIGNED(n), fd, 0);\n\t\t\tif (p \u003d\u003d MAP_FAILED || !_mi_is_aligned(p, try_alignment)) {\n\t\t\t\tint err \u003d errno;\n\t\t\t\t_mi_warning_message(\n\t\t\t\t\t\"unable to directly request aligned OS memory (error: %d (0x%x), size: 0x%zx \"\n\t\t\t\t\t\"bytes, alignment: 0x%zx, hint address: %p)\\n\",\n\t\t\t\t\terr, err, size, try_alignment, addr);\n\t\t\t}\n\t\t\tif (p !\u003d MAP_FAILED)\n\t\t\t\treturn p;\n\t\t\t// fall back to regular mmap\n\t\t}\n\t}\n#elif defined(MAP_ALIGN) // Solaris\n\tif (addr \u003d\u003d NULL \u0026\u0026 try_alignment \u003e 1 \u0026\u0026 (try_alignment % _mi_os_page_size()) \u003d\u003d 0) {\n\t\tp \u003d mmap((void*)try_alignment, size, protect_flags, flags | MAP_ALIGN, fd,\n\t\t\t0); // addr parameter is the required alignment\n\t\tif (p !\u003d MAP_FAILED)\n\t\t\treturn p;\n\t\t// fall back to regular mmap\n\t}\n#endif\n#if (MI_INTPTR_SIZE \u003e\u003d 8) \u0026\u0026 !defined(MAP_ALIGNED) \u0026\u0026 !defined(__HAIKU__)\n\t// on 64-bit systems, use the virtual address area after 2TiB for 4MiB aligned allocations\n\tif (addr \u003d\u003d NULL) {\n\t\tvoid* hint \u003d _mi_os_get_aligned_hint(try_alignment, size);\n\t\tif (hint !\u003d NULL) {\n\t\t\tp \u003d mmap(hint, size, protect_flags, flags, fd, 0);\n\t\t\tif (p \u003d\u003d MAP_FAILED || !_mi_is_aligned(p, try_alignment)) {\n#if MI_TRACK_ENABLED // asan sometimes does not instrument errno correctly?\n\t\t\t\tint err \u003d 0;\n#else\n\t\t\t\tint err \u003d errno;\n#endif\n\t\t\t\t_mi_warning_message(\n\t\t\t\t\t\"unable to directly request hinted aligned OS memory (error: %d (0x%x), size: \"\n\t\t\t\t\t\"0x%zx bytes, alignment: 0x%zx, hint address: %p)\\n\",\n\t\t\t\t\terr, err, size, try_alignment, hint);\n\t\t\t}\n\t\t\tif (p !\u003d MAP_FAILED)\n\t\t\t\treturn p;\n\t\t\t// fall back to regular mmap\n\t\t}\n\t}\n#endif\n\t// regular mmap\n\tp \u003d mmap(addr, size, protect_flags, flags, fd, 0);\n\tif (p !\u003d MAP_FAILED)\n\t\treturn p;\n\t// failed to allocate\n\treturn NULL;\n}\n\n\nstatic int\nunix_mmap_fd(void)\n{\n#if defined(VM_MAKE_TAG)\n\t// macOS: tracking anonymous page with a specific ID. (All up to 98 are taken officially but\n\t// LLVM sanitizers had taken 99)\n\tint os_tag \u003d (int)mi_option_get(mi_option_os_tag);\n\tif (os_tag \u003c 100 || os_tag \u003e 255)\n\t\tos_tag \u003d 100;\n\treturn VM_MAKE_TAG(os_tag);\n#else\n\treturn -1;\n#endif\n}\n\n\nstatic void*\nunix_mmap(void* addr, size_t size, size_t try_alignment, int protect_flags, bool large_only,\n\tbool allow_large, bool* is_large)\n{\n#if !defined(MAP_ANONYMOUS)\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#if !defined(MAP_NORESERVE)\n#define MAP_NORESERVE 0\n#endif\n\tvoid* p \u003d NULL;\n\tconst int fd \u003d unix_mmap_fd();\n\tint flags \u003d MAP_PRIVATE | MAP_ANONYMOUS;\n\tif (_mi_os_has_overcommit())\n\t\tflags |\u003d MAP_NORESERVE;\n#if defined(PROT_MAX)\n\tprotect_flags |\u003d PROT_MAX(PROT_READ | PROT_WRITE); // BSD\n#endif\n\t// huge page allocation\n\tif ((large_only || _mi_os_use_large_page(size, try_alignment)) \u0026\u0026 allow_large) {\n\t\tstatic _Atomic(size_t) large_page_try_ok; // \u003d 0;\n\t\tsize_t try_ok \u003d mi_atomic_load_acquire(\u0026large_page_try_ok);\n\t\tif (!large_only \u0026\u0026 try_ok \u003e 0) {\n\t\t\t// If the OS is not configured for large OS pages, or the user does not have\n\t\t\t// enough permission, the `mmap` will always fail (but it might also fail for other\n\t\t\t// reasons). Therefore, once a large page allocation failed, we don\u0027t try again for\n\t\t\t// `large_page_try_ok` times to avoid too many failing calls to mmap.\n\t\t\tmi_atomic_cas_strong_acq_rel(\u0026large_page_try_ok, \u0026try_ok, try_ok - 1);\n\t\t} else {\n\t\t\tint lflags\n\t\t\t\t\u003d flags \u0026 ~MAP_NORESERVE; // using NORESERVE on huge pages seems to fail on Linux\n\t\t\tint lfd \u003d fd;\n#ifdef MAP_ALIGNED_SUPER\n\t\t\tlflags |\u003d MAP_ALIGNED_SUPER;\n#endif\n#ifdef MAP_HUGETLB\n\t\t\tlflags |\u003d MAP_HUGETLB;\n#endif\n#ifdef MAP_HUGE_1GB\n\t\t\tstatic bool mi_huge_pages_available \u003d true;\n\t\t\tif ((size % MI_GiB) \u003d\u003d 0 \u0026\u0026 mi_huge_pages_available) {\n\t\t\t\tlflags |\u003d MAP_HUGE_1GB;\n\t\t\t} else\n#endif\n\t\t\t{\n#ifdef MAP_HUGE_2MB\n\t\t\t\tlflags |\u003d MAP_HUGE_2MB;\n#endif\n\t\t\t}\n#ifdef VM_FLAGS_SUPERPAGE_SIZE_2MB\n\t\t\tlfd |\u003d VM_FLAGS_SUPERPAGE_SIZE_2MB;\n#endif\n\t\t\tif (large_only || lflags !\u003d flags) {\n\t\t\t\t// try large OS page allocation\n\t\t\t\t*is_large \u003d true;\n\t\t\t\tp \u003d unix_mmap_prim(addr, size, try_alignment, protect_flags, lflags, lfd);\n#ifdef MAP_HUGE_1GB\n\t\t\t\tif (p \u003d\u003d NULL \u0026\u0026 (lflags \u0026 MAP_HUGE_1GB) !\u003d 0) {\n\t\t\t\t\tmi_huge_pages_available \u003d false; // don\u0027t try huge 1GiB pages again\n\t\t\t\t\t_mi_warning_message(\"unable to allocate huge (1GiB) page, trying large (2MiB) \"\n\t\t\t\t\t\t\t\t\t\t\"pages instead (errno: %i)\\n\",\n\t\t\t\t\t\terrno);\n\t\t\t\t\tlflags \u003d ((lflags \u0026 ~MAP_HUGE_1GB) | MAP_HUGE_2MB);\n\t\t\t\t\tp \u003d unix_mmap_prim(addr, size, try_alignment, protect_flags, lflags, lfd);\n\t\t\t\t}\n#endif\n\t\t\t\tif (large_only)\n\t\t\t\t\treturn p;\n\t\t\t\tif (p \u003d\u003d NULL) {\n\t\t\t\t\tmi_atomic_store_release(\u0026large_page_try_ok,\n\t\t\t\t\t\t(size_t)8); // on error, don\u0027t try again for the next N allocations\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// regular allocation\n\tif (p \u003d\u003d NULL) {\n\t\t*is_large \u003d false;\n\t\tp \u003d unix_mmap_prim(addr, size, try_alignment, protect_flags, flags, fd);\n\t\tif (p !\u003d NULL) {\n#if defined(MADV_HUGEPAGE)\n\t\t\t// Many Linux systems don\u0027t allow MAP_HUGETLB but they support instead\n\t\t\t// transparent huge pages (THP). Generally, it is not required to call `madvise` with\n\t\t\t// MADV_HUGE though since properly aligned allocations will already use large pages if\n\t\t\t// available in that case -- in particular for our large regions (in `memory.c`).\n\t\t\t// However, some systems only allow THP if called with explicit `madvise`, so\n\t\t\t// when large OS pages are enabled for mimalloc, we call `madvise` anyways.\n\t\t\tif (allow_large \u0026\u0026 _mi_os_use_large_page(size, try_alignment)) {\n\t\t\t\tif (unix_madvise(p, size, MADV_HUGEPAGE) \u003d\u003d 0)\n\t\t\t\t\t*is_large \u003d true; // possibly\n\t\t\t\t;\n\t\t\t}\n#elif defined(__sun)\n\t\t\tif (allow_large \u0026\u0026 _mi_os_use_large_page(size, try_alignment)) {\n\t\t\t\tstruct memcntl_mha cmd \u003d {0};\n\t\t\t\tcmd.mha_pagesize \u003d large_os_page_size;\n\t\t\t\tcmd.mha_cmd \u003d MHA_MAPSIZE_VA;\n\t\t\t\tif (memcntl((caddr_t)p, size, MC_HAT_ADVISE, (caddr_t)\u0026cmd, 0, 0) \u003d\u003d 0)\n\t\t\t\t\t*is_large \u003d true;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\treturn p;\n}\n\n// Note: the `try_alignment` is just a hint and the returned pointer is not guaranteed to be\n// aligned.\nint\n_mi_prim_alloc(size_t size, size_t try_alignment, bool commit, bool allow_large, bool* is_large,\n\tbool* is_zero, void** addr)\n{\n\tmi_assert_internal(size \u003e 0 \u0026\u0026 (size % _mi_os_page_size()) \u003d\u003d 0);\n\tmi_assert_internal(commit || !allow_large);\n\tmi_assert_internal(try_alignment \u003e 0);\n\n\t*is_zero \u003d true;\n\tint protect_flags \u003d (commit ? (PROT_WRITE | PROT_READ) : PROT_NONE);\n\t*addr \u003d unix_mmap(NULL, size, try_alignment, protect_flags, false, allow_large, is_large);\n\treturn *addr !\u003d NULL ? 0 : errno;\n```",
      "range": {
        "startLine": 157,
        "startChar": 0,
        "endLine": 336,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f454d6ef_63d3413e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 372,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nunix_mprotect_hint(int err)\n{\n#if defined(__linux__) \u0026\u0026 (MI_SECURE \u003e\u003d 2) // guard page around every mimalloc page\n\tif (err \u003d\u003d ENOMEM) {\n\t\t_mi_warning_message(\n\t\t\t\"The next warning may be caused by a low memory map limit.\\n\"\n\t\t\t\"  On Linux this is controlled by the vm.max_map_count -- maybe increase it?\\n\"\n\t\t\t\"  For example: sudo sysctl -w vm.max_map_count\u003d262144\\n\");\n\t}\n#else\n\tMI_UNUSED(err);\n#endif\n}\n\n\nint\n_mi_prim_commit(void* start, size_t size, bool* is_zero)\n{\n\t// commit: ensure we can access the area\n\t// note: we may think that *is_zero can be true since the memory\n\t// was either from mmap PROT_NONE, or from decommit MADV_DONTNEED, but\n\t// we sometimes call commit on a range with still partially committed\n\t// memory and `mprotect` does not zero the range.\n\t*is_zero \u003d false;\n\tint err \u003d mprotect(start, size, (PROT_READ | PROT_WRITE));\n\tif (err !\u003d 0) {\n\t\terr \u003d errno;\n\t\tunix_mprotect_hint(err);\n\t}\n\treturn err;\n}\n\n\nint\n_mi_prim_decommit(void* start, size_t size, bool* needs_recommit)\n{\n\tint err \u003d 0;\n```",
      "range": {
        "startLine": 344,
        "startChar": 0,
        "endLine": 372,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a2af5bea_d29ee222",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 424,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmprotect(start, size, PROT_NONE);\n\terr \u003d unix_madvise(start, size, MADV_FREE);\n\t*needs_recommit \u003d true;\n#else\n\t// decommit: use MADV_DONTNEED as it decreases rss immediately (unlike MADV_FREE)\n\terr \u003d unix_madvise(start, size, MADV_DONTNEED);\n#if !MI_DEBUG \u0026\u0026 !MI_SECURE\n\t*needs_recommit \u003d false;\n#else\n\t*needs_recommit \u003d true;\n\tmprotect(start, size, PROT_NONE);\n#endif\n\t/*\n\t// decommit: use mmap with MAP_FIXED and PROT_NONE to discard the existing memory (and reduce\n\trss) *needs_recommit \u003d true; const int fd \u003d unix_mmap_fd(); void* p \u003d mmap(start, size,\n\tPROT_NONE, (MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE), fd, 0); if (p !\u003d start) {\n\terr \u003d errno; }\n\t*/\n#endif\n\treturn err;\n}\n\n\nint\n_mi_prim_reset(void* start, size_t size)\n{\n// We try to use `MADV_FREE` as that is the fastest. A drawback though is that it\n// will not reduce the `rss` stats in tools like `top` even though the memory is available\n// to other processes. With the default `MIMALLOC_PURGE_DECOMMITS\u003d1` we ensure that by\n// default `MADV_DONTNEED` is used though.\n#if defined(MADV_FREE)\n\tstatic _Atomic(size_t) advice \u003d MI_ATOMIC_VAR_INIT(MADV_FREE);\n\tint oadvice \u003d (int)mi_atomic_load_relaxed(\u0026advice);\n\tint err;\n\twhile ((err \u003d unix_madvise(start, size, oadvice)) !\u003d 0 \u0026\u0026 errno \u003d\u003d EAGAIN)\n\t\terrno \u003d 0;\n\t;\n\tif (err !\u003d 0 \u0026\u0026 errno \u003d\u003d EINVAL \u0026\u0026 oadvice \u003d\u003d MADV_FREE) {\n\t\t// if MADV_FREE is not supported, fall back to MADV_DONTNEED from now on\n\t\tmi_atomic_store_release(\u0026advice, (size_t)MADV_DONTNEED);\n\t\terr \u003d unix_madvise(start, size, MADV_DONTNEED);\n\t}\n#else\n\tint err \u003d unix_madvise(start, size, MADV_DONTNEED);\n#endif\n\treturn err;\n}\n\n\nint\n_mi_prim_protect(void* start, size_t size, bool protect)\n{\n\tint err \u003d mprotect(start, size, protect ? PROT_NONE : (PROT_READ | PROT_WRITE));\n\tif (err !\u003d 0)\n\t\terr \u003d errno;\n\tunix_mprotect_hint(err);\n\treturn err;\n}\n```",
      "range": {
        "startLine": 374,
        "startChar": 0,
        "endLine": 424,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8d0215fb_b56e7ef8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 472,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic long\nmi_prim_mbind(void* start, unsigned long len, unsigned long mode, const unsigned long* nmask,\n\tunsigned long maxnode, unsigned flags)\n{\n\treturn syscall(SYS_mbind, start, len, mode, nmask, maxnode, flags);\n}\n#else\n\n\nstatic long\nmi_prim_mbind(void* start, unsigned long len, unsigned long mode, const unsigned long* nmask,\n\tunsigned long maxnode, unsigned flags)\n{\n\tMI_UNUSED(start);\n\tMI_UNUSED(len);\n\tMI_UNUSED(mode);\n\tMI_UNUSED(nmask);\n\tMI_UNUSED(maxnode);\n\tMI_UNUSED(flags);\n\treturn 0;\n}\n#endif\n\n\nint\n_mi_prim_alloc_huge_os_pages(void* hint_addr, size_t size, int numa_node, bool* is_zero,\n\tvoid** addr)\n{\n\tbool is_large \u003d true;\n\t*is_zero \u003d true;\n\t*addr \u003d unix_mmap(hint_addr, size, MI_SEGMENT_SIZE, PROT_READ | PROT_WRITE, true, true,\n\t\t\u0026is_large);\n\tif (*addr !\u003d NULL \u0026\u0026 numa_node \u003e\u003d 0 \u0026\u0026 numa_node \u003c 8 * MI_INTPTR_SIZE) { // at most 64 nodes\n\t\tunsigned long numa_mask \u003d (1UL \u003c\u003c numa_node);\n\t\t// TODO: does `mbind` work correctly for huge OS pages? should we\n\t\t// use `set_mempolicy` before calling mmap instead?\n\t\t// see: \u003chttps://lkml.org/lkml/2017/2/9/875\u003e\n\t\tlong err \u003d mi_prim_mbind(*addr, size, MPOL_PREFERRED, \u0026numa_mask, 8 * MI_INTPTR_SIZE, 0);\n\t\tif (err !\u003d 0) {\n\t\t\terr \u003d errno;\n\t\t\t_mi_warning_message(\n\t\t\t\t\"failed to bind huge (1GiB) pages to numa node %d (error: %d (0x%x))\\n\", numa_node,\n\t\t\t\terr, err);\n\t\t}\n\t}\n\treturn *addr !\u003d NULL ? 0 : errno;\n}\n\n#else\n\n\nint\n_mi_prim_alloc_huge_os_pages(void* hint_addr, size_t size, int numa_node, bool* is_zero,\n\tvoid** addr)\n{\n\tMI_UNUSED(hint_addr);\n\tMI_UNUSED(size);\n\tMI_UNUSED(numa_node);\n\t*is_zero \u003d false;\n\t*addr \u003d NULL;\n\treturn ENOMEM;\n```",
      "range": {
        "startLine": 438,
        "startChar": 0,
        "endLine": 472,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c06babfa_5ae1a03f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 505,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cstdio.h\u003e // snprintf\n\n\nsize_t\n_mi_prim_numa_node(void)\n{\n#if defined(MI_HAS_SYSCALL_H) \u0026\u0026 defined(SYS_getcpu)\n\tunsigned long node \u003d 0;\n\tunsigned long ncpu \u003d 0;\n\tlong err \u003d syscall(SYS_getcpu, \u0026ncpu, \u0026node, NULL);\n\tif (err !\u003d 0)\n\t\treturn 0;\n\treturn node;\n#else\n\treturn 0;\n#endif\n}\n\n\nsize_t\n_mi_prim_numa_node_count(void)\n{\n\tchar buf[128];\n\tunsigned node \u003d 0;\n\tfor (node \u003d 0; node \u003c 256; node++) {\n\t\t// enumerate node entries -- todo: it there a more efficient way to do this? (but ensure\n\t\t// there is no allocation)\n\t\tsnprintf(buf, 127, \"/sys/devices/system/node/node%u\", node + 1);\n\t\tif (mi_prim_access(buf, R_OK) !\u003d 0)\n\t\t\tbreak;\n\t}\n\treturn node + 1;\n```",
      "range": {
        "startLine": 483,
        "startChar": 0,
        "endLine": 505,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "117fc5c0_e839d1d9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 525,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nsize_t\n_mi_prim_numa_node(void)\n{\n\tdomainset_t dom;\n\tsize_t node;\n\tint policy;\n\tif (cpuset_getdomain(CPU_LEVEL_CPUSET, CPU_WHICH_PID, -1, sizeof(dom), \u0026dom, \u0026policy) \u003d\u003d -1)\n\t\treturn 0ul;\n\tfor (node \u003d 0; node \u003c MAXMEMDOM; node++) {\n\t\tif (DOMAINSET_ISSET(node, \u0026dom))\n\t\t\treturn node;\n\t}\n\treturn 0ul;\n}\n\n\nsize_t\n_mi_prim_numa_node_count(void)\n{\n\tsize_t ndomains \u003d 0;\n\tsize_t len \u003d sizeof(ndomains);\n\tif (sysctlbyname(\"vm.ndomains\", \u0026ndomains, \u0026len, NULL, 0) \u003d\u003d -1)\n\t\treturn 0ul;\n\treturn ndomains;\n```",
      "range": {
        "startLine": 510,
        "startChar": 0,
        "endLine": 525,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3e265d96_0125278b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 550,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nsize_t\n_mi_prim_numa_node(void)\n{\n\t// TODO: DragonFly does not seem to provide any userland means to get this information.\n\treturn 0ul;\n}\n\n\nsize_t\n_mi_prim_numa_node_count(void)\n{\n\tsize_t ncpus \u003d 0, nvirtcoresperphys \u003d 0;\n\tsize_t len \u003d sizeof(size_t);\n\tif (sysctlbyname(\"hw.ncpu\", \u0026ncpus, \u0026len, NULL, 0) \u003d\u003d -1)\n\t\treturn 0ul;\n\tif (sysctlbyname(\"hw.cpu_topology_ht_ids\", \u0026nvirtcoresperphys, \u0026len, NULL, 0) \u003d\u003d -1)\n\t\treturn 0ul;\n\treturn nvirtcoresperphys * ncpus;\n}\n\n#else\n\n\nsize_t\n_mi_prim_numa_node(void)\n{\n\treturn 0;\n}\n\n\nsize_t\n_mi_prim_numa_node_count(void)\n{\n\treturn 1;\n```",
      "range": {
        "startLine": 530,
        "startChar": 0,
        "endLine": 550,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd0abea6_ae3c1119",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 570,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nmi_msecs_t\n_mi_prim_clock_now(void)\n{\n\tstruct timespec t;\n#ifdef CLOCK_MONOTONIC\n\tclock_gettime(CLOCK_MONOTONIC, \u0026t);\n#else\n\tclock_gettime(CLOCK_REALTIME, \u0026t);\n#endif\n\treturn ((mi_msecs_t)t.tv_sec * 1000) + ((mi_msecs_t)t.tv_nsec / 1000000);\n```",
      "range": {
        "startLine": 563,
        "startChar": 0,
        "endLine": 570,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4928b511_98e49b45",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 588,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_msecs_t\n_mi_prim_clock_now(void)\n{\n#if !defined(CLOCKS_PER_SEC) || (CLOCKS_PER_SEC \u003d\u003d 1000) || (CLOCKS_PER_SEC \u003d\u003d 0)\n\treturn (mi_msecs_t)clock();\n#elif (CLOCKS_PER_SEC \u003c 1000)\n\treturn (mi_msecs_t)clock() * (1000 / (mi_msecs_t)CLOCKS_PER_SEC);\n#else\n\treturn (mi_msecs_t)clock() / ((mi_msecs_t)CLOCKS_PER_SEC / 1000);\n#endif\n}\n\n#endif\n```",
      "range": {
        "startLine": 576,
        "startChar": 0,
        "endLine": 588,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8b06055a_86dcd159",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 595,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if defined(__unix__) || defined(__unix) || defined(unix) || defined(__APPLE__) \\\n\t|| defined(__HAIKU__)\n```",
      "range": {
        "startLine": 595,
        "startChar": 0,
        "endLine": 595,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d6576a4_e5582e74",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 596,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \u003csys/resource.h\u003e\n```",
      "range": {
        "startLine": 596,
        "startChar": 0,
        "endLine": 596,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ed8be7e_d6134625",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 598,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 598,
        "startChar": 0,
        "endLine": 598,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8077ec44_7114750a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 617,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic mi_msecs_t\ntimeval_secs(const struct timeval* tv)\n{\n\treturn ((mi_msecs_t)tv-\u003etv_sec * 1000L) + ((mi_msecs_t)tv-\u003etv_usec / 1000L);\n}\n\n\nvoid\n_mi_prim_process_info(mi_process_info_t* pinfo)\n{\n\tstruct rusage rusage;\n\tgetrusage(RUSAGE_SELF, \u0026rusage);\n\tpinfo-\u003eutime \u003d timeval_secs(\u0026rusage.ru_utime);\n\tpinfo-\u003estime \u003d timeval_secs(\u0026rusage.ru_stime);\n```",
      "range": {
        "startLine": 608,
        "startChar": 0,
        "endLine": 617,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce81c44f_cb74f1c6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 619,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tpinfo-\u003epage_faults \u003d rusage.ru_majflt;\n```",
      "range": {
        "startLine": 619,
        "startChar": 0,
        "endLine": 619,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "efa2b09b_1cd0087a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 631,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// Haiku does not have (yet?) a way to\n\t// get these stats per process\n\tthread_info tid;\n\tarea_info mem;\n\tssize_t c;\n\tget_thread_info(find_thread(0), \u0026tid);\n\twhile (get_next_area_info(tid.team, \u0026c, \u0026mem) \u003d\u003d B_OK)\n\t\tpinfo-\u003epeak_rss +\u003d mem.ram_size;\n\tpinfo-\u003epage_faults \u003d 0;\n```",
      "range": {
        "startLine": 622,
        "startChar": 0,
        "endLine": 631,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d8d51dd0_9de246d4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 650,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tpinfo-\u003epeak_rss \u003d rusage.ru_maxrss; // macos reports in bytes\n#ifdef MACH_TASK_BASIC_INFO\n\tstruct mach_task_basic_info info;\n\tmach_msg_type_number_t infoCount \u003d MACH_TASK_BASIC_INFO_COUNT;\n\tif (task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)\u0026info, \u0026infoCount)\n\t\t\u003d\u003d KERN_SUCCESS) {\n\t\tpinfo-\u003ecurrent_rss \u003d (size_t)info.resident_size;\n\t}\n#else\n\tstruct task_basic_info info;\n\tmach_msg_type_number_t infoCount \u003d TASK_BASIC_INFO_COUNT;\n\tif (task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)\u0026info, \u0026infoCount)\n\t\t\u003d\u003d KERN_SUCCESS) {\n\t\tpinfo-\u003ecurrent_rss \u003d (size_t)info.resident_size;\n\t}\n#endif\n#else\n\tpinfo-\u003epeak_rss \u003d rusage.ru_maxrss * 1024; // Linux/BSD report in KiB\n#endif\n\t// use defaults for commit\n```",
      "range": {
        "startLine": 633,
        "startChar": 0,
        "endLine": 650,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e5c62404_a259b2f4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 663,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n_mi_prim_process_info(mi_process_info_t* pinfo)\n{\n\t// use defaults\n\tMI_UNUSED(pinfo);\n```",
      "range": {
        "startLine": 660,
        "startChar": 0,
        "endLine": 663,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ed4351a_9e3882cc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 674,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_prim_out_stderr(const char* msg)\n{\n\tfputs(msg, stderr);\n```",
      "range": {
        "startLine": 673,
        "startChar": 0,
        "endLine": 674,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be6a7748_f226368b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 682,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if !defined(MI_USE_ENVIRON) || (MI_USE_ENVIRON !\u003d 0)\n```",
      "range": {
        "startLine": 682,
        "startChar": 0,
        "endLine": 682,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3437358_a5431281",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 688,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic char**\nmi_get_environ(void)\n{\n\treturn *_NSGetEnviron();\n```",
      "range": {
        "startLine": 687,
        "startChar": 0,
        "endLine": 688,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "172ae856_24ba7c50",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 711,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nstatic char**\nmi_get_environ(void)\n{\n\treturn environ;\n}\n#endif\n\n\nbool\n_mi_prim_getenv(const char* name, char* result, size_t result_size)\n{\n\tif (name \u003d\u003d NULL)\n\t\treturn false;\n\tconst size_t len \u003d _mi_strlen(name);\n\tif (len \u003d\u003d 0)\n\t\treturn false;\n\tchar** env \u003d mi_get_environ();\n\tif (env \u003d\u003d NULL)\n\t\treturn false;\n\t// compare up to 10000 entries\n\tfor (int i \u003d 0; i \u003c 10000 \u0026\u0026 env[i] !\u003d NULL; i++) {\n\t\tconst char* s \u003d env[i];\n\t\tif (_mi_strnicmp(name, s, len) \u003d\u003d 0 \u0026\u0026 s[len] \u003d\u003d \u0027\u003d\u0027) { // case insensitive\n\t\t\t// found it\n\t\t\t_mi_strlcpy(result, s + len + 1, result_size);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n```",
      "range": {
        "startLine": 692,
        "startChar": 0,
        "endLine": 711,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb386b90_ccc6b774",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 733,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nbool\n_mi_prim_getenv(const char* name, char* result, size_t result_size)\n{\n\t// cannot call getenv() when still initializing the C runtime.\n\tif (_mi_preloading())\n\t\treturn false;\n\tconst char* s \u003d getenv(name);\n\tif (s \u003d\u003d NULL) {\n\t\t// we check the upper case name too.\n\t\tchar buf[64 + 1];\n\t\tsize_t len \u003d _mi_strnlen(name, sizeof(buf) - 1);\n\t\tfor (size_t i \u003d 0; i \u003c len; i++)\n\t\t\tbuf[i] \u003d _mi_toupper(name[i]);\n\t\tbuf[len] \u003d 0;\n\t\ts \u003d getenv(buf);\n\t}\n\tif (s \u003d\u003d NULL || _mi_strnlen(s, result_size) \u003e\u003d result_size)\n\t\treturn false;\n\t_mi_strlcpy(result, s, result_size);\n\treturn true;\n}\n#endif // !MI_USE_ENVIRON\n```",
      "range": {
        "startLine": 715,
        "startChar": 0,
        "endLine": 733,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c317d48b_a3f419e5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 761,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nbool\n_mi_prim_random_buf(void* buf, size_t buf_len)\n{\n#if defined(MAC_OS_X_VERSION_10_15) \u0026\u0026 MAC_OS_X_VERSION_MAX_ALLOWED \u003e\u003d MAC_OS_X_VERSION_10_15\n\t// We prefere CCRandomGenerateBytes as it returns an error code while arc4random_buf\n\t// may fail silently on macOS. See PR #390, and\n\t// \u003chttps://opensource.apple.com/source/Libc/Libc-1439.40.11/gen/FreeBSD/arc4random.c.auto.html\u003e\n\treturn CCRandomGenerateBytes(buf, buf_len) \u003d\u003d kCCSuccess;\n#else\n\t// fall back on older macOS\n\tarc4random_buf(buf, buf_len);\n\treturn true;\n#endif\n}\n\n#elif defined(__ANDROID__) || defined(__DragonFly__) || defined(__FreeBSD__) \\\n\t|| defined(__NetBSD__) || defined(__OpenBSD__) || defined(__sun)\n```",
      "range": {
        "startLine": 747,
        "startChar": 0,
        "endLine": 761,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20ccf7ce_24d3565e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 766,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nbool\n_mi_prim_random_buf(void* buf, size_t buf_len)\n{\n\tarc4random_buf(buf, buf_len);\n\treturn true;\n```",
      "range": {
        "startLine": 764,
        "startChar": 0,
        "endLine": 766,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "048d3eba_cfae8e65",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 770,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \u003cerrno.h\u003e\n#include \u003cfcntl.h\u003e\n#include \u003csys/stat.h\u003e\n```",
      "range": {
        "startLine": 770,
        "startChar": 0,
        "endLine": 770,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fc866d8a_bb0d1c89",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 816,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n\nbool\n_mi_prim_random_buf(void* buf, size_t buf_len)\n{\n// Modern Linux provides `getrandom` but different distributions either use `sys/random.h` or\n// `linux/random.h` and for the latter the actual `getrandom` call is not always defined. (see\n// \u003chttps://stackoverflow.com/questions/45237324/why-doesnt-getrandom-compile\u003e) We therefore use a\n// syscall directly and fall back dynamically to /dev/urandom when needed.\n#if defined(MI_HAS_SYSCALL_H) \u0026\u0026 defined(SYS_getrandom)\n#ifndef GRND_NONBLOCK\n#define GRND_NONBLOCK (1)\n#endif\n\tstatic _Atomic(uintptr_t) no_getrandom; // \u003d 0\n\tif (mi_atomic_load_acquire(\u0026no_getrandom) \u003d\u003d 0) {\n\t\tssize_t ret \u003d syscall(SYS_getrandom, buf, buf_len, GRND_NONBLOCK);\n\t\tif (ret \u003e\u003d 0)\n\t\t\treturn buf_len \u003d\u003d (size_t)ret;\n\t\tif (errno !\u003d ENOSYS)\n\t\t\treturn false;\n\t\tmi_atomic_store_release(\u0026no_getrandom,\n\t\t\t(uintptr_t)1); // don\u0027t call again, and fall back to /dev/urandom\n\t}\n#endif\n\tint flags \u003d O_RDONLY;\n#if defined(O_CLOEXEC)\n\tflags |\u003d O_CLOEXEC;\n#endif\n\tint fd \u003d mi_prim_open(\"/dev/urandom\", flags);\n\tif (fd \u003c 0)\n\t\treturn false;\n\tsize_t count \u003d 0;\n\twhile (count \u003c buf_len) {\n\t\tssize_t ret \u003d mi_prim_read(fd, (char*)buf + count, buf_len - count);\n\t\tif (ret \u003c\u003d 0) {\n\t\t\tif (errno !\u003d EAGAIN \u0026\u0026 errno !\u003d EINTR)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tcount +\u003d ret;\n\t\t}\n\t}\n\tmi_prim_close(fd);\n\treturn count \u003d\u003d buf_len;\n}\n\n#else\n\n\nbool\n_mi_prim_random_buf(void* buf, size_t buf_len)\n{\n\treturn false;\n```",
      "range": {
        "startLine": 772,
        "startChar": 0,
        "endLine": 816,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e73a657d_7239ba06",
        "filename": "src/system/libroot/posix/malloc/mimalloc/prim.c",
        "patchSetId": 7
      },
      "lineNbr": 867,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void\nmi_pthread_done(void* value)\n{\n\tif (value !\u003d NULL)\n\t\t_mi_thread_done((mi_heap_t*)value);\n}\n\n\nvoid\n_mi_prim_thread_init_auto_done(void)\n{\n\tmi_assert_internal(_mi_heap_default_key \u003d\u003d (pthread_key_t)(-1));\n\tpthread_key_create(\u0026_mi_heap_default_key, \u0026mi_pthread_done);\n}\n\n\nvoid\n_mi_prim_thread_done_auto_done(void)\n{\n\t// nothing to do\n}\n\n\nvoid\n_mi_prim_thread_associate_default_heap(mi_heap_t* heap)\n{\n\tif (_mi_heap_default_key\n\t\t!\u003d (pthread_key_t)(-1)) { // can happen during recursive invocation on freeBSD\n\t\tpthread_setspecific(_mi_heap_default_key, heap);\n\t}\n}\n\n#else\n\n\nvoid\n_mi_prim_thread_init_auto_done(void)\n{\n\t// nothing\n}\n\n\nvoid\n_mi_prim_thread_done_auto_done(void)\n{\n\t// nothing\n}\n\n\nvoid\n_mi_prim_thread_associate_default_heap(mi_heap_t* heap)\n{\n\tMI_UNUSED(heap);\n}\n\n#endif\n```",
      "range": {
        "startLine": 832,
        "startChar": 0,
        "endLine": 867,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "caab1d71_9ab43b76",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 10,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \"mimalloc/prim.h\" // _mi_prim_random_buf\n#include \u003cstring.h\u003e // memset\n```",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "920b043a_f6c0c8f9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_CHACHA_ROUNDS (20) // perhaps use 12 for better performance?\n```",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 20,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b080e30_7157a3c7",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 124,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline uint32_t\nrotl(uint32_t x, uint32_t shift)\n{\n\treturn (x \u003c\u003c shift) | (x \u003e\u003e (32 - shift));\n}\n\n\nstatic inline void\nqround(uint32_t x[16], size_t a, size_t b, size_t c, size_t d)\n{\n\tx[a] +\u003d x[b];\n\tx[d] \u003d rotl(x[d] ^ x[a], 16);\n\tx[c] +\u003d x[d];\n\tx[b] \u003d rotl(x[b] ^ x[c], 12);\n\tx[a] +\u003d x[b];\n\tx[d] \u003d rotl(x[d] ^ x[a], 8);\n\tx[c] +\u003d x[d];\n\tx[b] \u003d rotl(x[b] ^ x[c], 7);\n}\n\n\nstatic void\nchacha_block(mi_random_ctx_t* ctx)\n{\n\t// scramble into `x`\n\tuint32_t x[16];\n\tfor (size_t i \u003d 0; i \u003c 16; i++)\n\t\tx[i] \u003d ctx-\u003einput[i];\n\tfor (size_t i \u003d 0; i \u003c MI_CHACHA_ROUNDS; i +\u003d 2) {\n\t\tqround(x, 0, 4, 8, 12);\n\t\tqround(x, 1, 5, 9, 13);\n\t\tqround(x, 2, 6, 10, 14);\n\t\tqround(x, 3, 7, 11, 15);\n\t\tqround(x, 0, 5, 10, 15);\n\t\tqround(x, 1, 6, 11, 12);\n\t\tqround(x, 2, 7, 8, 13);\n\t\tqround(x, 3, 4, 9, 14);\n\t}\n\n\t// add scrambled data to the initial state\n\tfor (size_t i \u003d 0; i \u003c 16; i++)\n\t\tctx-\u003eoutput[i] \u003d x[i] + ctx-\u003einput[i];\n\tctx-\u003eoutput_available \u003d 16;\n\n\t// increment the counter for the next round\n\tctx-\u003einput[12] +\u003d 1;\n\tif (ctx-\u003einput[12] \u003d\u003d 0) {\n\t\tctx-\u003einput[13] +\u003d 1;\n\t\tif (ctx-\u003einput[13] \u003d\u003d 0) // and keep increasing into the nonce\n\t\t\tctx-\u003einput[14] +\u003d 1;\n\t}\n}\n\n\nstatic uint32_t\nchacha_next32(mi_random_ctx_t* ctx)\n{\n\tif (ctx-\u003eoutput_available \u003c\u003d 0) {\n\t\tchacha_block(ctx);\n\t\tctx-\u003eoutput_available \u003d 16; // (assign again to suppress static analysis warning)\n\t}\n\tconst uint32_t x \u003d ctx-\u003eoutput[16 - ctx-\u003eoutput_available];\n\tctx-\u003eoutput[16 - ctx-\u003eoutput_available] \u003d 0; // reset once the data is handed out\n\tctx-\u003eoutput_available--;\n\treturn x;\n}\n\n\nstatic inline uint32_t\nread32(const uint8_t* p, size_t idx32)\n{\n\tconst size_t i \u003d 4 * idx32;\n\treturn (uint32_t)p[i + 0] | (uint32_t)p[i + 1] \u003c\u003c 8 | (uint32_t)p[i + 2] \u003c\u003c 16\n\t\t| (uint32_t)p[i + 3] \u003c\u003c 24;\n}\n\n\nstatic void\nchacha_init(mi_random_ctx_t* ctx, const uint8_t key[32], uint64_t nonce)\n{\n\t// since we only use chacha for randomness (and not encryption) we\n\t// do not _need_ to read 32-bit values as little endian but we do anyways\n\t// just for being compatible :-)\n\tmemset(ctx, 0, sizeof(*ctx));\n\tfor (size_t i \u003d 0; i \u003c 4; i++) {\n\t\tconst uint8_t* sigma \u003d (uint8_t*)\"expand 32-byte k\";\n\t\tctx-\u003einput[i] \u003d read32(sigma, i);\n\t}\n\tfor (size_t i \u003d 0; i \u003c 8; i++)\n\t\tctx-\u003einput[i + 4] \u003d read32(key, i);\n\tctx-\u003einput[12] \u003d 0;\n\tctx-\u003einput[13] \u003d 0;\n\tctx-\u003einput[14] \u003d (uint32_t)nonce;\n\tctx-\u003einput[15] \u003d (uint32_t)(nonce \u003e\u003e 32);\n}\n\n\nstatic void\nchacha_split(mi_random_ctx_t* ctx, uint64_t nonce, mi_random_ctx_t* ctx_new)\n{\n\tmemset(ctx_new, 0, sizeof(*ctx_new));\n\t_mi_memcpy(ctx_new-\u003einput, ctx-\u003einput, sizeof(ctx_new-\u003einput));\n\tctx_new-\u003einput[12] \u003d 0;\n\tctx_new-\u003einput[13] \u003d 0;\n\tctx_new-\u003einput[14] \u003d (uint32_t)nonce;\n\tctx_new-\u003einput[15] \u003d (uint32_t)(nonce \u003e\u003e 32);\n\tmi_assert_internal(ctx-\u003einput[14] !\u003d ctx_new-\u003einput[14]\n\t\t|| ctx-\u003einput[15] !\u003d ctx_new-\u003einput[15]); // do not reuse nonces!\n\tchacha_block(ctx_new);\n```",
      "range": {
        "startLine": 36,
        "startChar": 0,
        "endLine": 124,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b2583b0_1f4d4012",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 134,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if MI_DEBUG \u003e 1\n\n\nstatic bool\nmi_random_is_initialized(mi_random_ctx_t* ctx)\n{\n\treturn ctx !\u003d NULL \u0026\u0026 ctx-\u003einput[0] !\u003d 0;\n```",
      "range": {
        "startLine": 132,
        "startChar": 0,
        "endLine": 134,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5482e7a4_72290650",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 152,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n_mi_random_split(mi_random_ctx_t* ctx, mi_random_ctx_t* ctx_new)\n{\n\tmi_assert_internal(mi_random_is_initialized(ctx));\n\tmi_assert_internal(ctx !\u003d ctx_new);\n\tchacha_split(ctx, (uintptr_t)ctx_new /*nonce*/, ctx_new);\n}\n\n\nuintptr_t\n_mi_random_next(mi_random_ctx_t* ctx)\n{\n\tmi_assert_internal(mi_random_is_initialized(ctx));\n#if MI_INTPTR_SIZE \u003c\u003d 4\n\treturn chacha_next32(ctx);\n#elif MI_INTPTR_SIZE \u003d\u003d 8\n\treturn ((uintptr_t)chacha_next32(ctx) \u003c\u003c 32) | chacha_next32(ctx);\n#else\n#error \"define mi_random_next for this platform\"\n#endif\n```",
      "range": {
        "startLine": 138,
        "startChar": 0,
        "endLine": 152,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07a88949_b277477d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 205,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nuintptr_t\n_mi_os_random_weak(uintptr_t extra_seed)\n{\n\tuintptr_t x \u003d (uintptr_t)\u0026_mi_os_random_weak ^ extra_seed; // ASLR makes the address random\n\tx ^\u003d _mi_prim_clock_now();\n\t// and do a few randomization steps\n\tuintptr_t max \u003d ((x ^ (x \u003e\u003e 17)) \u0026 0x0F) + 1;\n\tfor (uintptr_t i \u003d 0; i \u003c max; i++)\n\t\tx \u003d _mi_random_shuffle(x);\n\tmi_assert_internal(x !\u003d 0);\n\treturn x;\n}\n\n\nstatic void\nmi_random_init_ex(mi_random_ctx_t* ctx, bool use_weak)\n{\n\tuint8_t key[32];\n\tif (use_weak || !_mi_prim_random_buf(key, sizeof(key))) {\n// if we fail to get random data from the OS, we fall back to a\n// weak random source based on the current time\n#if !defined(__wasi__)\n\t\tif (!use_weak)\n\t\t\t_mi_warning_message(\"unable to use secure randomness\\n\");\n#endif\n\t\tuintptr_t x \u003d _mi_os_random_weak(0);\n\t\tfor (size_t i \u003d 0; i \u003c 8; i++) { // key is eight 32-bit words.\n\t\t\tx \u003d _mi_random_shuffle(x);\n\t\t\t((uint32_t*)key)[i] \u003d (uint32_t)x;\n\t\t}\n\t\tctx-\u003eweak \u003d true;\n\t} else {\n\t\tctx-\u003eweak \u003d false;\n\t}\n\tchacha_init(ctx, key, (uintptr_t)ctx /*nonce*/);\n}\n\n\nvoid\n_mi_random_init(mi_random_ctx_t* ctx)\n{\n\tmi_random_init_ex(ctx, false);\n}\n\n\nvoid\n_mi_random_init_weak(mi_random_ctx_t* ctx)\n{\n\tmi_random_init_ex(ctx, true);\n}\n\n\nvoid\n_mi_random_reinit_if_weak(mi_random_ctx_t* ctx)\n{\n\tif (ctx-\u003eweak)\n\t\t_mi_random_init(ctx);\n```",
      "range": {
        "startLine": 161,
        "startChar": 0,
        "endLine": 205,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08cb1400_cf2a66b0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 214,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tif (x[i] !\u003d y[i]) return false;\n```",
      "range": {
        "startLine": 214,
        "startChar": 0,
        "endLine": 214,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9069168_8704edfa",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 229,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t   0x879531e0,  0xc5ecf37d,  0x516461b1,  0xc9a62f8a,\n\t   0x44c20ef3,  0x3390af7f,  0xd9fc690b,  0x2a5f714c,\n\t   0x53372767,  0xb00a5631,  0x974c541a,  0x359e9963,\n\t   0x5c971061,  0x3d631689,  0x2098d9d6,  0x91dbd320 };\n```",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 229,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e3bef6bf_225dbc15",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 234,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t   0x879531e0,  0xc5ecf37d,  0xbdb886dc,  0xc9a62f8a,\n\t   0x44c20ef3,  0x3390af7f,  0xd9fc690b,  0xcfacafd2,\n\t   0xe46bea80,  0xb00a5631,  0x974c541a,  0x359e9963,\n\t   0x5c971061,  0xccc07c79,  0x2098d9d6,  0x91dbd320 };\n```",
      "range": {
        "startLine": 231,
        "startChar": 0,
        "endLine": 234,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1717046_29581c0a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 244,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t{ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n\t  0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,\n\t  0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,\n\t  0x00000001, 0x09000000, 0x4a000000, 0x00000000 },\n\t{0},\n\t0\n```",
      "range": {
        "startLine": 239,
        "startChar": 0,
        "endLine": 244,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7e4da1c0_bec21b1d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/random.c",
        "patchSetId": 7
      },
      "lineNbr": 250,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t   0xe4e7f110, 0x15593bd1, 0x1fdd0f50, 0xc47120a3,\n\t   0xc7f4d1c7, 0x0368c033, 0x9aaa2204, 0x4e6cd4c3,\n\t   0x466482d2, 0x09aa9f07, 0x05d7c214, 0xa2028bd9,\n\t   0xd19c12b5, 0xb94e16de, 0xe883d0cb, 0x4e3c50a2 };\n```",
      "range": {
        "startLine": 247,
        "startChar": 0,
        "endLine": 250,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e025dc0a_367a1836",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 15,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 15,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7cb4da28_0a2030a5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 17,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 17,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c0244d1_4bd08cc3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#if (MI_INTPTR_SIZE \u003d\u003d 8)\n#define MI_MAX_ADDRESS ((size_t)40 \u003c\u003c 40) // 40TB (to include huge page areas)\n```",
      "range": {
        "startLine": 19,
        "startChar": 0,
        "endLine": 20,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "33686bdf_504ee93a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 22,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_MAX_ADDRESS ((size_t)2 \u003c\u003c 30) // 2Gb\n```",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 22,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20602db4_7a7bb784",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 26,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_SEGMENT_MAP_BITS (MI_MAX_ADDRESS / MI_SEGMENT_SIZE)\n#define MI_SEGMENT_MAP_SIZE (MI_SEGMENT_MAP_BITS / 8)\n```",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 26,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f634ef5_18abc59e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 29,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic _Atomic(uintptr_t)\n\tmi_segment_map[MI_SEGMENT_MAP_WSIZE + 1]; // 2KiB per TB with 64MiB segments\n```",
      "range": {
        "startLine": 29,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c5a8fd32_95eb246c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 43,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic size_t\nmi_segment_map_index_of(const mi_segment_t* segment, size_t* bitidx)\n{\n\tmi_assert_internal(\n\t\t_mi_ptr_segment(segment + 1) \u003d\u003d segment); // is it aligned on MI_SEGMENT_SIZE?\n\tif ((uintptr_t)segment \u003e\u003d MI_MAX_ADDRESS) {\n\t\t*bitidx \u003d 0;\n\t\treturn MI_SEGMENT_MAP_WSIZE;\n\t} else {\n\t\tconst uintptr_t segindex \u003d ((uintptr_t)segment) / MI_SEGMENT_SIZE;\n\t\t*bitidx \u003d segindex % MI_INTPTR_BITS;\n\t\tconst size_t mapindex \u003d segindex / MI_INTPTR_BITS;\n\t\tmi_assert_internal(mapindex \u003c MI_SEGMENT_MAP_WSIZE);\n\t\treturn mapindex;\n\t}\n```",
      "range": {
        "startLine": 31,
        "startChar": 0,
        "endLine": 43,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "99a40157_3208516b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n_mi_segment_map_allocated_at(const mi_segment_t* segment)\n{\n\tsize_t bitidx;\n\tsize_t index \u003d mi_segment_map_index_of(segment, \u0026bitidx);\n\tmi_assert_internal(index \u003c\u003d MI_SEGMENT_MAP_WSIZE);\n\tif (index \u003d\u003d MI_SEGMENT_MAP_WSIZE)\n\t\treturn;\n\tuintptr_t mask \u003d mi_atomic_load_relaxed(\u0026mi_segment_map[index]);\n\tuintptr_t newmask;\n\tdo {\n\t\tnewmask \u003d (mask | ((uintptr_t)1 \u003c\u003c bitidx));\n\t} while (!mi_atomic_cas_weak_release(\u0026mi_segment_map[index], \u0026mask, newmask));\n```",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 55,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b76a73c7_fda885e6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nvoid\n_mi_segment_map_freed_at(const mi_segment_t* segment)\n{\n\tsize_t bitidx;\n\tsize_t index \u003d mi_segment_map_index_of(segment, \u0026bitidx);\n\tmi_assert_internal(index \u003c\u003d MI_SEGMENT_MAP_WSIZE);\n\tif (index \u003d\u003d MI_SEGMENT_MAP_WSIZE)\n\t\treturn;\n\tuintptr_t mask \u003d mi_atomic_load_relaxed(\u0026mi_segment_map[index]);\n\tuintptr_t newmask;\n\tdo {\n\t\tnewmask \u003d (mask \u0026 ~((uintptr_t)1 \u003c\u003c bitidx));\n\t} while (!mi_atomic_cas_weak_release(\u0026mi_segment_map[index], \u0026mask, newmask));\n```",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 67,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0059ecab_a2b090ef",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 82,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_segment_t*\n_mi_segment_of(const void* p)\n{\n\tif (p \u003d\u003d NULL)\n\t\treturn NULL;\n\tmi_segment_t* segment \u003d _mi_ptr_segment(p);\n\tmi_assert_internal(segment !\u003d NULL);\n\tsize_t bitidx;\n\tsize_t index \u003d mi_segment_map_index_of(segment, \u0026bitidx);\n\t// fast path: for any pointer to valid small/medium/large object or first MI_SEGMENT_SIZE in\n\t// huge\n\tconst uintptr_t mask \u003d mi_atomic_load_relaxed(\u0026mi_segment_map[index]);\n\tif mi_likely ((mask \u0026 ((uintptr_t)1 \u003c\u003c bitidx)) !\u003d 0)\n\t\treturn segment; // yes, allocated by us\n\tif (index \u003d\u003d MI_SEGMENT_MAP_WSIZE)\n\t\treturn NULL;\n```",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 82,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6fbc4576_b8fe0c1c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 84,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// TODO: maintain max/min allocated range for efficiency for more efficient rejection of invalid\n\t// pointers?\n```",
      "range": {
        "startLine": 84,
        "startChar": 0,
        "endLine": 84,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f9c1d45_0602b01d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 114,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t// search downwards for the first segment in case it is an interior pointer\n\t// could be slow but searches in MI_INTPTR_SIZE * MI_SEGMENT_SIZE (512MiB) steps trough\n\t// valid huge objects\n\t// note: we could maintain a lowest index to speed up the path for invalid pointers?\n\tsize_t lobitidx;\n\tsize_t loindex;\n\tuintptr_t lobits \u003d mask \u0026 (((uintptr_t)1 \u003c\u003c bitidx) - 1);\n\tif (lobits !\u003d 0) {\n\t\tloindex \u003d index;\n\t\tlobitidx \u003d mi_bsr(lobits); // lobits !\u003d 0\n\t} else if (index \u003d\u003d 0) {\n\t\treturn NULL;\n\t} else {\n\t\tmi_assert_internal(index \u003e 0);\n\t\tuintptr_t lomask \u003d mask;\n\t\tloindex \u003d index;\n\t\tdo {\n\t\t\tloindex--;\n\t\t\tlomask \u003d mi_atomic_load_relaxed(\u0026mi_segment_map[loindex]);\n\t\t} while (lomask !\u003d 0 \u0026\u0026 loindex \u003e 0);\n\t\tif (lomask \u003d\u003d 0)\n\t\t\treturn NULL;\n\t\tlobitidx \u003d mi_bsr(lomask); // lomask !\u003d 0\n\t}\n\tmi_assert_internal(loindex \u003c MI_SEGMENT_MAP_WSIZE);\n\t// take difference as the addresses could be larger than the MAX_ADDRESS space.\n\tsize_t diff\n\t\t\u003d (((index - loindex) * (8 * MI_INTPTR_SIZE)) + bitidx - lobitidx) * MI_SEGMENT_SIZE;\n\tsegment \u003d (mi_segment_t*)((uint8_t*)segment - diff);\n```",
      "range": {
        "startLine": 86,
        "startChar": 0,
        "endLine": 114,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "47b702a2_ce575464",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 123,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tif (segment \u003d\u003d NULL)\n\t\treturn NULL;\n\tmi_assert_internal((void*)segment \u003c p);\n\tbool cookie_ok \u003d (_mi_ptr_cookie(segment) \u003d\u003d segment-\u003ecookie);\n\tmi_assert_internal(cookie_ok);\n\tif mi_unlikely (!cookie_ok)\n\t\treturn NULL;\n\tif (((uint8_t*)segment + mi_segment_size(segment)) \u003c\u003d (uint8_t*)p)\n\t\treturn NULL; // outside the range\n\tmi_assert_internal(\n\t\tp \u003e\u003d (void*)segment \u0026\u0026 (uint8_t*)p \u003c (uint8_t*)segment + mi_segment_size(segment));\n\treturn segment;\n```",
      "range": {
        "startLine": 116,
        "startChar": 0,
        "endLine": 123,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a828c8dc_0c413ddb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 128,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_is_valid_pointer(const void* p)\n{\n\treturn (_mi_segment_of(p) !\u003d NULL) || (_mi_arena_contains(p));\n```",
      "range": {
        "startLine": 127,
        "startChar": 0,
        "endLine": 128,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3b4e9672_284bda48",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 132,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nmi_decl_nodiscard mi_decl_export bool\nmi_is_in_heap_region(const void* p) mi_attr_noexcept\n{\n\treturn mi_is_valid_pointer(p);\n```",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 132,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "368300e2_7ba03a42",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 141,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tif (size !\u003d NULL) *size \u003d 0;\n\treturn NULL;\n```",
      "range": {
        "startLine": 140,
        "startChar": 0,
        "endLine": 141,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f3495148_dd3dd8ec",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 145,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tif (size !\u003d NULL) *size \u003d segment-\u003esegment_size;\n\treturn segment;\n```",
      "range": {
        "startLine": 144,
        "startChar": 0,
        "endLine": 145,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ace2f73_f6bb532b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment-map.c",
        "patchSetId": 7
      },
      "lineNbr": 151,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n  mi_assert_internal(page \u003d\u003d NULL || (mi_segment_page_size(_mi_page_segment(page)) - (MI_SECURE \u003d\u003d 0\n? 0 : _mi_os_page_size())) \u003e\u003d block_size); mi_reset_delayed(tld); mi_assert_internal(page \u003d\u003d NULL ||\nmi_page_not_in_queue(page, tld)); return page;\n```",
      "range": {
        "startLine": 148,
        "startChar": 0,
        "endLine": 151,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98cc2b91_2e6c869c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 7,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f3fc5ee_ab7b1d1e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 11,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\n```",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25d0fe8a_db8b13f4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 14,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cstring.h\u003e // memset\n\n#define MI_PAGE_HUGE_ALIGN (256 * 1024)\n```",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 14,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c009878f_8304d7fc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// commit mask\n```",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 20,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92eb0313_b63a37a1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 143,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_commit_mask_all_set(const mi_commit_mask_t* commit, const mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++) {\n\t\tif ((commit-\u003emask[i] \u0026 cm-\u003emask[i]) !\u003d cm-\u003emask[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nstatic bool\nmi_commit_mask_any_set(const mi_commit_mask_t* commit, const mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++) {\n\t\tif ((commit-\u003emask[i] \u0026 cm-\u003emask[i]) !\u003d 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nstatic void\nmi_commit_mask_create_intersect(const mi_commit_mask_t* commit, const mi_commit_mask_t* cm,\n\tmi_commit_mask_t* res)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++)\n\t\tres-\u003emask[i] \u003d (commit-\u003emask[i] \u0026 cm-\u003emask[i]);\n}\n\n\nstatic void\nmi_commit_mask_clear(mi_commit_mask_t* res, const mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++)\n\t\tres-\u003emask[i] \u0026\u003d ~(cm-\u003emask[i]);\n}\n\n\nstatic void\nmi_commit_mask_set(mi_commit_mask_t* res, const mi_commit_mask_t* cm)\n{\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++)\n\t\tres-\u003emask[i] |\u003d cm-\u003emask[i];\n}\n\n\nstatic void\nmi_commit_mask_create(size_t bitidx, size_t bitcount, mi_commit_mask_t* cm)\n{\n\tmi_assert_internal(bitidx \u003c MI_COMMIT_MASK_BITS);\n\tmi_assert_internal((bitidx + bitcount) \u003c\u003d MI_COMMIT_MASK_BITS);\n\tif (bitcount \u003d\u003d MI_COMMIT_MASK_BITS) {\n\t\tmi_assert_internal(bitidx \u003d\u003d 0);\n\t\tmi_commit_mask_create_full(cm);\n\t} else if (bitcount \u003d\u003d 0) {\n\t\tmi_commit_mask_create_empty(cm);\n\t} else {\n\t\tmi_commit_mask_create_empty(cm);\n\t\tsize_t i \u003d bitidx / MI_COMMIT_MASK_FIELD_BITS;\n\t\tsize_t ofs \u003d bitidx % MI_COMMIT_MASK_FIELD_BITS;\n\t\twhile (bitcount \u003e 0) {\n\t\t\tmi_assert_internal(i \u003c MI_COMMIT_MASK_FIELD_COUNT);\n\t\t\tsize_t avail \u003d MI_COMMIT_MASK_FIELD_BITS - ofs;\n\t\t\tsize_t count \u003d (bitcount \u003e avail ? avail : bitcount);\n\t\t\tsize_t mask \u003d (count \u003e\u003d MI_COMMIT_MASK_FIELD_BITS ? ~((size_t)0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  : (((size_t)1 \u003c\u003c count) - 1) \u003c\u003c ofs);\n\t\t\tcm-\u003emask[i] \u003d mask;\n\t\t\tbitcount -\u003d count;\n\t\t\tofs \u003d 0;\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n\nsize_t\n_mi_commit_mask_committed_size(const mi_commit_mask_t* cm, size_t total)\n{\n\tmi_assert_internal((total % MI_COMMIT_MASK_BITS) \u003d\u003d 0);\n\tsize_t count \u003d 0;\n\tfor (size_t i \u003d 0; i \u003c MI_COMMIT_MASK_FIELD_COUNT; i++) {\n\t\tsize_t mask \u003d cm-\u003emask[i];\n\t\tif (~mask \u003d\u003d 0) {\n\t\t\tcount +\u003d MI_COMMIT_MASK_FIELD_BITS;\n\t\t} else {\n\t\t\tfor (; mask !\u003d 0; mask \u003e\u003e\u003d 1) { // todo: use popcount\n\t\t\t\tif ((mask \u0026 1) !\u003d 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t// we use total since for huge segments each commit bit may represent a larger size\n\treturn (total / MI_COMMIT_MASK_BITS) * count;\n}\n\n\nsize_t\n_mi_commit_mask_next_run(const mi_commit_mask_t* cm, size_t* idx)\n{\n\tsize_t i \u003d (*idx) / MI_COMMIT_MASK_FIELD_BITS;\n\tsize_t ofs \u003d (*idx) % MI_COMMIT_MASK_FIELD_BITS;\n\tsize_t mask \u003d 0;\n\t// find first ones\n\twhile (i \u003c MI_COMMIT_MASK_FIELD_COUNT) {\n\t\tmask \u003d cm-\u003emask[i];\n\t\tmask \u003e\u003e\u003d ofs;\n\t\tif (mask !\u003d 0) {\n\t\t\twhile ((mask \u0026 1) \u003d\u003d 0) {\n\t\t\t\tmask \u003e\u003e\u003d 1;\n\t\t\t\tofs++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tofs \u003d 0;\n\t}\n\tif (i \u003e\u003d MI_COMMIT_MASK_FIELD_COUNT) {\n\t\t// not found\n\t\t*idx \u003d MI_COMMIT_MASK_BITS;\n\t\treturn 0;\n\t} else {\n\t\t// found, count ones\n\t\tsize_t count \u003d 0;\n\t\t*idx \u003d (i * MI_COMMIT_MASK_FIELD_BITS) + ofs;\n\t\tdo {\n\t\t\tmi_assert_internal(ofs \u003c MI_COMMIT_MASK_FIELD_BITS \u0026\u0026 (mask \u0026 1) \u003d\u003d 1);\n\t\t\tdo {\n\t\t\t\tcount++;\n\t\t\t\tmask \u003e\u003e\u003d 1;\n\t\t\t} while ((mask \u0026 1) \u003d\u003d 1);\n\t\t\tif (((*idx + count) % MI_COMMIT_MASK_FIELD_BITS) \u003d\u003d 0) {\n\t\t\t\ti++;\n\t\t\t\tif (i \u003e\u003d MI_COMMIT_MASK_FIELD_COUNT)\n\t\t\t\t\tbreak;\n\t\t\t\tmask \u003d cm-\u003emask[i];\n\t\t\t\tofs \u003d 0;\n\t\t\t}\n\t\t} while ((mask \u0026 1) \u003d\u003d 1);\n\t\tmi_assert_internal(count \u003e 0);\n\t\treturn count;\n\t}\n```",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 143,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "700d3831_bca81fe9",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 168,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic const mi_slice_t*\nmi_segment_slices_end(const mi_segment_t* segment)\n{\n\treturn \u0026segment-\u003eslices[segment-\u003eslice_entries];\n}\n\n\nstatic uint8_t*\nmi_slice_start(const mi_slice_t* slice)\n{\n\tmi_segment_t* segment \u003d _mi_ptr_segment(slice);\n\tmi_assert_internal(slice \u003e\u003d segment-\u003eslices \u0026\u0026 slice \u003c mi_segment_slices_end(segment));\n\treturn (uint8_t*)segment + ((slice - segment-\u003eslices) * MI_SEGMENT_SLICE_SIZE);\n```",
      "range": {
        "startLine": 161,
        "startChar": 0,
        "endLine": 168,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "de3f2e4f_f5735d7b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 199,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic inline size_t\nmi_slice_bin8(size_t slice_count)\n{\n\tif (slice_count \u003c\u003d 1)\n\t\treturn slice_count;\n\tmi_assert_internal(slice_count \u003c\u003d MI_SLICES_PER_SEGMENT);\n\tslice_count--;\n\tsize_t s \u003d mi_bsr(slice_count); // slice_count \u003e 1\n\tif (s \u003c\u003d 2)\n\t\treturn slice_count + 1;\n\tsize_t bin \u003d ((s \u003c\u003c 2) | ((slice_count \u003e\u003e (s - 2)) \u0026 0x03)) - 4;\n\treturn bin;\n}\n\n\nstatic inline size_t\nmi_slice_bin(size_t slice_count)\n{\n\tmi_assert_internal(slice_count * MI_SEGMENT_SLICE_SIZE \u003c\u003d MI_SEGMENT_SIZE);\n\tmi_assert_internal(mi_slice_bin8(MI_SLICES_PER_SEGMENT) \u003c\u003d MI_SEGMENT_BIN_MAX);\n\tsize_t bin \u003d mi_slice_bin8(slice_count);\n\tmi_assert_internal(bin \u003c\u003d MI_SEGMENT_BIN_MAX);\n\treturn bin;\n}\n\n\nstatic inline size_t\nmi_slice_index(const mi_slice_t* slice)\n{\n\tmi_segment_t* segment \u003d _mi_ptr_segment(slice);\n\tptrdiff_t index \u003d slice - segment-\u003eslices;\n\tmi_assert_internal(index \u003e\u003d 0 \u0026\u0026 index \u003c (ptrdiff_t)segment-\u003eslice_entries);\n\treturn index;\n```",
      "range": {
        "startLine": 177,
        "startChar": 0,
        "endLine": 199,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ca008df_9c5f6bef",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 234,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_span_queue_push(mi_span_queue_t* sq, mi_slice_t* slice)\n{\n\t// todo: or push to the end?\n\tmi_assert_internal(slice-\u003eprev \u003d\u003d NULL \u0026\u0026 slice-\u003enext \u003d\u003d NULL);\n\tslice-\u003eprev \u003d NULL; // paranoia\n\tslice-\u003enext \u003d sq-\u003efirst;\n\tsq-\u003efirst \u003d slice;\n\tif (slice-\u003enext !\u003d NULL)\n\t\tslice-\u003enext-\u003eprev \u003d slice;\n\telse\n\t\tsq-\u003elast \u003d slice;\n\tslice-\u003exblock_size \u003d 0; // free\n}\n\n\nstatic mi_span_queue_t*\nmi_span_queue_for(size_t slice_count, mi_segments_tld_t* tld)\n{\n\tsize_t bin \u003d mi_slice_bin(slice_count);\n\tmi_span_queue_t* sq \u003d \u0026tld-\u003espans[bin];\n\tmi_assert_internal(sq-\u003eslice_count \u003e\u003d slice_count);\n\treturn sq;\n}\n\n\nstatic void\nmi_span_queue_delete(mi_span_queue_t* sq, mi_slice_t* slice)\n{\n\tmi_assert_internal(\n\t\tslice-\u003exblock_size \u003d\u003d 0 \u0026\u0026 slice-\u003eslice_count \u003e 0 \u0026\u0026 slice-\u003eslice_offset \u003d\u003d 0);\n\t// should work too if the queue does not contain slice (which can happen during reclaim)\n\tif (slice-\u003eprev !\u003d NULL)\n\t\tslice-\u003eprev-\u003enext \u003d slice-\u003enext;\n\tif (slice \u003d\u003d sq-\u003efirst)\n\t\tsq-\u003efirst \u003d slice-\u003enext;\n\tif (slice-\u003enext !\u003d NULL)\n\t\tslice-\u003enext-\u003eprev \u003d slice-\u003eprev;\n\tif (slice \u003d\u003d sq-\u003elast)\n\t\tsq-\u003elast \u003d slice-\u003eprev;\n\tslice-\u003eprev \u003d NULL;\n\tslice-\u003enext \u003d NULL;\n\tslice-\u003exblock_size \u003d 1; // no more free\n```",
      "range": {
        "startLine": 207,
        "startChar": 0,
        "endLine": 234,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17a030f2_277db6d8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 302,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_slice_is_used(const mi_slice_t* slice)\n{\n\treturn slice-\u003exblock_size \u003e 0;\n}\n\n\n#if (MI_DEBUG \u003e\u003d 3)\n\n\nstatic bool\nmi_span_queue_contains(mi_span_queue_t* sq, mi_slice_t* slice)\n{\n\tfor (mi_slice_t* s \u003d sq-\u003efirst; s !\u003d NULL; s \u003d s-\u003enext) {\n\t\tif (s \u003d\u003d slice)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nstatic bool\nmi_segment_is_valid(mi_segment_t* segment, mi_segments_tld_t* tld)\n{\n\tmi_assert_internal(segment !\u003d NULL);\n\tmi_assert_internal(_mi_ptr_cookie(segment) \u003d\u003d segment-\u003ecookie);\n\tmi_assert_internal(segment-\u003eabandoned \u003c\u003d segment-\u003eused);\n\tmi_assert_internal(segment-\u003ethread_id \u003d\u003d 0 || segment-\u003ethread_id \u003d\u003d _mi_thread_id());\n\tmi_assert_internal(mi_commit_mask_all_set(\u0026segment-\u003ecommit_mask,\n\t\t\u0026segment-\u003epurge_mask)); // can only decommit committed blocks\n\t// mi_assert_internal(segment-\u003esegment_info_size % MI_SEGMENT_SLICE_SIZE \u003d\u003d 0);\n\tmi_slice_t* slice \u003d \u0026segment-\u003eslices[0];\n\tconst mi_slice_t* end \u003d mi_segment_slices_end(segment);\n\tsize_t used_count \u003d 0;\n\tmi_span_queue_t* sq;\n\twhile (slice \u003c end) {\n\t\tmi_assert_internal(slice-\u003eslice_count \u003e 0);\n\t\tmi_assert_internal(slice-\u003eslice_offset \u003d\u003d 0);\n\t\tsize_t index \u003d mi_slice_index(slice);\n\t\tsize_t maxindex\n\t\t\t\u003d (index + slice-\u003eslice_count \u003e\u003d segment-\u003eslice_entries ? segment-\u003eslice_entries\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: index + slice-\u003eslice_count)\n\t\t\t- 1;\n\t\tif (mi_slice_is_used(\n\t\t\t\tslice)) { // a page in use, we need at least MAX_SLICE_OFFSET valid back offsets\n\t\t\tused_count++;\n\t\t\tfor (size_t i \u003d 0; i \u003c\u003d MI_MAX_SLICE_OFFSET \u0026\u0026 index + i \u003c\u003d maxindex; i++) {\n\t\t\t\tmi_assert_internal(\n\t\t\t\t\tsegment-\u003eslices[index + i].slice_offset \u003d\u003d i * sizeof(mi_slice_t));\n\t\t\t\tmi_assert_internal(i \u003d\u003d 0 || segment-\u003eslices[index + i].slice_count \u003d\u003d 0);\n\t\t\t\tmi_assert_internal(i \u003d\u003d 0 || segment-\u003eslices[index + i].xblock_size \u003d\u003d 1);\n\t\t\t}\n\t\t\t// and the last entry as well (for coalescing)\n\t\t\tconst mi_slice_t* last \u003d slice + slice-\u003eslice_count - 1;\n\t\t\tif (last \u003e slice \u0026\u0026 last \u003c mi_segment_slices_end(segment)) {\n\t\t\t\tmi_assert_internal(\n\t\t\t\t\tlast-\u003eslice_offset \u003d\u003d (slice-\u003eslice_count - 1) * sizeof(mi_slice_t));\n\t\t\t\tmi_assert_internal(last-\u003eslice_count \u003d\u003d 0);\n\t\t\t\tmi_assert_internal(last-\u003exblock_size \u003d\u003d 1);\n\t\t\t}\n\t\t} else { // free range of slices; only last slice needs a valid back offset\n\t\t\tmi_slice_t* last \u003d \u0026segment-\u003eslices[maxindex];\n\t\t\tif (segment-\u003ekind !\u003d MI_SEGMENT_HUGE\n\t\t\t\t|| slice-\u003eslice_count \u003c\u003d (segment-\u003eslice_entries - segment-\u003esegment_info_slices)) {\n\t\t\t\tmi_assert_internal((uint8_t*)slice \u003d\u003d (uint8_t*)last - last-\u003eslice_offset);\n\t\t\t}\n\t\t\tmi_assert_internal(slice \u003d\u003d last || last-\u003eslice_count \u003d\u003d 0);\n\t\t\tmi_assert_internal(last-\u003exblock_size \u003d\u003d 0\n\t\t\t\t|| (segment-\u003ekind \u003d\u003d MI_SEGMENT_HUGE \u0026\u0026 last-\u003exblock_size \u003d\u003d 1));\n\t\t\tif (segment-\u003ekind !\u003d MI_SEGMENT_HUGE\n\t\t\t\t\u0026\u0026 segment-\u003ethread_id !\u003d 0) { // segment is not huge or abandoned\n\t\t\t\tsq \u003d mi_span_queue_for(slice-\u003eslice_count, tld);\n\t\t\t\tmi_assert_internal(mi_span_queue_contains(sq, slice));\n\t\t\t}\n\t\t}\n\t\tslice \u003d \u0026segment-\u003eslices[maxindex + 1];\n\t}\n\tmi_assert_internal(slice \u003d\u003d end);\n\tmi_assert_internal(used_count \u003d\u003d segment-\u003eused + 1);\n\treturn true;\n```",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 302,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6742662_d1f0ac7d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 327,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic size_t\nmi_segment_info_size(mi_segment_t* segment)\n{\n\treturn segment-\u003esegment_info_slices * MI_SEGMENT_SLICE_SIZE;\n}\n\n\nstatic uint8_t*\n_mi_segment_page_start_from_slice(const mi_segment_t* segment, const mi_slice_t* slice,\n\tsize_t xblock_size, size_t* page_size)\n{\n\tptrdiff_t idx \u003d slice - segment-\u003eslices;\n\tsize_t psize \u003d (size_t)slice-\u003eslice_count * MI_SEGMENT_SLICE_SIZE;\n\t// make the start not OS page aligned for smaller blocks to avoid page/cache effects\n\t// note: the offset must always be an xblock_size multiple since we assume small allocations\n\t// are aligned (see `mi_heap_malloc_aligned`).\n\tsize_t start_offset \u003d 0;\n\tif (xblock_size \u003e\u003d MI_INTPTR_SIZE) {\n\t\tif (xblock_size \u003c\u003d 64)\n\t\t\tstart_offset \u003d 3 * xblock_size;\n\t\telse if (xblock_size \u003c\u003d 512)\n\t\t\tstart_offset \u003d xblock_size;\n\t}\n\tif (page_size !\u003d NULL)\n\t\t*page_size \u003d psize - start_offset;\n\treturn (uint8_t*)segment + ((idx * MI_SEGMENT_SLICE_SIZE) + start_offset);\n```",
      "range": {
        "startLine": 310,
        "startChar": 0,
        "endLine": 327,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "64f218a9_563cee63",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 360,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nuint8_t*\n_mi_segment_page_start(const mi_segment_t* segment, const mi_page_t* page, size_t* page_size)\n{\n\tconst mi_slice_t* slice \u003d mi_page_to_slice((mi_page_t*)page);\n\tuint8_t* p \u003d _mi_segment_page_start_from_slice(segment, slice, page-\u003exblock_size, page_size);\n\tmi_assert_internal(page-\u003exblock_size \u003e 0 || _mi_ptr_page(p) \u003d\u003d page);\n\tmi_assert_internal(_mi_ptr_segment(p) \u003d\u003d segment);\n\treturn p;\n}\n\n\nstatic size_t\nmi_segment_calculate_slices(size_t required, size_t* pre_size, size_t* info_slices)\n{\n\tsize_t page_size \u003d _mi_os_page_size();\n\tsize_t isize \u003d _mi_align_up(sizeof(mi_segment_t), page_size);\n\tsize_t guardsize \u003d 0;\n\n\tif (MI_SECURE \u003e 0) {\n\t\t// in secure mode, we set up a protected page in between the segment info\n\t\t// and the page data (and one at the end of the segment)\n\t\tguardsize \u003d page_size;\n\t\tif (required \u003e 0)\n\t\t\trequired \u003d _mi_align_up(required, MI_SEGMENT_SLICE_SIZE) + page_size;\n\t}\n\n\tif (pre_size !\u003d NULL)\n\t\t*pre_size \u003d isize;\n\tisize \u003d _mi_align_up(isize + guardsize, MI_SEGMENT_SLICE_SIZE);\n\tif (info_slices !\u003d NULL)\n\t\t*info_slices \u003d isize / MI_SEGMENT_SLICE_SIZE;\n\tsize_t segment_size\n\t\t\u003d (required \u003d\u003d 0 ? MI_SEGMENT_SIZE\n\t\t\t\t\t\t : _mi_align_up(required + isize + guardsize, MI_SEGMENT_SLICE_SIZE));\n\tmi_assert_internal(segment_size % MI_SEGMENT_SLICE_SIZE \u003d\u003d 0);\n\treturn segment_size / MI_SEGMENT_SLICE_SIZE;\n```",
      "range": {
        "startLine": 331,
        "startChar": 0,
        "endLine": 360,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c385048_c30431bc",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 405,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_segments_track_size(long segment_size, mi_segments_tld_t* tld)\n{\n\tif (segment_size \u003e\u003d 0)\n\t\t_mi_stat_increase(\u0026tld-\u003estats-\u003esegments, 1);\n\telse\n\t\t_mi_stat_decrease(\u0026tld-\u003estats-\u003esegments, 1);\n\ttld-\u003ecount +\u003d (segment_size \u003e\u003d 0 ? 1 : -1);\n\tif (tld-\u003ecount \u003e tld-\u003epeak_count)\n\t\ttld-\u003epeak_count \u003d tld-\u003ecount;\n\ttld-\u003ecurrent_size +\u003d segment_size;\n\tif (tld-\u003ecurrent_size \u003e tld-\u003epeak_size)\n\t\ttld-\u003epeak_size \u003d tld-\u003ecurrent_size;\n}\n\n\nstatic void\nmi_segment_os_free(mi_segment_t* segment, mi_segments_tld_t* tld)\n{\n\tsegment-\u003ethread_id \u003d 0;\n\t_mi_segment_map_freed_at(segment);\n\tmi_segments_track_size(-((long)mi_segment_size(segment)), tld);\n\tif (MI_SECURE \u003e 0) {\n\t\t// _mi_os_unprotect(segment, mi_segment_size(segment)); // ensure no more guard pages are\n\t\t// set unprotect the guard pages; we cannot just unprotect the whole segment size as part\n\t\t// may be decommitted\n\t\tsize_t os_pagesize \u003d _mi_os_page_size();\n\t\t_mi_os_unprotect((uint8_t*)segment + mi_segment_info_size(segment) - os_pagesize,\n\t\t\tos_pagesize);\n\t\tuint8_t* end \u003d (uint8_t*)segment + mi_segment_size(segment) - os_pagesize;\n\t\t_mi_os_unprotect(end, os_pagesize);\n\t}\n\n\t// purge delayed decommits now? (no, leave it to the arena)\n\t// mi_segment_try_purge(segment,true,tld-\u003estats);\n\n\tconst size_t size \u003d mi_segment_size(segment);\n\tconst size_t csize \u003d _mi_commit_mask_committed_size(\u0026segment-\u003ecommit_mask, size);\n\n\t_mi_abandoned_await_readers(); // wait until safe to free\n\t_mi_arena_free(segment, mi_segment_size(segment), csize, segment-\u003ememid, tld-\u003estats);\n}\n\n// called by threads that are terminating\nvoid\n_mi_segment_thread_collect(mi_segments_tld_t* tld)\n{\n\tMI_UNUSED(tld);\n\t// nothing to do\n```",
      "range": {
        "startLine": 370,
        "startChar": 0,
        "endLine": 405,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e1a144b0_5848822d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 590,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_segment_commit_mask(mi_segment_t* segment, bool conservative, uint8_t* p, size_t size,\n\tuint8_t** start_p, size_t* full_size, mi_commit_mask_t* cm)\n{\n\tmi_assert_internal(_mi_ptr_segment(p + 1) \u003d\u003d segment);\n\tmi_assert_internal(segment-\u003ekind !\u003d MI_SEGMENT_HUGE);\n\tmi_commit_mask_create_empty(cm);\n\tif (size \u003d\u003d 0 || size \u003e MI_SEGMENT_SIZE || segment-\u003ekind \u003d\u003d MI_SEGMENT_HUGE)\n\t\treturn;\n\tconst size_t segstart \u003d mi_segment_info_size(segment);\n\tconst size_t segsize \u003d mi_segment_size(segment);\n\tif (p \u003e\u003d (uint8_t*)segment + segsize)\n\t\treturn;\n\n\tsize_t pstart \u003d (p - (uint8_t*)segment);\n\tmi_assert_internal(pstart + size \u003c\u003d segsize);\n\n\tsize_t start;\n\tsize_t end;\n\tif (conservative) {\n\t\t// decommit conservative\n\t\tstart \u003d _mi_align_up(pstart, MI_COMMIT_SIZE);\n\t\tend \u003d _mi_align_down(pstart + size, MI_COMMIT_SIZE);\n\t\tmi_assert_internal(start \u003e\u003d segstart);\n\t\tmi_assert_internal(end \u003c\u003d segsize);\n\t} else {\n\t\t// commit liberal\n\t\tstart \u003d _mi_align_down(pstart, MI_MINIMAL_COMMIT_SIZE);\n\t\tend \u003d _mi_align_up(pstart + size, MI_MINIMAL_COMMIT_SIZE);\n\t}\n\tif (pstart \u003e\u003d segstart \u0026\u0026 start \u003c segstart) { // note: the mask is also calculated for an\n\t\t\t\t\t\t\t\t\t\t\t\t  // initial commit of the info area\n\t\tstart \u003d segstart;\n\t}\n\tif (end \u003e segsize)\n\t\tend \u003d segsize;\n\n\tmi_assert_internal(start \u003c\u003d pstart \u0026\u0026 (pstart + size) \u003c\u003d end);\n\tmi_assert_internal(start % MI_COMMIT_SIZE \u003d\u003d 0 \u0026\u0026 end % MI_COMMIT_SIZE \u003d\u003d 0);\n\t*start_p \u003d (uint8_t*)segment + start;\n\t*full_size \u003d (end \u003e start ? end - start : 0);\n\tif (*full_size \u003d\u003d 0)\n\t\treturn;\n\n\tsize_t bitidx \u003d start / MI_COMMIT_SIZE;\n\tmi_assert_internal(bitidx \u003c MI_COMMIT_MASK_BITS);\n\n\tsize_t bitcount \u003d *full_size / MI_COMMIT_SIZE; // can be 0\n\tif (bitidx + bitcount \u003e MI_COMMIT_MASK_BITS) {\n\t\t_mi_warning_message(\"commit mask overflow: idx\u003d%zu count\u003d%zu start\u003d%zx end\u003d%zx p\u003d0x%p \"\n\t\t\t\t\t\t\t\"size\u003d%zu fullsize\u003d%zu\\n\",\n\t\t\tbitidx, bitcount, start, end, p, size, *full_size);\n\t}\n\tmi_assert_internal((bitidx + bitcount) \u003c\u003d MI_COMMIT_MASK_BITS);\n\tmi_commit_mask_create(bitidx, bitcount, cm);\n}\n\n\nstatic bool\nmi_segment_commit(mi_segment_t* segment, uint8_t* p, size_t size, mi_stats_t* stats)\n{\n\tmi_assert_internal(mi_commit_mask_all_set(\u0026segment-\u003ecommit_mask, \u0026segment-\u003epurge_mask));\n\n\t// commit liberal\n\tuint8_t* start \u003d NULL;\n\tsize_t full_size \u003d 0;\n\tmi_commit_mask_t mask;\n\tmi_segment_commit_mask(segment, false /* conservative? */, p, size, \u0026start, \u0026full_size, \u0026mask);\n\tif (mi_commit_mask_is_empty(\u0026mask) || full_size \u003d\u003d 0)\n\t\treturn true;\n\n\tif (!mi_commit_mask_all_set(\u0026segment-\u003ecommit_mask, \u0026mask)) {\n\t\t// committing\n\t\tbool is_zero \u003d false;\n\t\tmi_commit_mask_t cmask;\n\t\tmi_commit_mask_create_intersect(\u0026segment-\u003ecommit_mask, \u0026mask, \u0026cmask);\n\t\t_mi_stat_decrease(\u0026_mi_stats_main.committed,\n\t\t\t_mi_commit_mask_committed_size(\u0026cmask, MI_SEGMENT_SIZE)); // adjust for overlap\n\t\tif (!_mi_os_commit(start, full_size, \u0026is_zero, stats))\n\t\t\treturn false;\n\t\tmi_commit_mask_set(\u0026segment-\u003ecommit_mask, \u0026mask);\n\t}\n\n\t// increase purge expiration when using part of delayed purges -- we assume more allocations are\n\t// coming soon.\n\tif (mi_commit_mask_any_set(\u0026segment-\u003epurge_mask, \u0026mask))\n\t\tsegment-\u003epurge_expire \u003d _mi_clock_now() + mi_option_get(mi_option_purge_delay);\n\n\t// always clear any delayed purges in our range (as they are either committed now)\n\tmi_commit_mask_clear(\u0026segment-\u003epurge_mask, \u0026mask);\n\treturn true;\n}\n\n\nstatic bool\nmi_segment_ensure_committed(mi_segment_t* segment, uint8_t* p, size_t size, mi_stats_t* stats)\n{\n\tmi_assert_internal(mi_commit_mask_all_set(\u0026segment-\u003ecommit_mask, \u0026segment-\u003epurge_mask));\n\t// note: assumes commit_mask is always full for huge segments as otherwise the commit mask bits\n\t// can overflow\n\tif (mi_commit_mask_is_full(\u0026segment-\u003ecommit_mask)\n\t\t\u0026\u0026 mi_commit_mask_is_empty(\u0026segment-\u003epurge_mask)) {\n\t\treturn true; // fully committed\n\t}\n\tmi_assert_internal(segment-\u003ekind !\u003d MI_SEGMENT_HUGE);\n\treturn mi_segment_commit(segment, p, size, stats);\n}\n\n\nstatic bool\nmi_segment_purge(mi_segment_t* segment, uint8_t* p, size_t size, mi_stats_t* stats)\n{\n\tmi_assert_internal(mi_commit_mask_all_set(\u0026segment-\u003ecommit_mask, \u0026segment-\u003epurge_mask));\n\tif (!segment-\u003eallow_purge)\n\t\treturn true;\n\n\t// purge conservative\n\tuint8_t* start \u003d NULL;\n\tsize_t full_size \u003d 0;\n\tmi_commit_mask_t mask;\n\tmi_segment_commit_mask(segment, true /* conservative? */, p, size, \u0026start, \u0026full_size, \u0026mask);\n\tif (mi_commit_mask_is_empty(\u0026mask) || full_size \u003d\u003d 0)\n\t\treturn true;\n\n\tif (mi_commit_mask_any_set(\u0026segment-\u003ecommit_mask, \u0026mask)) {\n\t\t// purging\n\t\tmi_assert_internal((void*)start !\u003d (void*)segment);\n\t\tmi_assert_internal(segment-\u003eallow_decommit);\n\t\tconst bool decommitted \u003d _mi_os_purge(start, full_size, stats); // reset or decommit\n\t\tif (decommitted) {\n\t\t\tmi_commit_mask_t cmask;\n\t\t\tmi_commit_mask_create_intersect(\u0026segment-\u003ecommit_mask, \u0026mask, \u0026cmask);\n\t\t\t_mi_stat_increase(\u0026_mi_stats_main.committed,\n\t\t\t\tfull_size\n\t\t\t\t\t- _mi_commit_mask_committed_size(\u0026cmask,\n\t\t\t\t\t\tMI_SEGMENT_SIZE)); // adjust for double counting\n\t\t\tmi_commit_mask_clear(\u0026segment-\u003ecommit_mask, \u0026mask);\n\t\t}\n\t}\n\n\t// always clear any scheduled purges in our range\n\tmi_commit_mask_clear(\u0026segment-\u003epurge_mask, \u0026mask);\n\treturn true;\n}\n\n\nstatic void\nmi_segment_schedule_purge(mi_segment_t* segment, uint8_t* p, size_t size, mi_stats_t* stats)\n{\n\tif (!segment-\u003eallow_purge)\n\t\treturn;\n\n\tif (mi_option_get(mi_option_purge_delay) \u003d\u003d 0) {\n\t\tmi_segment_purge(segment, p, size, stats);\n\t} else {\n\t\t// register for future purge in the purge mask\n\t\tuint8_t* start \u003d NULL;\n\t\tsize_t full_size \u003d 0;\n\t\tmi_commit_mask_t mask;\n\t\tmi_segment_commit_mask(segment, true /*conservative*/, p, size, \u0026start, \u0026full_size, \u0026mask);\n\t\tif (mi_commit_mask_is_empty(\u0026mask) || full_size \u003d\u003d 0)\n\t\t\treturn;\n\n\t\t// update delayed commit\n\t\tmi_assert_internal(\n\t\t\tsegment-\u003epurge_expire \u003e 0 || mi_commit_mask_is_empty(\u0026segment-\u003epurge_mask));\n\t\tmi_commit_mask_t cmask;\n\t\tmi_commit_mask_create_intersect(\u0026segment-\u003ecommit_mask, \u0026mask,\n\t\t\t\u0026cmask); // only purge what is committed; span_free may try to decommit more\n\t\tmi_commit_mask_set(\u0026segment-\u003epurge_mask, \u0026cmask);\n\t\tmi_msecs_t now \u003d _mi_clock_now();\n\t\tif (segment-\u003epurge_expire \u003d\u003d 0) {\n\t\t\t// no previous purgess, initialize now\n\t\t\tsegment-\u003epurge_expire \u003d now + mi_option_get(mi_option_purge_delay);\n\t\t} else if (segment-\u003epurge_expire \u003c\u003d now) {\n\t\t\t// previous purge mask already expired\n\t\t\tif (segment-\u003epurge_expire + mi_option_get(mi_option_purge_extend_delay) \u003c\u003d now) {\n\t\t\t\tmi_segment_try_purge(segment, true, stats);\n\t\t\t} else {\n\t\t\t\tsegment-\u003epurge_expire \u003d now\n\t\t\t\t\t+ mi_option_get(\n\t\t\t\t\t\tmi_option_purge_extend_delay); // (mi_option_get(mi_option_purge_delay) /\n\t\t\t\t\t\t\t\t\t\t\t\t\t   // 8); // wait a tiny bit longer in case\n\t\t\t\t\t\t\t\t\t\t\t\t\t   // there is a series of free\u0027s\n\t\t\t}\n\t\t} else {\n\t\t\t// previous purge mask is not yet expired, increase the expiration by a bit.\n\t\t\tsegment-\u003epurge_expire +\u003d mi_option_get(mi_option_purge_extend_delay);\n\t\t}\n\t}\n}\n\n\nstatic void\nmi_segment_try_purge(mi_segment_t* segment, bool force, mi_stats_t* stats)\n{\n\tif (!segment-\u003eallow_purge || mi_commit_mask_is_empty(\u0026segment-\u003epurge_mask))\n\t\treturn;\n\tmi_msecs_t now \u003d _mi_clock_now();\n\tif (!force \u0026\u0026 now \u003c segment-\u003epurge_expire)\n\t\treturn;\n\n\tmi_commit_mask_t mask \u003d segment-\u003epurge_mask;\n\tsegment-\u003epurge_expire \u003d 0;\n\tmi_commit_mask_create_empty(\u0026segment-\u003epurge_mask);\n\n\tsize_t idx;\n\tsize_t count;\n\tmi_commit_mask_foreach(\u0026mask, idx, count)\n\t{\n\t\t// if found, decommit that sequence\n\t\tif (count \u003e 0) {\n\t\t\tuint8_t* p \u003d (uint8_t*)segment + (idx * MI_COMMIT_SIZE);\n\t\t\tsize_t size \u003d count * MI_COMMIT_SIZE;\n\t\t\tmi_segment_purge(segment, p, size, stats);\n\t\t}\n\t}\n\tmi_commit_mask_foreach_end() mi_assert_internal(mi_commit_mask_is_empty(\u0026segment-\u003epurge_mask));\n```",
      "range": {
        "startLine": 413,
        "startChar": 0,
        "endLine": 590,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1e78275f_b6141b5b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 599,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_segment_is_abandoned(mi_segment_t* segment)\n{\n\treturn segment-\u003ethread_id \u003d\u003d 0;\n```",
      "range": {
        "startLine": 598,
        "startChar": 0,
        "endLine": 599,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f3e1514_8696703a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 629,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_segment_span_free(mi_segment_t* segment, size_t slice_index, size_t slice_count,\n\tbool allow_purge, mi_segments_tld_t* tld)\n{\n\tmi_assert_internal(slice_index \u003c segment-\u003eslice_entries);\n\tmi_span_queue_t* sq \u003d (segment-\u003ekind \u003d\u003d MI_SEGMENT_HUGE || mi_segment_is_abandoned(segment)\n\t\t\t? NULL\n\t\t\t: mi_span_queue_for(slice_count, tld));\n\tif (slice_count \u003d\u003d 0)\n\t\tslice_count \u003d 1;\n\tmi_assert_internal(slice_index + slice_count - 1 \u003c segment-\u003eslice_entries);\n\n\t// set first and last slice (the intermediates can be undetermined)\n\tmi_slice_t* slice \u003d \u0026segment-\u003eslices[slice_index];\n\tslice-\u003eslice_count \u003d (uint32_t)slice_count;\n\tmi_assert_internal(slice-\u003eslice_count \u003d\u003d slice_count); // no overflow?\n\tslice-\u003eslice_offset \u003d 0;\n\tif (slice_count \u003e 1) {\n\t\tmi_slice_t* last \u003d \u0026segment-\u003eslices[slice_index + slice_count - 1];\n\t\tlast-\u003eslice_count \u003d 0;\n\t\tlast-\u003eslice_offset \u003d (uint32_t)(sizeof(mi_page_t) * (slice_count - 1));\n\t\tlast-\u003exblock_size \u003d 0;\n\t}\n\n\t// perhaps decommit\n\tif (allow_purge) {\n\t\tmi_segment_schedule_purge(segment, mi_slice_start(slice),\n\t\t\tslice_count * MI_SEGMENT_SLICE_SIZE, tld-\u003estats);\n\t}\n\n\t// and push it on the free page queue (if it was not a huge page)\n\tif (sq !\u003d NULL)\n\t\tmi_span_queue_push(sq, slice);\n\telse\n\t\tslice-\u003exblock_size \u003d 0; // mark huge page as free anyways\n```",
      "range": {
        "startLine": 603,
        "startChar": 0,
        "endLine": 629,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "39312d2a_4b020046",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 646,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_segment_span_remove_from_queue(mi_slice_t* slice, mi_segments_tld_t* tld)\n{\n\tmi_assert_internal(\n\t\tslice-\u003eslice_count \u003e 0 \u0026\u0026 slice-\u003eslice_offset \u003d\u003d 0 \u0026\u0026 slice-\u003exblock_size \u003d\u003d 0);\n\tmi_assert_internal(_mi_ptr_segment(slice)-\u003ekind !\u003d MI_SEGMENT_HUGE);\n\tmi_span_queue_t* sq \u003d mi_span_queue_for(slice-\u003eslice_count, tld);\n\tmi_span_queue_delete(sq, slice);\n```",
      "range": {
        "startLine": 642,
        "startChar": 0,
        "endLine": 646,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aae8bb85_ccbbe9f3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 691,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_slice_t*\nmi_segment_span_free_coalesce(mi_slice_t* slice, mi_segments_tld_t* tld)\n{\n\tmi_assert_internal(slice !\u003d NULL \u0026\u0026 slice-\u003eslice_count \u003e 0 \u0026\u0026 slice-\u003eslice_offset \u003d\u003d 0);\n\tmi_segment_t* segment \u003d _mi_ptr_segment(slice);\n\tbool is_abandoned \u003d mi_segment_is_abandoned(segment);\n\n\t// for huge pages, just mark as free but don\u0027t add to the queues\n\tif (segment-\u003ekind \u003d\u003d MI_SEGMENT_HUGE) {\n\t\t// issue #691: segment-\u003eused can be 0 if the huge page block was freed while abandoned\n\t\t// (reclaim will get here in that case)\n\t\tmi_assert_internal((segment-\u003eused \u003d\u003d 0 \u0026\u0026 slice-\u003exblock_size \u003d\u003d 0)\n\t\t\t|| segment-\u003eused \u003d\u003d 1); // decreased right after this call in `mi_segment_page_clear`\n\t\tslice-\u003exblock_size \u003d 0; // mark as free anyways\n\t\t// we should mark the last slice `xblock_size\u003d0` now to maintain invariants but we skip it\n\t\t// to avoid a possible cache miss (and the segment is about to be freed)\n\t\treturn slice;\n\t}\n\n\t// otherwise coalesce the span and add to the free span queues\n\tsize_t slice_count \u003d slice-\u003eslice_count;\n\tmi_slice_t* next \u003d slice + slice-\u003eslice_count;\n\tmi_assert_internal(next \u003c\u003d mi_segment_slices_end(segment));\n\tif (next \u003c mi_segment_slices_end(segment) \u0026\u0026 next-\u003exblock_size \u003d\u003d 0) {\n\t\t// free next block -- remove it from free and merge\n\t\tmi_assert_internal(next-\u003eslice_count \u003e 0 \u0026\u0026 next-\u003eslice_offset \u003d\u003d 0);\n\t\tslice_count +\u003d next-\u003eslice_count; // extend\n\t\tif (!is_abandoned)\n\t\t\tmi_segment_span_remove_from_queue(next, tld);\n\t}\n\tif (slice \u003e segment-\u003eslices) {\n\t\tmi_slice_t* prev \u003d mi_slice_first(slice - 1);\n\t\tmi_assert_internal(prev \u003e\u003d segment-\u003eslices);\n\t\tif (prev-\u003exblock_size \u003d\u003d 0) {\n\t\t\t// free previous slice -- remove it from free and merge\n\t\t\tmi_assert_internal(prev-\u003eslice_count \u003e 0 \u0026\u0026 prev-\u003eslice_offset \u003d\u003d 0);\n\t\t\tslice_count +\u003d prev-\u003eslice_count;\n\t\t\tif (!is_abandoned)\n\t\t\t\tmi_segment_span_remove_from_queue(prev, tld);\n\t\t\tslice \u003d prev;\n\t\t}\n\t}\n\n\t// and add the new free page\n\tmi_segment_span_free(segment, mi_slice_index(slice), slice_count, true, tld);\n\treturn slice;\n}\n```",
      "range": {
        "startLine": 650,
        "startChar": 0,
        "endLine": 691,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d84456c6_9526745e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 790,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_segment_span_allocate(mi_segment_t* segment, size_t slice_index, size_t slice_count,\n\tmi_segments_tld_t* tld)\n{\n\tmi_assert_internal(slice_index \u003c segment-\u003eslice_entries);\n\tmi_slice_t* const slice \u003d \u0026segment-\u003eslices[slice_index];\n\tmi_assert_internal(slice-\u003exblock_size \u003d\u003d 0 || slice-\u003exblock_size \u003d\u003d 1);\n\n\t// commit before changing the slice data\n\tif (!mi_segment_ensure_committed(segment,\n\t\t\t_mi_segment_page_start_from_slice(segment, slice, 0, NULL),\n\t\t\tslice_count * MI_SEGMENT_SLICE_SIZE, tld-\u003estats)) {\n\t\treturn NULL; // commit failed!\n\t}\n\n\t// convert the slices to a page\n\tslice-\u003eslice_offset \u003d 0;\n\tslice-\u003eslice_count \u003d (uint32_t)slice_count;\n\tmi_assert_internal(slice-\u003eslice_count \u003d\u003d slice_count);\n\tconst size_t bsize \u003d slice_count * MI_SEGMENT_SLICE_SIZE;\n\tslice-\u003exblock_size \u003d (uint32_t)(bsize \u003e\u003d MI_HUGE_BLOCK_SIZE ? MI_HUGE_BLOCK_SIZE : bsize);\n\tmi_page_t* page \u003d mi_slice_to_page(slice);\n\tmi_assert_internal(mi_page_block_size(page) \u003d\u003d bsize);\n\n\t// set slice back pointers for the first MI_MAX_SLICE_OFFSET entries\n\tsize_t extra \u003d slice_count - 1;\n\tif (extra \u003e MI_MAX_SLICE_OFFSET)\n\t\textra \u003d MI_MAX_SLICE_OFFSET;\n\tif (slice_index + extra \u003e\u003d segment-\u003eslice_entries) {\n\t\textra \u003d segment-\u003eslice_entries - slice_index\n\t\t\t- 1; // huge objects may have more slices than avaiable entries in the segment-\u003eslices\n\t}\n\n\tmi_slice_t* slice_next \u003d slice + 1;\n\tfor (size_t i \u003d 1; i \u003c\u003d extra; i++, slice_next++) {\n\t\tslice_next-\u003eslice_offset \u003d (uint32_t)(sizeof(mi_slice_t) * i);\n\t\tslice_next-\u003eslice_count \u003d 0;\n\t\tslice_next-\u003exblock_size \u003d 1;\n\t}\n\n\t// and also for the last one (if not set already) (the last one is needed for coalescing and for\n\t// large alignments) note: the cast is needed for ubsan since the index can be larger than\n\t// MI_SLICES_PER_SEGMENT for huge allocations (see #543)\n\tmi_slice_t* last \u003d slice + slice_count - 1;\n\tmi_slice_t* end \u003d (mi_slice_t*)mi_segment_slices_end(segment);\n\tif (last \u003e end)\n\t\tlast \u003d end;\n\tif (last \u003e slice) {\n\t\tlast-\u003eslice_offset \u003d (uint32_t)(sizeof(mi_slice_t) * (last - slice));\n\t\tlast-\u003eslice_count \u003d 0;\n\t\tlast-\u003exblock_size \u003d 1;\n\t}\n\n\t// and initialize the page\n\tpage-\u003eis_committed \u003d true;\n\tsegment-\u003eused++;\n\treturn page;\n}\n\n\nstatic void\nmi_segment_slice_split(mi_segment_t* segment, mi_slice_t* slice, size_t slice_count,\n\tmi_segments_tld_t* tld)\n{\n\tmi_assert_internal(_mi_ptr_segment(slice) \u003d\u003d segment);\n\tmi_assert_internal(slice-\u003eslice_count \u003e\u003d slice_count);\n\tmi_assert_internal(slice-\u003exblock_size \u003e 0); // no more in free queue\n\tif (slice-\u003eslice_count \u003c\u003d slice_count)\n\t\treturn;\n\tmi_assert_internal(segment-\u003ekind !\u003d MI_SEGMENT_HUGE);\n\tsize_t next_index \u003d mi_slice_index(slice) + slice_count;\n\tsize_t next_count \u003d slice-\u003eslice_count - slice_count;\n\tmi_segment_span_free(segment, next_index, next_count, false /* don\u0027t purge left-over part */,\n\t\ttld);\n\tslice-\u003eslice_count \u003d (uint32_t)slice_count;\n}\n\n\nstatic mi_page_t*\nmi_segments_page_find_and_allocate(size_t slice_count, mi_arena_id_t req_arena_id,\n\tmi_segments_tld_t* tld)\n{\n\tmi_assert_internal(slice_count * MI_SEGMENT_SLICE_SIZE \u003c\u003d MI_LARGE_OBJ_SIZE_MAX);\n\t// search from best fit up\n\tmi_span_queue_t* sq \u003d mi_span_queue_for(slice_count, tld);\n\tif (slice_count \u003d\u003d 0)\n\t\tslice_count \u003d 1;\n\twhile (sq \u003c\u003d \u0026tld-\u003espans[MI_SEGMENT_BIN_MAX]) {\n\t\tfor (mi_slice_t* slice \u003d sq-\u003efirst; slice !\u003d NULL; slice \u003d slice-\u003enext) {\n\t\t\tif (slice-\u003eslice_count \u003e\u003d slice_count) {\n\t\t\t\t// found one\n\t\t\t\tmi_segment_t* segment \u003d _mi_ptr_segment(slice);\n\t\t\t\tif (_mi_arena_memid_is_suitable(segment-\u003ememid, req_arena_id)) {\n\t\t\t\t\t// found a suitable page span\n\t\t\t\t\tmi_span_queue_delete(sq, slice);\n\n\t\t\t\t\tif (slice-\u003eslice_count \u003e slice_count)\n\t\t\t\t\t\tmi_segment_slice_split(segment, slice, slice_count, tld);\n\t\t\t\t\tmi_assert_internal(slice !\u003d NULL \u0026\u0026 slice-\u003eslice_count \u003d\u003d slice_count\n\t\t\t\t\t\t\u0026\u0026 slice-\u003exblock_size \u003e 0);\n\t\t\t\t\tmi_page_t* page \u003d mi_segment_span_allocate(segment, mi_slice_index(slice),\n\t\t\t\t\t\tslice-\u003eslice_count, tld);\n\t\t\t\t\tif (page \u003d\u003d NULL) {\n\t\t\t\t\t\t// commit failed; return NULL but first restore the slice\n\t\t\t\t\t\tmi_segment_span_free_coalesce(slice, tld);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treturn page;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsq++;\n\t}\n\t// could not find a page..\n\treturn NULL;\n```",
      "range": {
        "startLine": 699,
        "startChar": 0,
        "endLine": 790,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a6c7425e_de7b8cab",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 854,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_segment_t*\nmi_segment_os_alloc(size_t required, size_t page_alignment, bool eager_delayed,\n\tmi_arena_id_t req_arena_id, size_t* psegment_slices, size_t* ppre_size, size_t* pinfo_slices,\n\tbool commit, mi_segments_tld_t* tld, mi_os_tld_t* os_tld)\n\n{\n\tmi_memid_t memid;\n\tbool allow_large \u003d (!eager_delayed\n\t\t\u0026\u0026 (MI_SECURE \u003d\u003d 0)); // only allow large OS pages once we are no longer lazy\n\tsize_t align_offset \u003d 0;\n\tsize_t alignment \u003d MI_SEGMENT_ALIGN;\n\n\tif (page_alignment \u003e 0) {\n\t\t// mi_assert_internal(huge_page !\u003d NULL);\n\t\tmi_assert_internal(page_alignment \u003e\u003d MI_SEGMENT_ALIGN);\n\t\talignment \u003d page_alignment;\n\t\tconst size_t info_size \u003d (*pinfo_slices) * MI_SEGMENT_SLICE_SIZE;\n\t\talign_offset \u003d _mi_align_up(info_size, MI_SEGMENT_ALIGN);\n\t\tconst size_t extra \u003d align_offset - info_size;\n\t\t// recalculate due to potential guard pages\n\t\t*psegment_slices \u003d mi_segment_calculate_slices(required + extra, ppre_size, pinfo_slices);\n\t}\n\n\tconst size_t segment_size \u003d (*psegment_slices) * MI_SEGMENT_SLICE_SIZE;\n\tmi_segment_t* segment \u003d (mi_segment_t*)_mi_arena_alloc_aligned(segment_size, alignment,\n\t\talign_offset, commit, allow_large, req_arena_id, \u0026memid, os_tld);\n\tif (segment \u003d\u003d NULL)\n\t\treturn NULL; // failed to allocate\n\n\t// ensure metadata part of the segment is committed\n\tmi_commit_mask_t commit_mask;\n\tif (memid.initially_committed) {\n\t\tmi_commit_mask_create_full(\u0026commit_mask);\n\t} else {\n\t\t// at least commit the info slices\n\t\tconst size_t commit_needed\n\t\t\t\u003d _mi_divide_up((*pinfo_slices) * MI_SEGMENT_SLICE_SIZE, MI_COMMIT_SIZE);\n\t\tmi_assert_internal(commit_needed \u003e 0);\n\t\tmi_commit_mask_create(0, commit_needed, \u0026commit_mask);\n\t\tmi_assert_internal(\n\t\t\tcommit_needed * MI_COMMIT_SIZE \u003e\u003d (*pinfo_slices) * MI_SEGMENT_SLICE_SIZE);\n\t\tif (!_mi_os_commit(segment, commit_needed * MI_COMMIT_SIZE, NULL, tld-\u003estats)) {\n\t\t\t_mi_arena_free(segment, segment_size, 0, memid, tld-\u003estats);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmi_assert_internal(segment !\u003d NULL \u0026\u0026 (uintptr_t)segment % MI_SEGMENT_SIZE \u003d\u003d 0);\n\n\tsegment-\u003ememid \u003d memid;\n\tsegment-\u003eallow_decommit \u003d !memid.is_pinned;\n\tsegment-\u003eallow_purge \u003d segment-\u003eallow_decommit \u0026\u0026 (mi_option_get(mi_option_purge_delay) \u003e\u003d 0);\n\tsegment-\u003esegment_size \u003d segment_size;\n\tsegment-\u003ecommit_mask \u003d commit_mask;\n\tsegment-\u003epurge_expire \u003d 0;\n\tmi_commit_mask_create_empty(\u0026segment-\u003epurge_mask);\n\tmi_atomic_store_ptr_release(mi_segment_t, \u0026segment-\u003eabandoned_next, NULL); // tsan\n\n\tmi_segments_track_size((long)(segment_size), tld);\n\t_mi_segment_map_allocated_at(segment);\n\treturn segment;\n```",
      "range": {
        "startLine": 798,
        "startChar": 0,
        "endLine": 854,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "672574eb_fd867e29",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 969,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_segment_t*\nmi_segment_alloc(size_t required, size_t page_alignment, mi_arena_id_t req_arena_id,\n\tmi_segments_tld_t* tld, mi_os_tld_t* os_tld, mi_page_t** huge_page)\n{\n\tmi_assert_internal((required \u003d\u003d 0 \u0026\u0026 huge_page \u003d\u003d NULL) || (required \u003e 0 \u0026\u0026 huge_page !\u003d NULL));\n\n\t// calculate needed sizes first\n\tsize_t info_slices;\n\tsize_t pre_size;\n\tsize_t segment_slices \u003d mi_segment_calculate_slices(required, \u0026pre_size, \u0026info_slices);\n\n\t// Commit eagerly only if not the first N lazy segments (to reduce impact of many threads that\n\t// allocate just a little)\n\tconst bool eager_delay\n\t\t\u003d ( // !_mi_os_has_overcommit() \u0026\u0026             // never delay on overcommit systems\n\t\t\t_mi_current_thread_count() \u003e 1 \u0026\u0026 // do not delay for the first N threads\n\t\t\ttld-\u003ecount \u003c (size_t)mi_option_get(mi_option_eager_commit_delay));\n\tconst bool eager \u003d !eager_delay \u0026\u0026 mi_option_is_enabled(mi_option_eager_commit);\n\tbool commit \u003d eager || (required \u003e 0);\n\n\t// Allocate the segment from the OS\n\tmi_segment_t* segment \u003d mi_segment_os_alloc(required, page_alignment, eager_delay, req_arena_id,\n\t\t\u0026segment_slices, \u0026pre_size, \u0026info_slices, commit, tld, os_tld);\n\tif (segment \u003d\u003d NULL)\n\t\treturn NULL;\n\n\t// zero the segment info? -- not always needed as it may be zero initialized from the OS\n\tif (!segment-\u003ememid.initially_zero) {\n\t\tptrdiff_t ofs \u003d offsetof(mi_segment_t, next);\n\t\tsize_t prefix \u003d offsetof(mi_segment_t, slices) - ofs;\n\t\tsize_t zsize \u003d prefix + (sizeof(mi_slice_t) * (segment_slices + 1)); // one more\n\t\t_mi_memzero((uint8_t*)segment + ofs, zsize);\n\t}\n\n\t// initialize the rest of the segment info\n\tconst size_t slice_entries\n\t\t\u003d (segment_slices \u003e MI_SLICES_PER_SEGMENT ? MI_SLICES_PER_SEGMENT : segment_slices);\n\tsegment-\u003esegment_slices \u003d segment_slices;\n\tsegment-\u003esegment_info_slices \u003d info_slices;\n\tsegment-\u003ethread_id \u003d _mi_thread_id();\n\tsegment-\u003ecookie \u003d _mi_ptr_cookie(segment);\n\tsegment-\u003eslice_entries \u003d slice_entries;\n\tsegment-\u003ekind \u003d (required \u003d\u003d 0 ? MI_SEGMENT_NORMAL : MI_SEGMENT_HUGE);\n\n\t// _mi_memzero(segment-\u003eslices, sizeof(mi_slice_t)*(info_slices+1));\n\t_mi_stat_increase(\u0026tld-\u003estats-\u003epage_committed, mi_segment_info_size(segment));\n\n\t// set up guard pages\n\tsize_t guard_slices \u003d 0;\n\tif (MI_SECURE \u003e 0) {\n\t\t// in secure mode, we set up a protected page in between the segment info\n\t\t// and the page data, and at the end of the segment.\n\t\tsize_t os_pagesize \u003d _mi_os_page_size();\n\t\tmi_assert_internal(mi_segment_info_size(segment) - os_pagesize \u003e\u003d pre_size);\n\t\t_mi_os_protect((uint8_t*)segment + mi_segment_info_size(segment) - os_pagesize,\n\t\t\tos_pagesize);\n\t\tuint8_t* end \u003d (uint8_t*)segment + mi_segment_size(segment) - os_pagesize;\n\t\tmi_segment_ensure_committed(segment, end, os_pagesize, tld-\u003estats);\n\t\t_mi_os_protect(end, os_pagesize);\n\t\tif (slice_entries \u003d\u003d segment_slices)\n\t\t\tsegment-\u003eslice_entries--; // don\u0027t use the last slice :-(\n\t\tguard_slices \u003d 1;\n\t}\n\n\t// reserve first slices for segment info\n\tmi_page_t* page0 \u003d mi_segment_span_allocate(segment, 0, info_slices, tld);\n\tmi_assert_internal(page0 !\u003d NULL);\n\tif (page0 \u003d\u003d NULL)\n\t\treturn NULL; // cannot fail as we always commit in advance\n\tmi_assert_internal(segment-\u003eused \u003d\u003d 1);\n\tsegment-\u003eused \u003d 0; // don\u0027t count our internal slices towards usage\n\n\t// initialize initial free pages\n\tif (segment-\u003ekind \u003d\u003d MI_SEGMENT_NORMAL) { // not a huge page\n\t\tmi_assert_internal(huge_page \u003d\u003d NULL);\n\t\tmi_segment_span_free(segment, info_slices, segment-\u003eslice_entries - info_slices,\n\t\t\tfalse /* don\u0027t purge */, tld);\n\t} else {\n\t\tmi_assert_internal(huge_page !\u003d NULL);\n\t\tmi_assert_internal(mi_commit_mask_is_empty(\u0026segment-\u003epurge_mask));\n\t\tmi_assert_internal(mi_commit_mask_is_full(\u0026segment-\u003ecommit_mask));\n\t\t*huge_page \u003d mi_segment_span_allocate(segment, info_slices,\n\t\t\tsegment_slices - info_slices - guard_slices, tld);\n\t\tmi_assert_internal(*huge_page !\u003d NULL); // cannot fail as we commit in advance\n\t}\n\n\tmi_assert_expensive(mi_segment_is_valid(segment, tld));\n\treturn segment;\n}\n\n\nstatic void\nmi_segment_free(mi_segment_t* segment, bool force, mi_segments_tld_t* tld)\n{\n\tMI_UNUSED(force);\n\tmi_assert_internal(segment !\u003d NULL);\n\tmi_assert_internal(segment-\u003enext \u003d\u003d NULL);\n\tmi_assert_internal(segment-\u003eused \u003d\u003d 0);\n\n\t// Remove the free pages\n\tmi_slice_t* slice \u003d \u0026segment-\u003eslices[0];\n\tconst mi_slice_t* end \u003d mi_segment_slices_end(segment);\n#if MI_DEBUG \u003e 1\n\tsize_t page_count \u003d 0;\n#endif\n\twhile (slice \u003c end) {\n\t\tmi_assert_internal(slice-\u003eslice_count \u003e 0);\n\t\tmi_assert_internal(slice-\u003eslice_offset \u003d\u003d 0);\n\t\tmi_assert_internal(\n\t\t\tmi_slice_index(slice) \u003d\u003d 0 || slice-\u003exblock_size \u003d\u003d 0); // no more used pages ..\n\t\tif (slice-\u003exblock_size \u003d\u003d 0 \u0026\u0026 segment-\u003ekind !\u003d MI_SEGMENT_HUGE)\n\t\t\tmi_segment_span_remove_from_queue(slice, tld);\n#if MI_DEBUG \u003e 1\n\t\tpage_count++;\n#endif\n\t\tslice \u003d slice + slice-\u003eslice_count;\n\t}\n\tmi_assert_internal(page_count \u003d\u003d 2); // first page is allocated by the segment itself\n\n\t// stats\n\t_mi_stat_decrease(\u0026tld-\u003estats-\u003epage_committed, mi_segment_info_size(segment));\n\n\t// return it to the OS\n\tmi_segment_os_free(segment, tld);\n```",
      "range": {
        "startLine": 859,
        "startChar": 0,
        "endLine": 969,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f8761eb_089df56c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1029,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_slice_t*\nmi_segment_page_clear(mi_page_t* page, mi_segments_tld_t* tld)\n{\n\tmi_assert_internal(page-\u003exblock_size \u003e 0);\n\tmi_assert_internal(mi_page_all_free(page));\n\tmi_segment_t* segment \u003d _mi_ptr_segment(page);\n\tmi_assert_internal(segment-\u003eused \u003e 0);\n\n\tsize_t inuse \u003d page-\u003ecapacity * mi_page_block_size(page);\n\t_mi_stat_decrease(\u0026tld-\u003estats-\u003epage_committed, inuse);\n\t_mi_stat_decrease(\u0026tld-\u003estats-\u003epages, 1);\n\n\t// reset the page memory to reduce memory pressure?\n\tif (segment-\u003eallow_decommit \u0026\u0026 mi_option_is_enabled(mi_option_deprecated_page_reset)) {\n\t\tsize_t psize;\n\t\tuint8_t* start \u003d _mi_page_start(segment, page, \u0026psize);\n\t\t_mi_os_reset(start, psize, tld-\u003estats);\n\t}\n\n\t// zero the page data, but not the segment fields\n\tpage-\u003eis_zero_init \u003d false;\n\tptrdiff_t ofs \u003d offsetof(mi_page_t, capacity);\n\t_mi_memzero((uint8_t*)page + ofs, sizeof(*page) - ofs);\n\tpage-\u003exblock_size \u003d 1;\n\n\t// and free it\n\tmi_slice_t* slice \u003d mi_segment_span_free_coalesce(mi_page_to_slice(page), tld);\n\tsegment-\u003eused--;\n\t// cannot assert segment valid as it is called during reclaim\n\t// mi_assert_expensive(mi_segment_is_valid(segment, tld));\n\treturn slice;\n}\n\n\nvoid\n_mi_segment_page_free(mi_page_t* page, bool force, mi_segments_tld_t* tld)\n{\n\tmi_assert(page !\u003d NULL);\n\n\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\tmi_assert_expensive(mi_segment_is_valid(segment, tld));\n\n\t// mark it as free now\n\tmi_segment_page_clear(page, tld);\n\tmi_assert_expensive(mi_segment_is_valid(segment, tld));\n\n\tif (segment-\u003eused \u003d\u003d 0) {\n\t\t// no more used pages; remove from the free list and free the segment\n\t\tmi_segment_free(segment, force, tld);\n\t} else if (segment-\u003eused \u003d\u003d segment-\u003eabandoned) {\n\t\t// only abandoned pages; remove from free list and abandon\n\t\tmi_segment_abandon(segment, tld);\n\t}\n```",
      "range": {
        "startLine": 980,
        "startChar": 0,
        "endLine": 1029,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3747012f_a62638a4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1071,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define MI_TAGGED_MASK MI_SEGMENT_MASK\ntypedef uintptr_t mi_tagged_segment_t;\n\n\nstatic mi_segment_t*\nmi_tagged_segment_ptr(mi_tagged_segment_t ts)\n{\n\treturn (mi_segment_t*)(ts \u0026 ~MI_TAGGED_MASK);\n}\n\n\nstatic mi_tagged_segment_t\nmi_tagged_segment(mi_segment_t* segment, mi_tagged_segment_t ts)\n{\n\tmi_assert_internal(((uintptr_t)segment \u0026 MI_TAGGED_MASK) \u003d\u003d 0);\n\tuintptr_t tag \u003d ((ts \u0026 MI_TAGGED_MASK) + 1) \u0026 MI_TAGGED_MASK;\n\treturn (uintptr_t)segment | tag;\n```",
      "range": {
        "startLine": 1061,
        "startChar": 0,
        "endLine": 1071,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9729f5d2_0c7ea789",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1077,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_cache_align _Atomic(mi_segment_t*) abandoned_visited; // \u003d NULL\n```",
      "range": {
        "startLine": 1077,
        "startChar": 0,
        "endLine": 1077,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d27ede30_22a044a6",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1080,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_cache_align _Atomic(mi_tagged_segment_t) abandoned; // \u003d NULL\n```",
      "range": {
        "startLine": 1080,
        "startChar": 0,
        "endLine": 1080,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "09550706_91f31c19",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1084,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_cache_align _Atomic(size_t) abandoned_count;\nstatic mi_decl_cache_align _Atomic(size_t) abandoned_visited_count;\n```",
      "range": {
        "startLine": 1083,
        "startChar": 0,
        "endLine": 1084,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85daec21_c086b28e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1089,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_decl_cache_align _Atomic(size_t) abandoned_readers; // \u003d 0\n```",
      "range": {
        "startLine": 1089,
        "startChar": 0,
        "endLine": 1089,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6fdd2f36_7b0a82c8",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1101,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_abandoned_visited_push(mi_segment_t* segment)\n{\n\tmi_assert_internal(segment-\u003ethread_id \u003d\u003d 0);\n\tmi_assert_internal(mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026segment-\u003eabandoned_next) \u003d\u003d NULL);\n\tmi_assert_internal(segment-\u003enext \u003d\u003d NULL);\n\tmi_assert_internal(segment-\u003eused \u003e 0);\n\tmi_segment_t* anext \u003d mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026abandoned_visited);\n\tdo {\n\t\tmi_atomic_store_ptr_release(mi_segment_t, \u0026segment-\u003eabandoned_next, anext);\n\t} while (!mi_atomic_cas_ptr_weak_release(mi_segment_t, \u0026abandoned_visited, \u0026anext, segment));\n\tmi_atomic_increment_relaxed(\u0026abandoned_visited_count);\n```",
      "range": {
        "startLine": 1092,
        "startChar": 0,
        "endLine": 1101,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fecf328_e5d3d347",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1145,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_abandoned_visited_revisit(void)\n{\n\t// quick check if the visited list is empty\n\tif (mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026abandoned_visited) \u003d\u003d NULL)\n\t\treturn false;\n\n\t// grab the whole visited list\n\tmi_segment_t* first \u003d mi_atomic_exchange_ptr_acq_rel(mi_segment_t, \u0026abandoned_visited, NULL);\n\tif (first \u003d\u003d NULL)\n\t\treturn false;\n\n\t// first try to swap directly if the abandoned list happens to be NULL\n\tmi_tagged_segment_t afirst;\n\tmi_tagged_segment_t ts \u003d mi_atomic_load_relaxed(\u0026abandoned);\n\tif (mi_tagged_segment_ptr(ts) \u003d\u003d NULL) {\n\t\tsize_t count \u003d mi_atomic_load_relaxed(\u0026abandoned_visited_count);\n\t\tafirst \u003d mi_tagged_segment(first, ts);\n\t\tif (mi_atomic_cas_strong_acq_rel(\u0026abandoned, \u0026ts, afirst)) {\n\t\t\tmi_atomic_add_relaxed(\u0026abandoned_count, count);\n\t\t\tmi_atomic_sub_relaxed(\u0026abandoned_visited_count, count);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// find the last element of the visited list: O(n)\n\tmi_segment_t* last \u003d first;\n\tmi_segment_t* next;\n\twhile ((next \u003d mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026last-\u003eabandoned_next)) !\u003d NULL)\n\t\tlast \u003d next;\n\n\t// and atomically prepend to the abandoned list\n\t// (no need to increase the readers as we don\u0027t access the abandoned segments)\n\tmi_tagged_segment_t anext \u003d mi_atomic_load_relaxed(\u0026abandoned);\n\tsize_t count;\n\tdo {\n\t\tcount \u003d mi_atomic_load_relaxed(\u0026abandoned_visited_count);\n\t\tmi_atomic_store_ptr_release(mi_segment_t, \u0026last-\u003eabandoned_next,\n\t\t\tmi_tagged_segment_ptr(anext));\n\t\tafirst \u003d mi_tagged_segment(first, anext);\n\t} while (!mi_atomic_cas_weak_release(\u0026abandoned, \u0026anext, afirst));\n\tmi_atomic_add_relaxed(\u0026abandoned_count, count);\n\tmi_atomic_sub_relaxed(\u0026abandoned_visited_count, count);\n\treturn true;\n```",
      "range": {
        "startLine": 1105,
        "startChar": 0,
        "endLine": 1145,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e5ba4d57_80256e58",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1160,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_abandoned_push(mi_segment_t* segment)\n{\n\tmi_assert_internal(segment-\u003ethread_id \u003d\u003d 0);\n\tmi_assert_internal(mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026segment-\u003eabandoned_next) \u003d\u003d NULL);\n\tmi_assert_internal(segment-\u003enext \u003d\u003d NULL);\n\tmi_assert_internal(segment-\u003eused \u003e 0);\n\tmi_tagged_segment_t next;\n\tmi_tagged_segment_t ts \u003d mi_atomic_load_relaxed(\u0026abandoned);\n\tdo {\n\t\tmi_atomic_store_ptr_release(mi_segment_t, \u0026segment-\u003eabandoned_next,\n\t\t\tmi_tagged_segment_ptr(ts));\n\t\tnext \u003d mi_tagged_segment(segment, ts);\n\t} while (!mi_atomic_cas_weak_release(\u0026abandoned, \u0026ts, next));\n\tmi_atomic_increment_relaxed(\u0026abandoned_count);\n```",
      "range": {
        "startLine": 1149,
        "startChar": 0,
        "endLine": 1160,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f0304fe_c0815983",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1170,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_abandoned_await_readers(void)\n{\n\tsize_t n;\n\tdo {\n\t\tn \u003d mi_atomic_load_acquire(\u0026abandoned_readers);\n\t\tif (n !\u003d 0)\n\t\t\tmi_atomic_yield();\n\t} while (n !\u003d 0);\n```",
      "range": {
        "startLine": 1165,
        "startChar": 0,
        "endLine": 1170,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82289fe5_ac6c9da5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1204,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_segment_t*\nmi_abandoned_pop(void)\n{\n\tmi_segment_t* segment;\n\t// Check efficiently if it is empty (or if the visited list needs to be moved)\n\tmi_tagged_segment_t ts \u003d mi_atomic_load_relaxed(\u0026abandoned);\n\tsegment \u003d mi_tagged_segment_ptr(ts);\n\tif mi_likely (segment \u003d\u003d NULL) {\n\t\tif mi_likely (!mi_abandoned_visited_revisit()) // try to swap in the visited list on NULL\n\t\t\treturn NULL;\n\t}\n\n\t// Do a pop. We use a reader count to prevent\n\t// a segment to be decommitted while a read is still pending,\n\t// and a tagged pointer to prevent A-B-A link corruption.\n\t// (this is called from `region.c:_mi_mem_free` for example)\n\tmi_atomic_increment_relaxed(\u0026abandoned_readers); // ensure no segment gets decommitted\n\tmi_tagged_segment_t next \u003d 0;\n\tts \u003d mi_atomic_load_acquire(\u0026abandoned);\n\tdo {\n\t\tsegment \u003d mi_tagged_segment_ptr(ts);\n\t\tif (segment !\u003d NULL) {\n\t\t\tmi_segment_t* anext\n\t\t\t\t\u003d mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026segment-\u003eabandoned_next);\n\t\t\tnext \u003d mi_tagged_segment(anext, ts); // note: reads the segment\u0027s `abandoned_next` field\n\t\t\t\t\t\t\t\t\t\t\t\t // so should not be decommitted\n\t\t}\n\t} while (segment !\u003d NULL \u0026\u0026 !mi_atomic_cas_weak_acq_rel(\u0026abandoned, \u0026ts, next));\n\tmi_atomic_decrement_relaxed(\u0026abandoned_readers); // release reader lock\n\tif (segment !\u003d NULL) {\n\t\tmi_atomic_store_ptr_release(mi_segment_t, \u0026segment-\u003eabandoned_next, NULL);\n\t\tmi_atomic_decrement_relaxed(\u0026abandoned_count);\n\t}\n\treturn segment;\n```",
      "range": {
        "startLine": 1174,
        "startChar": 0,
        "endLine": 1204,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f5cd9372_20964acd",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1257,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_segment_abandon(mi_segment_t* segment, mi_segments_tld_t* tld)\n{\n\tmi_assert_internal(segment-\u003eused \u003d\u003d segment-\u003eabandoned);\n\tmi_assert_internal(segment-\u003eused \u003e 0);\n\tmi_assert_internal(mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026segment-\u003eabandoned_next) \u003d\u003d NULL);\n\tmi_assert_internal(segment-\u003eabandoned_visits \u003d\u003d 0);\n\tmi_assert_expensive(mi_segment_is_valid(segment, tld));\n\n\t// remove the free pages from the free page queues\n\tmi_slice_t* slice \u003d \u0026segment-\u003eslices[0];\n\tconst mi_slice_t* end \u003d mi_segment_slices_end(segment);\n\twhile (slice \u003c end) {\n\t\tmi_assert_internal(slice-\u003eslice_count \u003e 0);\n\t\tmi_assert_internal(slice-\u003eslice_offset \u003d\u003d 0);\n\t\tif (slice-\u003exblock_size \u003d\u003d 0) { // a free page\n\t\t\tmi_segment_span_remove_from_queue(slice, tld);\n\t\t\tslice-\u003exblock_size \u003d 0; // but keep it free\n\t\t}\n\t\tslice \u003d slice + slice-\u003eslice_count;\n\t}\n\n\t// perform delayed decommits (forcing is much slower on mstress)\n\tmi_segment_try_purge(segment, mi_option_is_enabled(mi_option_abandoned_page_purge) /* force? */,\n\t\ttld-\u003estats);\n\n\t// all pages in the segment are abandoned; add it to the abandoned list\n\t_mi_stat_increase(\u0026tld-\u003estats-\u003esegments_abandoned, 1);\n\tmi_segments_track_size(-((long)mi_segment_size(segment)), tld);\n\tsegment-\u003ethread_id \u003d 0;\n\tmi_atomic_store_ptr_release(mi_segment_t, \u0026segment-\u003eabandoned_next, NULL);\n\tsegment-\u003eabandoned_visits \u003d 1; // from 0 to 1 to signify it is abandoned\n\tmi_abandoned_push(segment);\n}\n\n\nvoid\n_mi_segment_page_abandon(mi_page_t* page, mi_segments_tld_t* tld)\n{\n\tmi_assert(page !\u003d NULL);\n\tmi_assert_internal(mi_page_thread_free_flag(page) \u003d\u003d MI_NEVER_DELAYED_FREE);\n\tmi_assert_internal(mi_page_heap(page) \u003d\u003d NULL);\n\tmi_segment_t* segment \u003d _mi_page_segment(page);\n\n\tmi_assert_expensive(mi_segment_is_valid(segment, tld));\n\tsegment-\u003eabandoned++;\n\n\t_mi_stat_increase(\u0026tld-\u003estats-\u003epages_abandoned, 1);\n\tmi_assert_internal(segment-\u003eabandoned \u003c\u003d segment-\u003eused);\n\tif (segment-\u003eused \u003d\u003d segment-\u003eabandoned) {\n\t\t// all pages are abandoned, abandon the entire segment\n\t\tmi_segment_abandon(segment, tld);\n\t}\n```",
      "range": {
        "startLine": 1211,
        "startChar": 0,
        "endLine": 1257,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a36b4e3_74669df0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1269,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_slice_t*\nmi_slices_start_iterate(mi_segment_t* segment, const mi_slice_t** end)\n{\n\tmi_slice_t* slice \u003d \u0026segment-\u003eslices[0];\n\t*end \u003d mi_segment_slices_end(segment);\n\tmi_assert_internal(slice-\u003eslice_count \u003e 0 \u0026\u0026 slice-\u003exblock_size \u003e 0); // segment allocated page\n\tslice \u003d slice + slice-\u003eslice_count; // skip the first segment allocated page\n\treturn slice;\n```",
      "range": {
        "startLine": 1264,
        "startChar": 0,
        "endLine": 1269,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "959d77da_7cbbde73",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1315,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_segment_check_free(mi_segment_t* segment, size_t slices_needed, size_t block_size,\n\tmi_segments_tld_t* tld)\n{\n\tmi_assert_internal(block_size \u003c MI_HUGE_BLOCK_SIZE);\n\tmi_assert_internal(mi_segment_is_abandoned(segment));\n\tbool has_page \u003d false;\n\n\t// for all slices\n\tconst mi_slice_t* end;\n\tmi_slice_t* slice \u003d mi_slices_start_iterate(segment, \u0026end);\n\twhile (slice \u003c end) {\n\t\tmi_assert_internal(slice-\u003eslice_count \u003e 0);\n\t\tmi_assert_internal(slice-\u003eslice_offset \u003d\u003d 0);\n\t\tif (mi_slice_is_used(slice)) { // used page\n\t\t\t// ensure used count is up to date and collect potential concurrent frees\n\t\t\tmi_page_t* const page \u003d mi_slice_to_page(slice);\n\t\t\t_mi_page_free_collect(page, false);\n\t\t\tif (mi_page_all_free(page)) {\n\t\t\t\t// if this page is all free now, free it without adding to any queues (yet)\n\t\t\t\tmi_assert_internal(page-\u003enext \u003d\u003d NULL \u0026\u0026 page-\u003eprev \u003d\u003d NULL);\n\t\t\t\t_mi_stat_decrease(\u0026tld-\u003estats-\u003epages_abandoned, 1);\n\t\t\t\tsegment-\u003eabandoned--;\n\t\t\t\tslice \u003d mi_segment_page_clear(page, tld); // re-assign slice due to coalesce!\n\t\t\t\tmi_assert_internal(!mi_slice_is_used(slice));\n\t\t\t\tif (slice-\u003eslice_count \u003e\u003d slices_needed)\n\t\t\t\t\thas_page \u003d true;\n\t\t\t} else if (page-\u003exblock_size \u003d\u003d block_size \u0026\u0026 mi_page_has_any_available(page)) {\n\t\t\t\t// a page has available free blocks of the right size\n\t\t\t\thas_page \u003d true;\n\t\t\t}\n\t\t} else {\n\t\t\t// empty span\n\t\t\tif (slice-\u003eslice_count \u003e\u003d slices_needed)\n\t\t\t\thas_page \u003d true;\n\t\t}\n\t\tslice \u003d slice + slice-\u003eslice_count;\n\t}\n\treturn has_page;\n```",
      "range": {
        "startLine": 1273,
        "startChar": 0,
        "endLine": 1315,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69f340e4_5b5c976d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1449,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n// set `right_page_reclaimed` to `true` if it reclaimed a page of the right `block_size` that was\n// not full.\nstatic mi_segment_t*\nmi_segment_reclaim(mi_segment_t* segment, mi_heap_t* heap, size_t requested_block_size,\n\tbool* right_page_reclaimed, mi_segments_tld_t* tld)\n{\n\tmi_assert_internal(mi_atomic_load_ptr_relaxed(mi_segment_t, \u0026segment-\u003eabandoned_next) \u003d\u003d NULL);\n\tmi_assert_expensive(mi_segment_is_valid(segment, tld));\n\tif (right_page_reclaimed !\u003d NULL)\n\t\t*right_page_reclaimed \u003d false;\n\n\tsegment-\u003ethread_id \u003d _mi_thread_id();\n\tsegment-\u003eabandoned_visits \u003d 0;\n\tmi_segments_track_size((long)mi_segment_size(segment), tld);\n\tmi_assert_internal(segment-\u003enext \u003d\u003d NULL);\n\t_mi_stat_decrease(\u0026tld-\u003estats-\u003esegments_abandoned, 1);\n\n\t// for all slices\n\tconst mi_slice_t* end;\n\tmi_slice_t* slice \u003d mi_slices_start_iterate(segment, \u0026end);\n\twhile (slice \u003c end) {\n\t\tmi_assert_internal(slice-\u003eslice_count \u003e 0);\n\t\tmi_assert_internal(slice-\u003eslice_offset \u003d\u003d 0);\n\t\tif (mi_slice_is_used(slice)) {\n\t\t\t// in use: reclaim the page in our heap\n\t\t\tmi_page_t* page \u003d mi_slice_to_page(slice);\n\t\t\tmi_assert_internal(page-\u003eis_committed);\n\t\t\tmi_assert_internal(mi_page_thread_free_flag(page) \u003d\u003d MI_NEVER_DELAYED_FREE);\n\t\t\tmi_assert_internal(mi_page_heap(page) \u003d\u003d NULL);\n\t\t\tmi_assert_internal(page-\u003enext \u003d\u003d NULL \u0026\u0026 page-\u003eprev \u003d\u003d NULL);\n\t\t\t_mi_stat_decrease(\u0026tld-\u003estats-\u003epages_abandoned, 1);\n\t\t\tsegment-\u003eabandoned--;\n\t\t\t// set the heap again and allow delayed free again\n\t\t\tmi_page_set_heap(page, heap);\n\t\t\t_mi_page_use_delayed_free(page, MI_USE_DELAYED_FREE,\n\t\t\t\ttrue); // override never (after heap is set)\n\t\t\t_mi_page_free_collect(page, false); // ensure used count is up to date\n\t\t\tif (mi_page_all_free(page)) {\n\t\t\t\t// if everything free by now, free the page\n\t\t\t\tslice \u003d mi_segment_page_clear(page, tld); // set slice again due to coalesceing\n\t\t\t} else {\n\t\t\t\t// otherwise reclaim it into the heap\n\t\t\t\t_mi_page_reclaim(heap, page);\n\t\t\t\tif (requested_block_size \u003d\u003d page-\u003exblock_size \u0026\u0026 mi_page_has_any_available(page)) {\n\t\t\t\t\tif (right_page_reclaimed !\u003d NULL)\n\t\t\t\t\t\t*right_page_reclaimed \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// the span is free, add it to our page queues\n\t\t\tslice \u003d mi_segment_span_free_coalesce(slice, tld); // set slice again due to coalesceing\n\t\t}\n\t\tmi_assert_internal(slice-\u003eslice_count \u003e 0 \u0026\u0026 slice-\u003eslice_offset \u003d\u003d 0);\n\t\tslice \u003d slice + slice-\u003eslice_count;\n\t}\n\n\tmi_assert(segment-\u003eabandoned \u003d\u003d 0);\n\tif (segment-\u003eused \u003d\u003d 0) { // due to page_clear\n\t\tmi_assert_internal(right_page_reclaimed \u003d\u003d NULL || !(*right_page_reclaimed));\n\t\tmi_segment_free(segment, false, tld);\n\t\treturn NULL;\n\t} else {\n\t\treturn segment;\n\t}\n}\n\n\nvoid\n_mi_abandoned_reclaim_all(mi_heap_t* heap, mi_segments_tld_t* tld)\n{\n\tmi_segment_t* segment;\n\twhile ((segment \u003d mi_abandoned_pop()) !\u003d NULL)\n\t\tmi_segment_reclaim(segment, heap, 0, NULL, tld);\n}\n\n\nstatic mi_segment_t*\nmi_segment_try_reclaim(mi_heap_t* heap, size_t needed_slices, size_t block_size, bool* reclaimed,\n\tmi_segments_tld_t* tld)\n{\n\t*reclaimed \u003d false;\n\tmi_segment_t* segment;\n\tlong max_tries \u003d mi_option_get_clamp(mi_option_max_segment_reclaim, 8,\n\t\t1024); // limit the work to bound allocation times\n\twhile ((max_tries-- \u003e 0) \u0026\u0026 ((segment \u003d mi_abandoned_pop()) !\u003d NULL)) {\n\t\tsegment-\u003eabandoned_visits++;\n\t\t// todo: an arena exclusive heap will potentially visit many abandoned unsuitable segments\n\t\t// and push them into the visited list and use many tries. Perhaps we can skip non-suitable\n\t\t// ones in a better way?\n\t\tbool is_suitable \u003d _mi_heap_memid_is_suitable(heap, segment-\u003ememid);\n\t\tbool has_page \u003d mi_segment_check_free(segment, needed_slices, block_size,\n\t\t\ttld); // try to free up pages (due to concurrent frees)\n\t\tif (segment-\u003eused \u003d\u003d 0) {\n\t\t\t// free the segment (by forced reclaim) to make it available to other threads.\n\t\t\t// note1: we prefer to free a segment as that might lead to reclaiming another\n\t\t\t// segment that is still partially used.\n\t\t\t// note2: we could in principle optimize this by skipping reclaim and directly\n\t\t\t// freeing but that would violate some invariants temporarily)\n\t\t\tmi_segment_reclaim(segment, heap, 0, NULL, tld);\n\t\t} else if (has_page \u0026\u0026 is_suitable) {\n\t\t\t// found a large enough free span, or a page of the right block_size with free space\n\t\t\t// we return the result of reclaim (which is usually `segment`) as it might free\n\t\t\t// the segment due to concurrent frees (in which case `NULL` is returned).\n\t\t\treturn mi_segment_reclaim(segment, heap, block_size, reclaimed, tld);\n\t\t} else if (segment-\u003eabandoned_visits \u003e 3 \u0026\u0026 is_suitable) {\n\t\t\t// always reclaim on 3rd visit to limit the abandoned queue length.\n\t\t\tmi_segment_reclaim(segment, heap, 0, NULL, tld);\n\t\t} else {\n\t\t\t// otherwise, push on the visited list so it gets not looked at too quickly again\n\t\t\tmi_segment_try_purge(segment, true /* force? */,\n\t\t\t\ttld-\u003estats); // force purge if needed as we may not visit soon again\n\t\t\tmi_abandoned_visited_push(segment);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nvoid\n_mi_abandoned_collect(mi_heap_t* heap, bool force, mi_segments_tld_t* tld)\n{\n\tmi_segment_t* segment;\n\tint max_tries \u003d (force ? 16 * 1024 : 1024); // limit latency\n\tif (force)\n\t\tmi_abandoned_visited_revisit();\n\twhile ((max_tries-- \u003e 0) \u0026\u0026 ((segment \u003d mi_abandoned_pop()) !\u003d NULL)) {\n\t\tmi_segment_check_free(segment, 0, 0, tld); // try to free up pages (due to concurrent frees)\n\t\tif (segment-\u003eused \u003d\u003d 0) {\n\t\t\t// free the segment (by forced reclaim) to make it available to other threads.\n\t\t\t// note: we could in principle optimize this by skipping reclaim and directly\n\t\t\t// freeing but that would violate some invariants temporarily)\n\t\t\tmi_segment_reclaim(segment, heap, 0, NULL, tld);\n\t\t} else {\n\t\t\t// otherwise, purge if needed and push on the visited list\n\t\t\t// note: forced purge can be expensive if many threads are destroyed/created as in\n\t\t\t// mstress.\n\t\t\tmi_segment_try_purge(segment, force, tld-\u003estats);\n\t\t\tmi_abandoned_visited_push(segment);\n\t\t}\n\t}\n```",
      "range": {
        "startLine": 1319,
        "startChar": 0,
        "endLine": 1449,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b92d7a7_58cc1f1b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1474,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_segment_t*\nmi_segment_reclaim_or_alloc(mi_heap_t* heap, size_t needed_slices, size_t block_size,\n\tmi_segments_tld_t* tld, mi_os_tld_t* os_tld)\n{\n\tmi_assert_internal(block_size \u003c MI_HUGE_BLOCK_SIZE);\n\tmi_assert_internal(block_size \u003c\u003d MI_LARGE_OBJ_SIZE_MAX);\n\n\t// 1. try to reclaim an abandoned segment\n\tbool reclaimed;\n\tmi_segment_t* segment\n\t\t\u003d mi_segment_try_reclaim(heap, needed_slices, block_size, \u0026reclaimed, tld);\n\tif (reclaimed) {\n\t\t// reclaimed the right page right into the heap\n\t\tmi_assert_internal(segment !\u003d NULL);\n\t\treturn NULL; // pretend out-of-memory as the page will be in the page queue of the heap with\n\t\t\t\t\t // available blocks\n\t} else if (segment !\u003d NULL) {\n\t\t// reclaimed a segment with a large enough empty span in it\n\t\treturn segment;\n\t}\n\t// 2. otherwise allocate a fresh segment\n\treturn mi_segment_alloc(0, 0, heap-\u003earena_id, tld, os_tld, NULL);\n```",
      "range": {
        "startLine": 1456,
        "startChar": 0,
        "endLine": 1474,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "58272acd_4c93a72a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1507,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_segments_page_alloc(mi_heap_t* heap, mi_page_kind_t page_kind, size_t required,\n\tsize_t block_size, mi_segments_tld_t* tld, mi_os_tld_t* os_tld)\n{\n\tmi_assert_internal(required \u003c\u003d MI_LARGE_OBJ_SIZE_MAX \u0026\u0026 page_kind \u003c\u003d MI_PAGE_LARGE);\n\n\t// find a free page\n\tsize_t page_size \u003d _mi_align_up(required,\n\t\t(required \u003e MI_MEDIUM_PAGE_SIZE ? MI_MEDIUM_PAGE_SIZE : MI_SEGMENT_SLICE_SIZE));\n\tsize_t slices_needed \u003d page_size / MI_SEGMENT_SLICE_SIZE;\n\tmi_assert_internal(slices_needed * MI_SEGMENT_SLICE_SIZE \u003d\u003d page_size);\n\tmi_page_t* page \u003d mi_segments_page_find_and_allocate(slices_needed, heap-\u003earena_id,\n\t\ttld); //(required \u003c\u003d MI_SMALL_SIZE_MAX ? 0 : slices_needed), tld);\n\tif (page \u003d\u003d NULL) {\n\t\t// no free page, allocate a new segment and try again\n\t\tif (mi_segment_reclaim_or_alloc(heap, slices_needed, block_size, tld, os_tld) \u003d\u003d NULL) {\n\t\t\t// OOM or reclaimed a good page in the heap\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t// otherwise try again\n\t\t\treturn mi_segments_page_alloc(heap, page_kind, required, block_size, tld, os_tld);\n\t\t}\n\t}\n\tmi_assert_internal(page !\u003d NULL \u0026\u0026 page-\u003eslice_count * MI_SEGMENT_SLICE_SIZE \u003d\u003d page_size);\n\tmi_assert_internal(_mi_ptr_segment(page)-\u003ethread_id \u003d\u003d _mi_thread_id());\n\tmi_segment_try_purge(_mi_ptr_segment(page), false, tld-\u003estats);\n\treturn page;\n}\n```",
      "range": {
        "startLine": 1482,
        "startChar": 0,
        "endLine": 1507,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e65992be_6f904613",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1541,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic mi_page_t*\nmi_segment_huge_page_alloc(size_t size, size_t page_alignment, mi_arena_id_t req_arena_id,\n\tmi_segments_tld_t* tld, mi_os_tld_t* os_tld)\n{\n\tmi_page_t* page \u003d NULL;\n\tmi_segment_t* segment\n\t\t\u003d mi_segment_alloc(size, page_alignment, req_arena_id, tld, os_tld, \u0026page);\n\tif (segment \u003d\u003d NULL || page \u003d\u003d NULL)\n\t\treturn NULL;\n\tmi_assert_internal(segment-\u003eused \u003d\u003d 1);\n\tmi_assert_internal(mi_page_block_size(page) \u003e\u003d size);\n#if MI_HUGE_PAGE_ABANDON\n\tsegment-\u003ethread_id \u003d 0; // huge segments are immediately abandoned\n#endif\n\n\t// for huge pages we initialize the xblock_size as we may\n\t// overallocate to accommodate large alignments.\n\tsize_t psize;\n\tuint8_t* start \u003d _mi_segment_page_start(segment, page, \u0026psize);\n\tpage-\u003exblock_size \u003d (psize \u003e MI_HUGE_BLOCK_SIZE ? MI_HUGE_BLOCK_SIZE : (uint32_t)psize);\n\n\t// decommit the part of the prefix of a page that will not be used; this can be quite large\n\t// (close to MI_SEGMENT_SIZE)\n\tif (page_alignment \u003e 0 \u0026\u0026 segment-\u003eallow_decommit) {\n\t\tuint8_t* aligned_p \u003d (uint8_t*)_mi_align_up((uintptr_t)start, page_alignment);\n\t\tmi_assert_internal(_mi_is_aligned(aligned_p, page_alignment));\n\t\tmi_assert_internal(psize - (aligned_p - start) \u003e\u003d size);\n\t\tuint8_t* decommit_start \u003d start + sizeof(mi_block_t); // for the free list\n\t\tptrdiff_t decommit_size \u003d aligned_p - decommit_start;\n\t\t_mi_os_reset(decommit_start, decommit_size,\n\t\t\t\u0026_mi_stats_main); // note: cannot use segment_decommit on huge segments\n\t}\n\n\treturn page;\n```",
      "range": {
        "startLine": 1514,
        "startChar": 0,
        "endLine": 1541,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "03511b8d_25c4fe04",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1568,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_segment_huge_page_free(mi_segment_t* segment, mi_page_t* page, mi_block_t* block)\n{\n\t// huge page segments are always abandoned and can be freed immediately by any thread\n\tmi_assert_internal(segment-\u003ekind \u003d\u003d MI_SEGMENT_HUGE);\n\tmi_assert_internal(segment \u003d\u003d _mi_page_segment(page));\n\tmi_assert_internal(mi_atomic_load_relaxed(\u0026segment-\u003ethread_id) \u003d\u003d 0);\n\n\t// claim it and free\n\tmi_heap_t* heap \u003d mi_heap_get_default(); // issue #221; don\u0027t use the internal get_default_heap\n\t\t\t\t\t\t\t\t\t\t\t // as we need to ensure the thread is initialized.\n\t// paranoia: if this it the last reference, the cas should always succeed\n\tsize_t expected_tid \u003d 0;\n\tif (mi_atomic_cas_strong_acq_rel(\u0026segment-\u003ethread_id, \u0026expected_tid, heap-\u003ethread_id)) {\n\t\tmi_block_set_next(page, block, page-\u003efree);\n\t\tpage-\u003efree \u003d block;\n\t\tpage-\u003eused--;\n\t\tpage-\u003eis_zero \u003d false;\n\t\tmi_assert(page-\u003eused \u003d\u003d 0);\n\t\tmi_tld_t* tld \u003d heap-\u003etld;\n\t\t_mi_segment_page_free(page, true, \u0026tld-\u003esegments);\n\t}\n#if (MI_DEBUG !\u003d 0)\n\telse {\n\t\tmi_assert_internal(false);\n\t}\n```",
      "range": {
        "startLine": 1546,
        "startChar": 0,
        "endLine": 1568,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "10a2ec30_2749b0e5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1587,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nvoid\n_mi_segment_huge_page_reset(mi_segment_t* segment, mi_page_t* page, mi_block_t* block)\n{\n\tMI_UNUSED(page);\n\tmi_assert_internal(segment-\u003ekind \u003d\u003d MI_SEGMENT_HUGE);\n\tmi_assert_internal(segment \u003d\u003d _mi_page_segment(page));\n\tmi_assert_internal(page-\u003eused \u003d\u003d 1); // this is called just before the free\n\tmi_assert_internal(page-\u003efree \u003d\u003d NULL);\n\tif (segment-\u003eallow_decommit) {\n\t\tsize_t csize \u003d mi_usable_size(block);\n\t\tif (csize \u003e sizeof(mi_block_t)) {\n\t\t\tcsize \u003d csize - sizeof(mi_block_t);\n\t\t\tuint8_t* p \u003d (uint8_t*)block + sizeof(mi_block_t);\n\t\t\t_mi_os_reset(p, csize,\n\t\t\t\t\u0026_mi_stats_main); // note: cannot use segment_decommit on huge segments\n\t\t}\n\t}\n```",
      "range": {
        "startLine": 1574,
        "startChar": 0,
        "endLine": 1587,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "746a9da6_a5ebd44c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/segment.c",
        "patchSetId": 7
      },
      "lineNbr": 1619,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_page_t*\n_mi_segment_page_alloc(mi_heap_t* heap, size_t block_size, size_t page_alignment,\n\tmi_segments_tld_t* tld, mi_os_tld_t* os_tld)\n{\n\tmi_page_t* page;\n\tif mi_unlikely (page_alignment \u003e MI_ALIGNMENT_MAX) {\n\t\tmi_assert_internal(_mi_is_power_of_two(page_alignment));\n\t\tmi_assert_internal(page_alignment \u003e\u003d MI_SEGMENT_SIZE);\n\t\tif (page_alignment \u003c MI_SEGMENT_SIZE)\n\t\t\tpage_alignment \u003d MI_SEGMENT_SIZE;\n\t\tpage \u003d mi_segment_huge_page_alloc(block_size, page_alignment, heap-\u003earena_id, tld, os_tld);\n\t} else if (block_size \u003c\u003d MI_SMALL_OBJ_SIZE_MAX) {\n\t\tpage \u003d mi_segments_page_alloc(heap, MI_PAGE_SMALL, block_size, block_size, tld, os_tld);\n\t} else if (block_size \u003c\u003d MI_MEDIUM_OBJ_SIZE_MAX) {\n\t\tpage \u003d mi_segments_page_alloc(heap, MI_PAGE_MEDIUM, MI_MEDIUM_PAGE_SIZE, block_size, tld,\n\t\t\tos_tld);\n\t} else if (block_size \u003c\u003d MI_LARGE_OBJ_SIZE_MAX) {\n\t\tpage \u003d mi_segments_page_alloc(heap, MI_PAGE_LARGE, block_size, block_size, tld, os_tld);\n\t} else {\n\t\tpage \u003d mi_segment_huge_page_alloc(block_size, page_alignment, heap-\u003earena_id, tld, os_tld);\n\t}\n\tmi_assert_internal(\n\t\tpage \u003d\u003d NULL || _mi_heap_memid_is_suitable(heap, _mi_page_segment(page)-\u003ememid));\n\tmi_assert_expensive(page \u003d\u003d NULL || mi_segment_is_valid(_mi_page_segment(page), tld));\n\treturn page;\n}\n```",
      "range": {
        "startLine": 1594,
        "startChar": 0,
        "endLine": 1619,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e83bca51_c961cceb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/static.c",
        "patchSetId": 7
      },
      "lineNbr": 23,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 23,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df403862_3aa9948e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/static.c",
        "patchSetId": 7
      },
      "lineNbr": 25,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"alloc.c\" // includes alloc-override.c\n```",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07f12dc2_b17e569d",
        "filename": "src/system/libroot/posix/malloc/mimalloc/static.c",
        "patchSetId": 7
      },
      "lineNbr": 33,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \"page.c\" // includes page-queue.c\n#include \"prim/prim.c\"\n#include \"random.c\"\n#include \"segment-map.c\"\n```",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08a0f942_43eafebb",
        "filename": "src/system/libroot/posix/malloc/mimalloc/static.c",
        "patchSetId": 7
      },
      "lineNbr": 35,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 35,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00e8916e_f075c21e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/static.c",
        "patchSetId": 7
      },
      "lineNbr": 37,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 37,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7ddce60a_4a91fb4b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 7,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \"mimalloc/atomic.h\"\n```",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "28c9aef2_7130667b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 9,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 9,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1657ca4b_32120793",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 12,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#include \u003cstdio.h\u003e // snprintf\n```",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "686d7f87_6c7d8941",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#pragma warning(disable : 4204) // non-constant aggregate initializer\n```",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d4b1aa57_5852276f",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 71,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic bool\nmi_is_in_main(void* stat)\n{\n\treturn (uint8_t*)stat \u003e\u003d (uint8_t*)\u0026_mi_stats_main\n\t\t\u0026\u0026 (uint8_t*)stat \u003c ((uint8_t*)\u0026_mi_stats_main + sizeof(mi_stats_t));\n}\n\n\nstatic void\nmi_stat_update(mi_stat_count_t* stat, int64_t amount)\n{\n\tif (amount \u003d\u003d 0)\n\t\treturn;\n\tif (mi_is_in_main(stat)) {\n\t\t// add atomically (for abandoned pages)\n\t\tint64_t current \u003d mi_atomic_addi64_relaxed(\u0026stat-\u003ecurrent, amount);\n\t\tmi_atomic_maxi64_relaxed(\u0026stat-\u003epeak, current + amount);\n\t\tif (amount \u003e 0)\n\t\t\tmi_atomic_addi64_relaxed(\u0026stat-\u003eallocated, amount);\n\t\telse\n\t\t\tmi_atomic_addi64_relaxed(\u0026stat-\u003efreed, -amount);\n\t} else {\n\t\t// add thread local\n\t\tstat-\u003ecurrent +\u003d amount;\n\t\tif (stat-\u003ecurrent \u003e stat-\u003epeak)\n\t\t\tstat-\u003epeak \u003d stat-\u003ecurrent;\n\t\tif (amount \u003e 0)\n\t\t\tstat-\u003eallocated +\u003d amount;\n\t\telse\n\t\t\tstat-\u003efreed +\u003d -amount;\n\t}\n}\n\n\nvoid\n_mi_stat_counter_increase(mi_stat_counter_t* stat, size_t amount)\n{\n\tif (mi_is_in_main(stat)) {\n\t\tmi_atomic_addi64_relaxed(\u0026stat-\u003ecount, 1);\n\t\tmi_atomic_addi64_relaxed(\u0026stat-\u003etotal, (int64_t)amount);\n\t} else {\n\t\tstat-\u003ecount++;\n\t\tstat-\u003etotal +\u003d amount;\n\t}\n}\n\n\nvoid\n_mi_stat_increase(mi_stat_count_t* stat, size_t amount)\n{\n\tmi_stat_update(stat, (int64_t)amount);\n}\n\n\nvoid\n_mi_stat_decrease(mi_stat_count_t* stat, size_t amount)\n{\n\tmi_stat_update(stat, -((int64_t)amount));\n```",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 71,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e9de463_82b7ac3c",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 88,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_stat_add(mi_stat_count_t* stat, const mi_stat_count_t* src, int64_t unit)\n{\n\tif (stat \u003d\u003d src)\n\t\treturn;\n\tif (src-\u003eallocated \u003d\u003d 0 \u0026\u0026 src-\u003efreed \u003d\u003d 0)\n\t\treturn;\n\tmi_atomic_addi64_relaxed(\u0026stat-\u003eallocated, src-\u003eallocated * unit);\n\tmi_atomic_addi64_relaxed(\u0026stat-\u003ecurrent, src-\u003ecurrent * unit);\n\tmi_atomic_addi64_relaxed(\u0026stat-\u003efreed, src-\u003efreed * unit);\n\t// peak scores do not work across threads..\n\tmi_atomic_addi64_relaxed(\u0026stat-\u003epeak, src-\u003epeak * unit);\n}\n\n\nstatic void\nmi_stat_counter_add(mi_stat_counter_t* stat, const mi_stat_counter_t* src, int64_t unit)\n{\n\tif (stat \u003d\u003d src)\n\t\treturn;\n\tmi_atomic_addi64_relaxed(\u0026stat-\u003etotal, src-\u003etotal * unit);\n\tmi_atomic_addi64_relaxed(\u0026stat-\u003ecount, src-\u003ecount * unit);\n```",
      "range": {
        "startLine": 75,
        "startChar": 0,
        "endLine": 88,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89d07618_9a9ddfb3",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 128,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_stats_add(mi_stats_t* stats, const mi_stats_t* src)\n{\n\tif (stats \u003d\u003d src)\n\t\treturn;\n\tmi_stat_add(\u0026stats-\u003esegments, \u0026src-\u003esegments, 1);\n\tmi_stat_add(\u0026stats-\u003epages, \u0026src-\u003epages, 1);\n\tmi_stat_add(\u0026stats-\u003ereserved, \u0026src-\u003ereserved, 1);\n\tmi_stat_add(\u0026stats-\u003ecommitted, \u0026src-\u003ecommitted, 1);\n\tmi_stat_add(\u0026stats-\u003ereset, \u0026src-\u003ereset, 1);\n\tmi_stat_add(\u0026stats-\u003epurged, \u0026src-\u003epurged, 1);\n\tmi_stat_add(\u0026stats-\u003epage_committed, \u0026src-\u003epage_committed, 1);\n\n\tmi_stat_add(\u0026stats-\u003epages_abandoned, \u0026src-\u003epages_abandoned, 1);\n\tmi_stat_add(\u0026stats-\u003esegments_abandoned, \u0026src-\u003esegments_abandoned, 1);\n\tmi_stat_add(\u0026stats-\u003ethreads, \u0026src-\u003ethreads, 1);\n\n\tmi_stat_add(\u0026stats-\u003emalloc, \u0026src-\u003emalloc, 1);\n\tmi_stat_add(\u0026stats-\u003esegments_cache, \u0026src-\u003esegments_cache, 1);\n\tmi_stat_add(\u0026stats-\u003enormal, \u0026src-\u003enormal, 1);\n\tmi_stat_add(\u0026stats-\u003ehuge, \u0026src-\u003ehuge, 1);\n\tmi_stat_add(\u0026stats-\u003elarge, \u0026src-\u003elarge, 1);\n\n\tmi_stat_counter_add(\u0026stats-\u003epages_extended, \u0026src-\u003epages_extended, 1);\n\tmi_stat_counter_add(\u0026stats-\u003emmap_calls, \u0026src-\u003emmap_calls, 1);\n\tmi_stat_counter_add(\u0026stats-\u003ecommit_calls, \u0026src-\u003ecommit_calls, 1);\n\tmi_stat_counter_add(\u0026stats-\u003ereset_calls, \u0026src-\u003ereset_calls, 1);\n\tmi_stat_counter_add(\u0026stats-\u003epurge_calls, \u0026src-\u003epurge_calls, 1);\n\n\tmi_stat_counter_add(\u0026stats-\u003epage_no_retire, \u0026src-\u003epage_no_retire, 1);\n\tmi_stat_counter_add(\u0026stats-\u003esearches, \u0026src-\u003esearches, 1);\n\tmi_stat_counter_add(\u0026stats-\u003enormal_count, \u0026src-\u003enormal_count, 1);\n\tmi_stat_counter_add(\u0026stats-\u003ehuge_count, \u0026src-\u003ehuge_count, 1);\n\tmi_stat_counter_add(\u0026stats-\u003elarge_count, \u0026src-\u003elarge_count, 1);\n#if MI_STAT \u003e 1\n\tfor (size_t i \u003d 0; i \u003c\u003d MI_BIN_HUGE; i++) {\n\t\tif (src-\u003enormal_bins[i].allocated \u003e 0 || src-\u003enormal_bins[i].freed \u003e 0)\n\t\t\tmi_stat_add(\u0026stats-\u003enormal_bins[i], \u0026src-\u003enormal_bins[i], 1);\n\t}\n```",
      "range": {
        "startLine": 92,
        "startChar": 0,
        "endLine": 128,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf8fef1c_e94cc19a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 265,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\nmi_printf_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg, const char* fmt)\n{\n\tchar buf[32];\n\tbuf[0] \u003d 0;\n\tint len \u003d 32;\n\tconst char* suffix \u003d (unit \u003c\u003d 0 ? \" \" : \"B\");\n\tconst int64_t base \u003d (unit \u003d\u003d 0 ? 1000 : 1024);\n\tif (unit \u003e 0)\n\t\tn *\u003d unit;\n\n\tconst int64_t pos \u003d (n \u003c 0 ? -n : n);\n\tif (pos \u003c base) {\n\t\tif (n !\u003d 1 || suffix[0] !\u003d \u0027B\u0027) // skip printing 1 B for the unit column\n\t\t\tsnprintf(buf, len, \"%d   %-3s\", (int)n, (n \u003d\u003d 0 ? \"\" : suffix));\n\t} else {\n\t\tint64_t divider \u003d base;\n\t\tconst char* magnitude \u003d \"K\";\n\t\tif (pos \u003e\u003d divider * base) {\n\t\t\tdivider *\u003d base;\n\t\t\tmagnitude \u003d \"M\";\n\t\t}\n\t\tif (pos \u003e\u003d divider * base) {\n\t\t\tdivider *\u003d base;\n\t\t\tmagnitude \u003d \"G\";\n\t\t}\n\t\tconst int64_t tens \u003d (n / (divider / 10));\n\t\tconst long whole \u003d (long)(tens / 10);\n\t\tconst long frac1 \u003d (long)(tens % 10);\n\t\tchar unitdesc[8];\n\t\tsnprintf(unitdesc, 8, \"%s%s%s\", magnitude, (base \u003d\u003d 1024 ? \"i\" : \"\"), suffix);\n\t\tsnprintf(buf, len, \"%ld.%ld %-3s\", whole, (frac1 \u003c 0 ? -frac1 : frac1), unitdesc);\n\t}\n\t_mi_fprintf(out, arg, (fmt \u003d\u003d NULL ? \"%12s\" : fmt), buf);\n}\n\n\nstatic void\nmi_print_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg)\n{\n\tmi_printf_amount(n, unit, out, arg, NULL);\n}\n\n\nstatic void\nmi_print_count(int64_t n, int64_t unit, mi_output_fun* out, void* arg)\n{\n\tif (unit \u003d\u003d 1)\n\t\t_mi_fprintf(out, arg, \"%12s\", \" \");\n\telse\n\t\tmi_print_amount(n, 0, out, arg);\n}\n\n\nstatic void\nmi_stat_print_ex(const mi_stat_count_t* stat, const char* msg, int64_t unit, mi_output_fun* out,\n\tvoid* arg, const char* notok)\n{\n\t_mi_fprintf(out, arg, \"%10s:\", msg);\n\tif (unit \u003e 0) {\n\t\tmi_print_amount(stat-\u003epeak, unit, out, arg);\n\t\tmi_print_amount(stat-\u003eallocated, unit, out, arg);\n\t\tmi_print_amount(stat-\u003efreed, unit, out, arg);\n\t\tmi_print_amount(stat-\u003ecurrent, unit, out, arg);\n\t\tmi_print_amount(unit, 1, out, arg);\n\t\tmi_print_count(stat-\u003eallocated, unit, out, arg);\n\t\tif (stat-\u003eallocated \u003e stat-\u003efreed) {\n\t\t\t_mi_fprintf(out, arg, \"  \");\n\t\t\t_mi_fprintf(out, arg, (notok \u003d\u003d NULL ? \"not all freed\" : notok));\n\t\t\t_mi_fprintf(out, arg, \"\\n\");\n\t\t} else {\n\t\t\t_mi_fprintf(out, arg, \"  ok\\n\");\n\t\t}\n\t} else if (unit \u003c 0) {\n\t\tmi_print_amount(stat-\u003epeak, -1, out, arg);\n\t\tmi_print_amount(stat-\u003eallocated, -1, out, arg);\n\t\tmi_print_amount(stat-\u003efreed, -1, out, arg);\n\t\tmi_print_amount(stat-\u003ecurrent, -1, out, arg);\n\t\tif (unit \u003d\u003d -1) {\n\t\t\t_mi_fprintf(out, arg, \"%24s\", \"\");\n\t\t} else {\n\t\t\tmi_print_amount(-unit, 1, out, arg);\n\t\t\tmi_print_count((stat-\u003eallocated / -unit), 0, out, arg);\n\t\t}\n\t\tif (stat-\u003eallocated \u003e stat-\u003efreed)\n\t\t\t_mi_fprintf(out, arg, \"  not all freed!\\n\");\n\t\telse\n\t\t\t_mi_fprintf(out, arg, \"  ok\\n\");\n\t} else {\n\t\tmi_print_amount(stat-\u003epeak, 1, out, arg);\n\t\tmi_print_amount(stat-\u003eallocated, 1, out, arg);\n\t\t_mi_fprintf(out, arg, \"%11s\", \" \"); // no freed\n\t\tmi_print_amount(stat-\u003ecurrent, 1, out, arg);\n\t\t_mi_fprintf(out, arg, \"\\n\");\n\t}\n}\n\n\nstatic void\nmi_stat_print(const mi_stat_count_t* stat, const char* msg, int64_t unit, mi_output_fun* out,\n\tvoid* arg)\n{\n\tmi_stat_print_ex(stat, msg, unit, out, arg, NULL);\n}\n\n\nstatic void\nmi_stat_peak_print(const mi_stat_count_t* stat, const char* msg, int64_t unit, mi_output_fun* out,\n\tvoid* arg)\n{\n\t_mi_fprintf(out, arg, \"%10s:\", msg);\n\tmi_print_amount(stat-\u003epeak, unit, out, arg);\n\t_mi_fprintf(out, arg, \"\\n\");\n}\n\n\nstatic void\nmi_stat_counter_print(const mi_stat_counter_t* stat, const char* msg, mi_output_fun* out, void* arg)\n{\n\t_mi_fprintf(out, arg, \"%10s:\", msg);\n\tmi_print_amount(stat-\u003etotal, -1, out, arg);\n\t_mi_fprintf(out, arg, \"\\n\");\n}\n\n\nstatic void\nmi_stat_counter_print_avg(const mi_stat_counter_t* stat, const char* msg, mi_output_fun* out,\n\tvoid* arg)\n{\n\tconst int64_t avg_tens \u003d (stat-\u003ecount \u003d\u003d 0 ? 0 : (stat-\u003etotal * 10 / stat-\u003ecount));\n\tconst long avg_whole \u003d (long)(avg_tens / 10);\n\tconst long avg_frac1 \u003d (long)(avg_tens % 10);\n\t_mi_fprintf(out, arg, \"%10s: %5ld.%ld avg\\n\", msg, avg_whole, avg_frac1);\n}\n\n\nstatic void\nmi_print_header(mi_output_fun* out, void* arg)\n{\n\t_mi_fprintf(out, arg, \"%10s: %11s %11s %11s %11s %11s %11s\\n\", \"heap stats\", \"peak   \",\n\t\t\"total   \", \"freed   \", \"current   \", \"unit   \", \"count   \");\n}\n\n#if MI_STAT \u003e 1\n\n\nstatic void\nmi_stats_print_bins(const mi_stat_count_t* bins, size_t max, const char* fmt, mi_output_fun* out,\n\tvoid* arg)\n{\n\tbool found \u003d false;\n\tchar buf[64];\n\tfor (size_t i \u003d 0; i \u003c\u003d max; i++) {\n\t\tif (bins[i].allocated \u003e 0) {\n\t\t\tfound \u003d true;\n\t\t\tint64_t unit \u003d _mi_bin_size((uint8_t)i);\n\t\t\tsnprintf(buf, 64, \"%s %3lu\", fmt, (long)i);\n\t\t\tmi_stat_print(\u0026bins[i], buf, unit, out, arg);\n\t\t}\n\t}\n\tif (found) {\n\t\t_mi_fprintf(out, arg, \"\\n\");\n\t\tmi_print_header(out, arg);\n\t}\n```",
      "range": {
        "startLine": 139,
        "startChar": 0,
        "endLine": 265,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a7ac923_da0166e4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 268,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 268,
        "startChar": 0,
        "endLine": 268,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fbb2904_cf901073",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 280,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tmi_output_fun* out; // original output function\n\tvoid* arg; // and state\n\tchar* buf; // local buffer of at least size `count+1`\n\tsize_t used; // currently used chars `used \u003c\u003d count`\n\tsize_t count; // total chars available for output\n```",
      "range": {
        "startLine": 276,
        "startChar": 0,
        "endLine": 280,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "94c4730b_d9c50974",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 298,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic void\nmi_buffered_flush(buffered_t* buf)\n{\n\tbuf-\u003ebuf[buf-\u003eused] \u003d 0;\n\t_mi_fputs(buf-\u003eout, buf-\u003earg, NULL, buf-\u003ebuf);\n\tbuf-\u003eused \u003d 0;\n}\n\n\nstatic void mi_cdecl\nmi_buffered_out(const char* msg, void* arg)\n{\n\tbuffered_t* buf \u003d (buffered_t*)arg;\n\tif (msg \u003d\u003d NULL || buf \u003d\u003d NULL)\n\t\treturn;\n\tfor (const char* src \u003d msg; *src !\u003d 0; src++) {\n\t\tchar c \u003d *src;\n\t\tif (buf-\u003eused \u003e\u003d buf-\u003ecount)\n\t\t\tmi_buffered_flush(buf);\n\t\tmi_assert_internal(buf-\u003eused \u003c buf-\u003ecount);\n\t\tbuf-\u003ebuf[buf-\u003eused++] \u003d c;\n\t\tif (c \u003d\u003d \u0027\\n\u0027)\n\t\t\tmi_buffered_flush(buf);\n\t}\n```",
      "range": {
        "startLine": 283,
        "startChar": 0,
        "endLine": 298,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0adb6cc5_d552d05a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 369,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic void\n_mi_stats_print(mi_stats_t* stats, mi_output_fun* out0, void* arg0) mi_attr_noexcept\n{\n\t// wrap the output function to be line buffered\n\tchar buf[256];\n\tbuffered_t buffer \u003d {out0, arg0, NULL, 0, 255};\n\tbuffer.buf \u003d buf;\n\tmi_output_fun* out \u003d \u0026mi_buffered_out;\n\tvoid* arg \u003d \u0026buffer;\n\n\t// and print using that\n\tmi_print_header(out, arg);\n#if MI_STAT \u003e 1\n\tmi_stats_print_bins(stats-\u003enormal_bins, MI_BIN_HUGE, \"normal\", out, arg);\n#endif\n#if MI_STAT\n\tmi_stat_print(\u0026stats-\u003enormal, \"normal\",\n\t\t(stats-\u003enormal_count.count \u003d\u003d 0 ? 1\n\t\t\t\t\t\t\t\t\t\t: -(stats-\u003enormal.allocated / stats-\u003enormal_count.count)),\n\t\tout, arg);\n\tmi_stat_print(\u0026stats-\u003elarge, \"large\",\n\t\t(stats-\u003elarge_count.count \u003d\u003d 0 ? 1 : -(stats-\u003elarge.allocated / stats-\u003elarge_count.count)),\n\t\tout, arg);\n\tmi_stat_print(\u0026stats-\u003ehuge, \"huge\",\n\t\t(stats-\u003ehuge_count.count \u003d\u003d 0 ? 1 : -(stats-\u003ehuge.allocated / stats-\u003ehuge_count.count)),\n\t\tout, arg);\n\tmi_stat_count_t total \u003d {0, 0, 0, 0};\n\tmi_stat_add(\u0026total, \u0026stats-\u003enormal, 1);\n\tmi_stat_add(\u0026total, \u0026stats-\u003elarge, 1);\n\tmi_stat_add(\u0026total, \u0026stats-\u003ehuge, 1);\n\tmi_stat_print(\u0026total, \"total\", 1, out, arg);\n#endif\n#if MI_STAT \u003e 1\n\tmi_stat_print(\u0026stats-\u003emalloc, \"malloc req\", 1, out, arg);\n\t_mi_fprintf(out, arg, \"\\n\");\n#endif\n\tmi_stat_print_ex(\u0026stats-\u003ereserved, \"reserved\", 1, out, arg, \"\");\n\tmi_stat_print_ex(\u0026stats-\u003ecommitted, \"committed\", 1, out, arg, \"\");\n\tmi_stat_peak_print(\u0026stats-\u003ereset, \"reset\", 1, out, arg);\n\tmi_stat_peak_print(\u0026stats-\u003epurged, \"purged\", 1, out, arg);\n\tmi_stat_print(\u0026stats-\u003epage_committed, \"touched\", 1, out, arg);\n\tmi_stat_print(\u0026stats-\u003esegments, \"segments\", -1, out, arg);\n\tmi_stat_print(\u0026stats-\u003esegments_abandoned, \"-abandoned\", -1, out, arg);\n\tmi_stat_print(\u0026stats-\u003esegments_cache, \"-cached\", -1, out, arg);\n\tmi_stat_print(\u0026stats-\u003epages, \"pages\", -1, out, arg);\n\tmi_stat_print(\u0026stats-\u003epages_abandoned, \"-abandoned\", -1, out, arg);\n\tmi_stat_counter_print(\u0026stats-\u003epages_extended, \"-extended\", out, arg);\n\tmi_stat_counter_print(\u0026stats-\u003epage_no_retire, \"-noretire\", out, arg);\n\tmi_stat_counter_print(\u0026stats-\u003emmap_calls, \"mmaps\", out, arg);\n\tmi_stat_counter_print(\u0026stats-\u003ecommit_calls, \"commits\", out, arg);\n\tmi_stat_counter_print(\u0026stats-\u003ereset_calls, \"resets\", out, arg);\n\tmi_stat_counter_print(\u0026stats-\u003epurge_calls, \"purges\", out, arg);\n\tmi_stat_print(\u0026stats-\u003ethreads, \"threads\", -1, out, arg);\n\tmi_stat_counter_print_avg(\u0026stats-\u003esearches, \"searches\", out, arg);\n\t_mi_fprintf(out, arg, \"%10s: %5zu\\n\", \"numa nodes\", _mi_os_numa_node_count());\n\n\tsize_t elapsed;\n\tsize_t user_time;\n\tsize_t sys_time;\n\tsize_t current_rss;\n\tsize_t peak_rss;\n\tsize_t current_commit;\n\tsize_t peak_commit;\n\tsize_t page_faults;\n\tmi_process_info(\u0026elapsed, \u0026user_time, \u0026sys_time, \u0026current_rss, \u0026peak_rss, \u0026current_commit,\n\t\t\u0026peak_commit, \u0026page_faults);\n\t_mi_fprintf(out, arg, \"%10s: %5ld.%03ld s\\n\", \"elapsed\", elapsed / 1000, elapsed % 1000);\n\t_mi_fprintf(out, arg,\n\t\t\"%10s: user: %ld.%03ld s, system: %ld.%03ld s, faults: %lu, rss: \", \"process\",\n\t\tuser_time / 1000, user_time % 1000, sys_time / 1000, sys_time % 1000,\n\t\t(unsigned long)page_faults);\n\tmi_printf_amount((int64_t)peak_rss, 1, out, arg, \"%s\");\n\tif (peak_commit \u003e 0) {\n\t\t_mi_fprintf(out, arg, \", commit: \");\n\t\tmi_printf_amount((int64_t)peak_commit, 1, out, arg, \"%s\");\n\t}\n\t_mi_fprintf(out, arg, \"\\n\");\n```",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 369,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "115b6e0b_77d5a2d4",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 412,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nstatic mi_stats_t*\nmi_stats_get_default(void)\n{\n\tmi_heap_t* heap \u003d mi_heap_get_default();\n\treturn \u0026heap-\u003etld-\u003estats;\n}\n\n\nstatic void\nmi_stats_merge_from(mi_stats_t* stats)\n{\n\tif (stats !\u003d \u0026_mi_stats_main) {\n\t\tmi_stats_add(\u0026_mi_stats_main, stats);\n\t\tmemset(stats, 0, sizeof(mi_stats_t));\n\t}\n}\n\n\nvoid\nmi_stats_reset(void) mi_attr_noexcept\n{\n\tmi_stats_t* stats \u003d mi_stats_get_default();\n\tif (stats !\u003d \u0026_mi_stats_main)\n\t\tmemset(stats, 0, sizeof(mi_stats_t));\n\tmemset(\u0026_mi_stats_main, 0, sizeof(mi_stats_t));\n\tif (mi_process_start \u003d\u003d 0)\n\t\tmi_process_start \u003d _mi_clock_start();\n\t;\n}\n\n\nvoid\nmi_stats_merge(void) mi_attr_noexcept\n{\n\tmi_stats_merge_from(mi_stats_get_default());\n}\n\n\nvoid\n_mi_stats_done(mi_stats_t* stats)\n{ // called from `mi_thread_done`\n\tmi_stats_merge_from(stats);\n}\n\n\nvoid\nmi_stats_print_out(mi_output_fun* out, void* arg) mi_attr_noexcept\n{\n\tmi_stats_merge_from(mi_stats_get_default());\n\t_mi_stats_print(\u0026_mi_stats_main, out, arg);\n}\n\n\nvoid\nmi_stats_print(void* out) mi_attr_noexcept\n{\n\t// for compatibility there is an `out` parameter (which can be `stdout` or `stderr`)\n\tmi_stats_print_out((mi_output_fun*)out, NULL);\n}\n\n\nvoid\nmi_thread_stats_print_out(mi_output_fun* out, void* arg) mi_attr_noexcept\n{\n\t_mi_stats_print(mi_stats_get_default(), out, arg);\n```",
      "range": {
        "startLine": 374,
        "startChar": 0,
        "endLine": 412,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3cfc17fc_449a069e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 436,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\nmi_msecs_t\n_mi_clock_now(void)\n{\n\treturn _mi_prim_clock_now();\n}\n\n\nmi_msecs_t\n_mi_clock_start(void)\n{\n\tif (mi_clock_diff \u003d\u003d 0.0) {\n\t\tmi_msecs_t t0 \u003d _mi_clock_now();\n\t\tmi_clock_diff \u003d _mi_clock_now() - t0;\n\t}\n\treturn _mi_clock_now();\n}\n\n\nmi_msecs_t\n_mi_clock_end(mi_msecs_t start)\n{\n\tmi_msecs_t end \u003d _mi_clock_now();\n\treturn end - start - mi_clock_diff;\n```",
      "range": {
        "startLine": 422,
        "startChar": 0,
        "endLine": 436,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "319301fc_a760f25a",
        "filename": "src/system/libroot/posix/malloc/mimalloc/stats.c",
        "patchSetId": 7
      },
      "lineNbr": 467,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmi_decl_export void\nmi_process_info(size_t* elapsed_msecs, size_t* user_msecs, size_t* system_msecs,\n\tsize_t* current_rss, size_t* peak_rss, size_t* current_commit, size_t* peak_commit,\n\tsize_t* page_faults) mi_attr_noexcept\n{\n\tmi_process_info_t pinfo;\n\t_mi_memzero_var(pinfo);\n\tpinfo.elapsed \u003d _mi_clock_end(mi_process_start);\n\tpinfo.current_commit\n\t\t\u003d (size_t)(mi_atomic_loadi64_relaxed((_Atomic(int64_t)*)\u0026_mi_stats_main.committed.current));\n\tpinfo.peak_commit\n\t\t\u003d (size_t)(mi_atomic_loadi64_relaxed((_Atomic(int64_t)*)\u0026_mi_stats_main.committed.peak));\n\tpinfo.current_rss \u003d pinfo.current_commit;\n\tpinfo.peak_rss \u003d pinfo.peak_commit;\n\tpinfo.utime \u003d 0;\n\tpinfo.stime \u003d 0;\n\tpinfo.page_faults \u003d 0;\n\n\t_mi_prim_process_info(\u0026pinfo);\n\n\tif (elapsed_msecs !\u003d NULL) {\n\t\t*elapsed_msecs \u003d (pinfo.elapsed \u003c 0\n\t\t\t\t? 0\n\t\t\t\t: (pinfo.elapsed \u003c (mi_msecs_t)PTRDIFF_MAX ? (size_t)pinfo.elapsed : PTRDIFF_MAX));\n\t}\n\tif (user_msecs !\u003d NULL) {\n\t\t*user_msecs \u003d (pinfo.utime \u003c 0\n\t\t\t\t? 0\n\t\t\t\t: (pinfo.utime \u003c (mi_msecs_t)PTRDIFF_MAX ? (size_t)pinfo.utime : PTRDIFF_MAX));\n\t}\n\tif (system_msecs !\u003d NULL) {\n\t\t*system_msecs \u003d (pinfo.stime \u003c 0\n\t\t\t\t? 0\n\t\t\t\t: (pinfo.stime \u003c (mi_msecs_t)PTRDIFF_MAX ? (size_t)pinfo.stime : PTRDIFF_MAX));\n\t}\n\tif (current_rss !\u003d NULL)\n\t\t*current_rss \u003d pinfo.current_rss;\n\tif (peak_rss !\u003d NULL)\n\t\t*peak_rss \u003d pinfo.peak_rss;\n\tif (current_commit !\u003d NULL)\n\t\t*current_commit \u003d pinfo.current_commit;\n\tif (peak_commit !\u003d NULL)\n\t\t*peak_commit \u003d pinfo.peak_commit;\n\tif (page_faults !\u003d NULL)\n\t\t*page_faults \u003d pinfo.page_faults;\n}\n```",
      "range": {
        "startLine": 444,
        "startChar": 0,
        "endLine": 467,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2cfe53b_49e18952",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 5,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n#include \u003cOS.h\u003e\n```",
      "range": {
        "startLine": 5,
        "startChar": 0,
        "endLine": 5,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76009783_876cd932",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 7,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` is to remove this line/these lines.",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6adadc3e_a0072896",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 43,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\" void*\n```",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 43,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d16bb07_0ed731f0",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 50,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\" void*\n```",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c92fa31f_d5775909",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 58,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nfree(void* ptr)\n```",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 58,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "656faac2_83e860f5",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 64,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\" void*\n```",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 64,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "32a8fefd_1bbdd445",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 71,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\" void*\n```",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 71,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1f5e88b_b182ca34",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 83,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nposix_memalign(void** _pointer, size_t alignment, size_t size)\n```",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 83,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a2632282_c57e1b0b",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 89,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\" void*\n```",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 89,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff817ca1_74c5172e",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 97,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nextern \"C\" void*\nrealloc(void* ptr, size_t size)\n```",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 97,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4289d0d6_0ef260f1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 104,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nmalloc_usable_size(void* ptr)\n```",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 104,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f85a2210_db3ae5b1",
        "filename": "src/system/libroot/posix/malloc/mimalloc/wrapper.cpp",
        "patchSetId": 7
      },
      "lineNbr": 123,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-12-28T21:08:43Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (insert after):\n```c++\n\n```",
      "range": {
        "startLine": 123,
        "startChar": 0,
        "endLine": 123,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "7b1b6a049c832012bec3868618c0a3be0e19526b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}