{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d140e7a1_cdd5ac89",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-04-27T05:32:12Z",
      "side": 1,
      "message": "So, while trying to work on this patch so that it can be merged, a major shortcoming became apparent which I do not see any simple way of rectifying with the current setup.\n\nThat has to do with truncation of I/O requests. At present, API consumers of the \"io\" hook are held to a high standard: any requests they make are expected to be valid (i.e. fall entirely within the device/partition\u0027s bounds.) This is checked and enforced for partitions at higher layers, and for the devices themselves in various other ways. So, if I have a device of 2x512 blocks, and submit an IO request of a [0, 1024+1] read, it will be rejected.\n\nBut, if I submit it via the read/write hooks, on most drivers this will just truncate it to [0, 1024] and perform the request anyway. This is important, because most calls from userland go through the these hooks, including from programs like \"dd\".\n\nIORequest\u0027s length cannot be changed after it was created. It can only be partially filled, of course, but in the case where DMAResource or IOScheduler is used, informing these that the read/write can only partially be satisfied is not really possible.\n\nFor example, suppose I want to do a [0, 1024+1] write. Here is what happens at present:\n\n1. truncated to [0, 1024]\n2. IO hook called.\n3. Request is already aligned; no bouncing required, written as-is.\n4. Success.\n\nBut here is what will happen if the IORequest is created without first being truncated in write():\n\n1. IO hook called\n2. Request is not aligned. Round up to block size: write [0, 1024+512].\n3. Partial read needed, read 512 bytes starting at offset 1024. But that doesn\u0027t exist.\n4. Failure.\n\nWhen using \"dd\", this case is probably hit every single time when reaching the end of a device unless someone took great care to set an exactly correct length and block size when invoking dd. So, we absolutely must handle it correctly.\n\nI guess we could introduce some mechanism into IORequest to handle this case? Other than that, we could keep the disparate truncation behavior between read/write hooks and io hooks.",
      "revId": "f66f573605267d04b3ccb8e284d5f4a8ead76862",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a2aeeab_714caf32",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2023-04-27T09:15:36Z",
      "side": 1,
      "message": "This problem seems already present in drivers before this patch applied, it just move common code in multiple drivers.",
      "revId": "f66f573605267d04b3ccb8e284d5f4a8ead76862",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af03849c_955b0198",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-04-27T15:48:48Z",
      "side": 1,
      "message": "In some drivers, yes, but in other ones like nvme or mmc, it isn\u0027t.",
      "parentUuid": "0a2aeeab_714caf32",
      "revId": "f66f573605267d04b3ccb8e284d5f4a8ead76862",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "473304b5_aa10fb4f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-04-27T15:48:48Z",
      "side": 1,
      "message": "I suppose adding a TruncateLength() method to IORequest may be the best way to go here. We already support changing the IORequest\u0027s offset, and of course the returned TransferredBytes needs to already be checked by anything performing IO requests. Thoughts?",
      "parentUuid": "d140e7a1_cdd5ac89",
      "revId": "f66f573605267d04b3ccb8e284d5f4a8ead76862",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd40c768_c2c006d8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-04-27T16:40:10Z",
      "side": 1,
      "message": "In the eMMC driver, the difference is fully handled in the mmc_block_read and mmc_block_write functions which do bound checks to make sure the request is within device bounds. These checks can easily be moved into AbstractModuleDevice::Read and AbstractModuleDevice::Write, and then everything will be fine. Besides these checks and the wait for the request response, the implementation is identical to mmc_block_io.\n\nThe io_scheduler, associated with DMA constraints, will do the remaining part: handling partial reads and writes by doing full sector reads and writes as needed. The DMA constraints are configured so that the io_scheduler can never submit to the device a request that\u0027s not starting and ending at sector boundaries.\n\nI see this is not the case in other devices, it seems they accept requests without any preprocessing and figure out the alignment problems when the request is scheduled? Apparently I abused the DMA constraints to convince the io_scheduler to do that work for me in mmc_disk.\n\nBut in any case, moving the bound checks as done in mmc_block_read and _write to AbstractModuleDevice should solve your problem. However, that means AbstractModuleDevice has to know the device block count to perform the check.",
      "parentUuid": "473304b5_aa10fb4f",
      "revId": "f66f573605267d04b3ccb8e284d5f4a8ead76862",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58ca55ed_ef39fd82",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-04-27T16:42:23Z",
      "side": 1,
      "message": "Alignment being handled by DMA constraints is the normal way to do things when using the I/O scheduler, I think. The nvme_disk driver is special because it uses DMAResource but not IOScheduler, so we try to bypass DMAResource if the request is already aligned.\n\nYes, AbstractModuleDevice will then have to know the device block count. But then we are still inconsistent between the read/write hooks and the IO hook. Is that fine? Or should we instead have the IO hook adjust the request length?",
      "parentUuid": "cd40c768_c2c006d8",
      "revId": "f66f573605267d04b3ccb8e284d5f4a8ead76862",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6debf794_075f7e6c",
        "filename": "src/system/kernel/device_manager/AbstractModuleDevice.cpp",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-04-26T03:49:45Z",
      "side": 1,
      "message": "This isn\u0027t correct. Instead we need to use: request.TransferredBytes(); and unconditionally on status (especially if partial read/write is set.)\n\nI think with that, we don\u0027t need these prints. I also see that the nvme_disk driver could then take advantage of this same code.",
      "revId": "f66f573605267d04b3ccb8e284d5f4a8ead76862",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}