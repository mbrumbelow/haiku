{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "597ad110_153b6c89",
        "filename": "src/add-ons/kernel/drivers/display/display_adapter.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2022-07-15T18:02:36Z",
      "side": 1,
      "message": "It was a long time ago I wrote this, so I might not recall the code correctly. I think old code should only show attaced devices. If we skip don\u0027t we just show every possible combination in ACPI, like TV\u0027s even on computers that don\u0027t support tv\u0027s? And on your computer do you have several graphics cards? \nI get the feeling you are looking under gfx card A, but only gfx card B has displays attached?\nIt is easy to check the ACPI tree by opening the acpi/namespace  file. Most likely only internal displays have DOS and DOD and such.",
      "revId": "4e23da664b9012f02dcada4e642ab6f058e7560b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c741cef6_27e92913",
        "filename": "src/add-ons/kernel/drivers/display/display_adapter.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-04-13T17:53:50Z",
      "side": 1,
      "message": "I have only one graphics card, but I have several nodes exposed under it (DD01, until DD0F, and then DD1F and DD2F). Only one is actually \"working\" (in the sense that I can read and set a value): DD2F.\n\nBut, as noted in my comment, the _ADR value do not match. The first devices have addresses 1 to 15, the last two both have address 31 in the _ADR field.\n\nThere seem to be only one entry in the _DOD, and the display ID (from the log before in this function) says:\n\n\"Display ID \u003d Type 1, Value 65536\"\n\nThat is the correct type (ACPI_TYPE_INTEGER), but the value does not match any of the addresses. So, either something is wrong with my BIOS (very possible), or something is wrong with this code. But disabling this temporarily allows me to test what happens in other parts of the driver. Of course it should be re-enabled in some way when we understand why it doesn\u0027t work.\n\nI do not yet fully understand ACPI, and I am wondering for example if we could be using the wrong structure definition for the reply to _DOD (since we define equivaents of ACPICA structures, and there are no compiler checks for casting into the correct ones, or there could be alignment and padding issues, etc). But maybe it\u0027s some other problem altogether.",
      "parentUuid": "597ad110_153b6c89",
      "revId": "4e23da664b9012f02dcada4e642ab6f058e7560b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a3ecd47_5b38b3f5",
        "filename": "src/add-ons/kernel/drivers/display/display_adapter.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2024-04-14T17:36:23Z",
      "side": 1,
      "message": "This might come out a bit rambling, but I thought it is better to share, and I don\u0027t have enough time atm to write it better..\n\nI think reading the ACPI_Spec_6_5_Aug29 B section would help. It explains a lot of the setup for displays. \nFor _DOD: \"This method is used to enumerate devices attached to the display adapter. This method is required if integrated\ncontroller supports output switching.\"\n\n\"\nReturn Value:\nA Package containing a variable-length list of Integers, each of which contains the 32-bit device attribute\nof a child device\n\"\n\nAnd for _ADR: \"\nThis method returns a unique ID representing the display output device. All output devices must have a unique\nhardware ID. This method is required for all The IDs returned by this method will appear in the list of hardware IDs\nreturned by the _DOD method.\n\"\n\"\nReturn Value:\nAn Integer containing the device ID (32 bits)\n\"\n\nTo me it looks like _DOD and _ADR integers should be compared 32bit, as Device ID\u0027s are listed as 32 bit examples (see Table B-3, and if we trim 16 bit, the uniqueness they write about will be lost). The internal \"device id\" seems to be named in a confusing way. The upper parts to identify if it is multihead, and the bit for non-vga device, otherwise multihead id 0, non-vga id 0 and vga id 0 will have same id 0. However, note that bit 31:\n\"\nDevice ID Scheme:\n1 - Uses the bit-field definitions above (bits 15:0)\n0 - Other scheme, contact the Video Chip Vendor\n\"\nSo maybe it is just a problem with the highest bit being one...\n\nI am confused about the switch to evaluate_method, as evaluate_object is the  way that ACPICA calls things and enumeration worked fine on my machine. I can\u0027t recall where evaluate_method is used, it might not do what you think it does? \npkgData and buffer juggling also seems more complicated to me. I think you need to give ACPI its memory back, not free it. I might remember wrong, I am very rusty.\n\nSee AcpiEvaluateObject in ACPICA User Guide and Programmer Reference here: https://www.intel.com/content/www/us/en/developer/topic-technology/open/acpica/documentation.html\n\nI don\u0027t think your machine has bad firmware, if it has a _DOD it probably does the right thing, the best would probably be to dump the values and figure out the mapping. Not sure why your machine does not work with the old code for enumerating. It worked on a now very old intel Asus laptop at least.",
      "parentUuid": "c741cef6_27e92913",
      "revId": "4e23da664b9012f02dcada4e642ab6f058e7560b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf7ee157_e645a52b",
        "filename": "src/add-ons/kernel/drivers/display/display_adapter.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-03T16:49:00Z",
      "side": 1,
      "message": "Thanks for your reply.\n\nI think I switched from evaluate_object to evaluate_method to benefit from the automatic allocation of the buffer with the right size instead of hardcoding it to 128 bytes. I switched it back, it appears to make no difference.\n\nComplete syslog: https://pulkomandy.tk/drop/syslog_test_acpi_display.txt\n\n    KERN: displayadapter_support: found at bus: acpi path: \\_SB_.PC00.GFX0\n    KERN: publish device: node 0xffffffff832553c8, path display/display_adapter/0_control, module drivers/display/display_adapter/device_v1\n    KERN: Display ID \u003d Type 1, Value 65536\n    Last message repeated 1 time\n\nThe value is 65536, so bit 31 is 0, and I\u0027m in the \"contact the Video Chip Vendor\" case. But this shouldn\u0027t really matter, I think, the Device ID can be handled as an opaque 16 or 32 bit value and we don\u0027t need to decode its exact content.\n\nAnd then for the device enumeration:\n\n    KERN: name: DD01\n    KERN: Child _adr 1\n    KERN: display: child not found in displayIDs list.\n    KERN: path: \\_SB_.PC00.GFX0.DD01\n\nI get _adr values of 1, 2, 3, ..., 15 and then 31, 31.\n\nIn both cases, the logs show the full 32 bit values. The 16 low bits of _DOD are all 0, and none of the displays have these bits set to 0. So, even when comparing on 16 bits (which, if anything, would result in false positive, where we match things when we shouldn\u0027t), I\u0027m not going to get any match. As a result, on my machine, if I enable this code, no devices are published. This is why I had disabled it to test the other parts of the driver. Then, every available display, no matter if it is the active one or not, gets a published device and I can try to send commands to it.\n\nBut what is confusing is that the spec says this:\n\n\u003e Every child device enumerated in the ACPI namespace under the graphics adapter must be speciÔ¨Åed in this list of devices. Each display device must have its own ID, which is unique with respect to any other attachable devices enumerated.\n\nWhich they repeat again as you quoted in the description of _ADR:\n\n\u003e This method is required for all The IDs returned by this method will appear in the list of hardware IDs returned by the _DOD method.\n\nand in my case, this is not what I get. I get 17 child devices, but only 2 entries in _DOD. And these 2 entries both have the same values in them (in the log I pasted above this results in \"Last message repeated 1 time\"). So I assume there is something terribly wrong in the way the _DOD method result is parsed? Or is it just my machine not following the spec, or some other error?",
      "parentUuid": "3a3ecd47_5b38b3f5",
      "revId": "4e23da664b9012f02dcada4e642ab6f058e7560b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}