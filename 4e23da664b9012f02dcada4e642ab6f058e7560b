{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "597ad110_153b6c89",
        "filename": "src/add-ons/kernel/drivers/display/display_adapter.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2022-07-15T18:02:36Z",
      "side": 1,
      "message": "It was a long time ago I wrote this, so I might not recall the code correctly. I think old code should only show attaced devices. If we skip don\u0027t we just show every possible combination in ACPI, like TV\u0027s even on computers that don\u0027t support tv\u0027s? And on your computer do you have several graphics cards? \nI get the feeling you are looking under gfx card A, but only gfx card B has displays attached?\nIt is easy to check the ACPI tree by opening the acpi/namespace  file. Most likely only internal displays have DOS and DOD and such.",
      "revId": "4e23da664b9012f02dcada4e642ab6f058e7560b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c741cef6_27e92913",
        "filename": "src/add-ons/kernel/drivers/display/display_adapter.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-04-13T17:53:50Z",
      "side": 1,
      "message": "I have only one graphics card, but I have several nodes exposed under it (DD01, until DD0F, and then DD1F and DD2F). Only one is actually \"working\" (in the sense that I can read and set a value): DD2F.\n\nBut, as noted in my comment, the _ADR value do not match. The first devices have addresses 1 to 15, the last two both have address 31 in the _ADR field.\n\nThere seem to be only one entry in the _DOD, and the display ID (from the log before in this function) says:\n\n\"Display ID \u003d Type 1, Value 65536\"\n\nThat is the correct type (ACPI_TYPE_INTEGER), but the value does not match any of the addresses. So, either something is wrong with my BIOS (very possible), or something is wrong with this code. But disabling this temporarily allows me to test what happens in other parts of the driver. Of course it should be re-enabled in some way when we understand why it doesn\u0027t work.\n\nI do not yet fully understand ACPI, and I am wondering for example if we could be using the wrong structure definition for the reply to _DOD (since we define equivaents of ACPICA structures, and there are no compiler checks for casting into the correct ones, or there could be alignment and padding issues, etc). But maybe it\u0027s some other problem altogether.",
      "parentUuid": "597ad110_153b6c89",
      "revId": "4e23da664b9012f02dcada4e642ab6f058e7560b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a3ecd47_5b38b3f5",
        "filename": "src/add-ons/kernel/drivers/display/display_adapter.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2024-04-14T17:36:23Z",
      "side": 1,
      "message": "This might come out a bit rambling, but I thought it is better to share, and I don\u0027t have enough time atm to write it better..\n\nI think reading the ACPI_Spec_6_5_Aug29 B section would help. It explains a lot of the setup for displays. \nFor _DOD: \"This method is used to enumerate devices attached to the display adapter. This method is required if integrated\ncontroller supports output switching.\"\n\n\"\nReturn Value:\nA Package containing a variable-length list of Integers, each of which contains the 32-bit device attribute\nof a child device\n\"\n\nAnd for _ADR: \"\nThis method returns a unique ID representing the display output device. All output devices must have a unique\nhardware ID. This method is required for all The IDs returned by this method will appear in the list of hardware IDs\nreturned by the _DOD method.\n\"\n\"\nReturn Value:\nAn Integer containing the device ID (32 bits)\n\"\n\nTo me it looks like _DOD and _ADR integers should be compared 32bit, as Device ID\u0027s are listed as 32 bit examples (see Table B-3, and if we trim 16 bit, the uniqueness they write about will be lost). The internal \"device id\" seems to be named in a confusing way. The upper parts to identify if it is multihead, and the bit for non-vga device, otherwise multihead id 0, non-vga id 0 and vga id 0 will have same id 0. However, note that bit 31:\n\"\nDevice ID Scheme:\n1 - Uses the bit-field definitions above (bits 15:0)\n0 - Other scheme, contact the Video Chip Vendor\n\"\nSo maybe it is just a problem with the highest bit being one...\n\nI am confused about the switch to evaluate_method, as evaluate_object is the  way that ACPICA calls things and enumeration worked fine on my machine. I can\u0027t recall where evaluate_method is used, it might not do what you think it does? \npkgData and buffer juggling also seems more complicated to me. I think you need to give ACPI its memory back, not free it. I might remember wrong, I am very rusty.\n\nSee AcpiEvaluateObject in ACPICA User Guide and Programmer Reference here: https://www.intel.com/content/www/us/en/developer/topic-technology/open/acpica/documentation.html\n\nI don\u0027t think your machine has bad firmware, if it has a _DOD it probably does the right thing, the best would probably be to dump the values and figure out the mapping. Not sure why your machine does not work with the old code for enumerating. It worked on a now very old intel Asus laptop at least.",
      "parentUuid": "c741cef6_27e92913",
      "revId": "4e23da664b9012f02dcada4e642ab6f058e7560b",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}