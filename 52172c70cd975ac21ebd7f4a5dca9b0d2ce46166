{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6dfabfd4_01e05a37",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2020-02-21T13:40:34Z",
      "side": 1,
      "message": "Why not leave BUrl(const char* url) as is and add BUrl(const char* url, bool encode)?",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9fbe9aa_b272c3c8",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-08-01T15:49:52Z",
      "side": 1,
      "message": "I\u0027m not sure about this, it would preserve the existing ABI and existing apps would still run. But, if we make the existing constructor encode the URL, it is a change of behavior (the old version of the API did not do it automatically). And, if we make it not encode it, you can put yourself in a situation where your URL is essentially unusable, because it is not URL encoded and there is no function to encode it. Which is the thing we\u0027re trying to avoid with this change.\n\nI expect that all working applications did already call UrlEncode in some place (otherwise, non-ASCII characters will just fail to work). And so they would not run anyway because that method is removed. Unless we also add an ABI stub for it that just does nothing, maybe?",
      "parentUuid": "6dfabfd4_01e05a37",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "459cc920_c28d8d69",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2021-08-02T04:16:55Z",
      "side": 1,
      "message": "Symbol versioning should help here.",
      "parentUuid": "d9fbe9aa_b272c3c8",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cab7a02_b165d167",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-11-29T21:45:18Z",
      "side": 1,
      "message": "Wouldn\u0027t it make more sense to store unencoded strings, and only encode when building the full URL? I think that would make it easier to keep ABI compatibility here?",
      "parentUuid": "459cc920_c28d8d69",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62c347e0_189fc1bb",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-12-22T10:36:22Z",
      "side": 1,
      "message": "Before this change, URLs can be either encoded or not encoded. This leads to confusion in situations where you:\n- Forget to decode or encode\n- Accidentally try to decode or encode multiple times\n\nThe goal of this change is to remove this whole class of errors, by making it harder to misuse the API. This means:\n\n- By default, the constructor automatically encodes the string. Then, you can use it (in HTTP requests, etc) without worrying about encoding or decoding.\n- If you have an already encoded URL string, you can speficy that to the constructor or SetUrlString.\n\nIt is important that the API is done in that direction (encode the URL by default), because that makes it more likely that the problems will be easily identified. Forgetting to encode the URL results in something that \"looks\" valid. But encoding twice (passing an already encoded URL to SetUrlString with encode \u003d true) is easier to detect because the resulting string is recognizable (% characters themselves % encoded).\n\nThis means the following changes are needed:\n\n- Remove the UrlEncode/UrlDecode functions\n- Change the behavior of SetUrlString and BUrl constructor to encode by default\n\nI could keep the old methods as private methods, but it would still break the existing applications in subtle ways where they interface with the services kit: URL will not be encoded and decoded as they should. So, the ABI is preserved from a C++ point of view, but the behavior is broken, possibly in subtle ways (some URLs will still work as they don\u0027t need encoding, but not all of them). What\u0027s the point of keeping the ABI, then?\n\nThat\u0027s why I think breaking the ABI is a better idea here: then all applications using BUrl have to be checked and rebuilt, but at least it\u0027s obvious, and we don\u0027t waste time trying to debug it.",
      "parentUuid": "7cab7a02_b165d167",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a83397a_df7e4ae3",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-12-22T19:37:11Z",
      "side": 1,
      "message": "Alright, that makes sense.\n\nMy question about whether it makes more sense to store unencoded URLs remains, though. That way, whenever an encoded URL is passed, we decode it immediately, and then only re-encode when asked to produce the final result. But maybe there are other reasons that doesn\u0027t make sense to do.",
      "parentUuid": "62c347e0_189fc1bb",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5069e8ee_1744a77e",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-12-23T09:25:55Z",
      "side": 1,
      "message": "It depends how you think about it, I guess.\n\nIf I read the RFC correctly, there is no such thing as a \"decoded\" URL. URLs have a very restricted set of allowed characters, and everything else must be percent encoded. So it makes sense to do this as soon as you construct an URL, and then keep it that way through all modifications to the URL.\n\nRFC 1738:\n\n    Thus, only alphanumerics, the special characters \"$-_.+!*\u0027(),\", and\n    reserved characters used for their reserved purposes may be used\n    unencoded within a URL.\n   \nRFC 3986 is similar:\n\n    A URI is composed from a limited set of characters consisting of\n    digits, letters, and a few graphic symbols.  A reserved subset of\n    those characters may be used to delimit syntax components within a\n    URI while the remaining characters, including both the unreserved set\n    and those reserved characters not acting as delimiters, define each\n    component\u0027s identifying data.\n\n    A percent-encoding mechanism is used to represent a data octet in a\n    component when that octet\u0027s corresponding character is outside the\n    allowed set or is being used as a delimiter of, or within, the\n    component.\n   \nSo, a \"decoded\" URL is invalid as it contains characters that should not be allowed. Encoding at the input makes sure this doesn\u0027t happen.\n\nAn additional problem is that decoding is a destructive operation that loses information:\n\nRFC 3986:\n\n    URIs that differ in the replacement of a reserved character with its\n    corresponding percent-encoded octet are not equivalent.  Percent-\n    encoding a reserved character, or decoding a percent-encoded octet\n    that corresponds to a reserved character, will change how the URI is\n    interpreted by most applications.\n   \nAnd similarly in RFC 1738:\n\n    Usually a URL has the same interpretation when an octet is\n    represented by a character and when it encoded. However, this is not\n    true for reserved characters: encoding a character reserved for a\n    particular scheme may change the semantics of a URL.\n\n    Thus, only alphanumerics, the special characters \"$-_.+!*\u0027(),\", and\n    reserved characters used for their reserved purposes may be used\n    unencoded within a URL.\n\nSo, a naive decoding (which is what we implement now) that replaces all percent encoded characters with the ASCII equivalent will not actually produce the same URL.\n\nThe result is, it\u0027s just a bad idea to work with \"decoded URLs\". For example:\n\n    http://example.com/%3F/test?query\u003dhello\n\nWould decode as:\n\n    http://example.com/?/test?query\u003dhello\n\nWhich does a completely different thing on the web server side.\n\nOr even worse:\n\n    http://example.com/%35/test?query\u003dhello\n\nWill decode as:\n\n    http://example.com/#/test?query\u003dhello\n\nAnd since # is a special case in the HTTP protocol and in browsers, the server will get a request of http://example.com/ only.\n\nWith our URL class it was possible to work with such things (you just have to do url.SetPath(\"#/test/\") for example), and the URL encoding/decoding would work, but the string representation of a decoded URL is confusing and not what you expect. So, URL should really always be encoded to avoid this, and be represented as an unambiguous string with percent encoding where needed.",
      "parentUuid": "4a83397a_df7e4ae3",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5b560e9_430312a0",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-12-23T16:48:03Z",
      "side": 1,
      "message": "Well, I was looking at the fields and assuming that everything was stored in its own BString besides the URL string itself, but indeed it seems that\u0027s not the case. What\u0027s the point of double-storing the various fields then, I wonder? Or why store the UrlString separately instead of just building it when requested?\n\nAlso: should the `bool encode` be called `bool unencoded` instead, to better indicate it goes with the first parameter?",
      "parentUuid": "5069e8ee_1744a77e",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7949d0eb_f58c316b",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-04-30T12:15:34Z",
      "side": 1,
      "message": "PulkoMandy, any remarks about these two questions?",
      "parentUuid": "a5b560e9_430312a0",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0395106_12756104",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2025-04-30T12:59:13Z",
      "side": 1,
      "message": "The internal representation seems out of scope to me, it can be improved/adressed in a subsequent change.",
      "parentUuid": "7949d0eb_f58c316b",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c079ac02_8c4a7792",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2025-05-01T07:47:08Z",
      "side": 1,
      "message": "If I remember correctly, fUrlString is just a cache for optimization. IT avoids re-computing the complete string everything you access it. That\u0027s why it\u0027s declared mutable: this caching can be done even on a const object when you get the URL as a string. The UrlString() method relies on fUrlStringValid to know if it needs to regenerate the string, or if it can use the already generated one. This way, calling UrlString() (or converting the URL to const char* or to BString implicitly) is relatively cheap as long as the URL is not modified.\n\nThe same thing is done for the authority and userinfo, which are composite fields as well (userinfo is username and password, and authority is userinfo plus host and port).\n\nFor the parameter naming, I don\u0027t have a strong opinion, but \"encode\" seems easier to understand to me. This is better solved by providing documentation, I cna look into that, but maybe in a separate commit as discussing this one was already complicated enough.\n\nFinally regarding preserving ABI compatibility: indeed the patch has aged a lot and I expect there are more things using BUrl now than there were in 2018. So, this has become more important to keep working. This won\u0027t be solved by symbol versioning since the new methods are different from the old ones (methods entirely deleted, or new parameters added to existing methods). So, the correct solution is to keep the deprecated methods for now, and make them private. Then we can remove them later after all apps using them have been rebuilt.",
      "parentUuid": "e0395106_12756104",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "112c1e3f_defa6be7",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2020-02-21T13:40:34Z",
      "side": 1,
      "message": "Why not leave SetUrlString(const BString\u0026 url) as is, and add SetUrlString(const BString\u0026 url, bool encode)?",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "469c0d2e_3d505e53",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-12-22T10:36:22Z",
      "side": 1,
      "message": "Same as the constructor: if we leave it strictly \"as is\", it would not encode the URL, and keep open the possibility to create an URL that is not encoded.\n\nIf on the other hand we change it to encode the URL, it keeps the ABI, but changes the behavior, and applications will be broken (in more subtle ways) as a result.",
      "parentUuid": "112c1e3f_defa6be7",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a99b850_4617e2cf",
        "filename": "headers/os/support/Url.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2025-05-01T11:37:33Z",
      "side": 1,
      "message": "I re-added the old constructor as private for ABI compatibility. Unfortunately, it forces all callers to explicitly set the boolean encode parameter to true (or false), the default value cannot apply because the call is ambiguous between the new and old constructor.\n\nIn the next commit in the patch series I fix all callers in Haiku codebase accordingly. The explicit boolean in the callers can be removed after we remove the legacy methods, I guess after one or two beta releases when every app has been recompiled with the new API/ABI.",
      "parentUuid": "469c0d2e_3d505e53",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2167590c_e74f0aca",
        "filename": "src/kits/network/libnetapi/FileRequest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2020-02-21T12:01:34Z",
      "side": 1,
      "message": "remove this",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e86c7432_e1c653fa",
        "filename": "src/kits/network/libnetapi/FileRequest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-08-01T15:49:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2167590c_e74f0aca",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ed9ddd5_3a29f4b1",
        "filename": "src/kits/network/libnetapi/GopherRequest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 191,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2020-02-21T12:01:34Z",
      "side": 1,
      "message": "remove this",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c46eca9d_196af58a",
        "filename": "src/kits/network/libnetapi/GopherRequest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 191,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-08-01T15:49:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4ed9ddd5_3a29f4b1",
      "revId": "52172c70cd975ac21ebd7f4a5dca9b0d2ce46166",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}