{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "46dc8260_d19e8005",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-01-04T21:16:56Z",
      "side": 1,
      "message": "\u003e Noob question here. keymap structure is the one found at InterfaceDefs.h?\n\nYes,\n\nAs you can see, the struct key_map starts with a \"version\" field so we need to increase that, and enlarge the tables.\n\nWe probably need to keep the previous version of the structure for old BeOS apps, and give them a truncated keymap? And have the new version only for new Haiku apps? There are several ways to do this, probably the easiest one is to add a get_key_map variant that takes a max_version as a parameter, and return a keympa of a version lower or equal.\n\nThe old get_key_map function can then be implemented by calling the new one and setting that parameter to 1 to ask for the old BeOS style keymap. And later on if we introduce more keymap versions, we will have a little less work to do.",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "525686a2_f3349d5a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000214
      },
      "writtenOn": "2022-01-05T17:47:34Z",
      "side": 1,
      "message": "The requirement is keeping binary and source compatibility with BeOS apps or just binary?\n\nIf binary only, we can safely grow arrays from 128 to... 256? And then, using version field control how many scancodes we copy. Am I right?",
      "parentUuid": "46dc8260_d19e8005",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d8b63db8_69857139",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-01-05T17:57:45Z",
      "side": 1,
      "message": "The requirement is keeping binary compatibility. To achieve this, a function must exist with this prototype:\n\n    void get_key_map(struct key_map*);\n\nThis function must fill the passed struct with the v1 keymap format, always.\n\nThe idea is to add a new function:\n\n    void get_key_map(int version, struct key_map*);\n\nThis function can return a keymap using up to the version passed as a parameter (but not a newer one).\n\nSo new apps would do:\n\n    struct key_map myKeymap;\n    get_key_map(2, \u0026myKeymap);\n\nWe can implement the old function as:\n\n\n    void get_key_map(struct key_map* map)\n    {\n        get_key_map(1, map);\n\n    }\n\n\nLater on if we ever introduce yet another keymap format, already compiled apps will all specifiy they expect version 1 or 2 so no new function needs to be introduced.\n\nWe can add a B_CURRENT_KEYMAP_VERSION define:\n\n    #define B_CURRENT_KEYMAP_VERSION 2\n\n\nAnd we could also decide to hide this from application developers, by having this in InterfaceDefs.h:\n\n\n    #define get_key_map(x) get_key_map(B_CURRENT_KEYMAP_VERSION, x)\n\nThis way, developers don\u0027t need to know what tricks we are doing. They just call get_key_map(myKeys) and get the latest keymap version at the time of compiling.",
      "parentUuid": "525686a2_f3349d5a",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16b6ef26_2e00134a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000214
      },
      "writtenOn": "2022-01-10T12:32:15Z",
      "side": 1,
      "message": "I did some research this days, and I really wanted to push a patch to have some code to speak about, but I am afraid it is not on a good shape yet. Anyway, I told you what we have:\n\n- Public prototype is this void get_key_map(key_map **map, char **key_buffer). Function is responsible of allocating the space (and I guess, client is to free them)\n- There is a private function prototyped as void _get_key_map(key_map **map, char **key_buffer, ssize_t *key_buffer_size). It returns also the key buffer size. Public one is wrapped on top of this one. This private function is already used at on the input kit.\n\nSo I understand api already diverged and initial prototype is only there for backwards compatibility. Will _get_key_map remain private forever? Will move to something public in the form of get_key_map_ext? or perhaps, being C++ we can just use overload feature and use the same function name (with different arguments).\n\nNow, the struct key_map. As the memory is allocated on function, I though about using some union trick to keep a single structure but that is not allowed on C++. I see no other solution but a new structure, key_map_ext with key arrays increased from 128 to 256 or whatever we need.\n\nIn summary:\n\nstruct key_map {...}\nstruct key_map_ext {...}\n\nget_key_map(key_map **map, char **key_buffer)\nget_key_map(key_map_ext **map, char **key_buffer, ssize_t *key_buffer_size)\n\nWhat do you think?",
      "parentUuid": "d8b63db8_69857139",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fe76299_a01fba13",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-01-10T13:11:30Z",
      "side": 1,
      "message": "key_buffer_size isn\u0027t a great way to specify different keymap versions. If we are going to introduce a new API, I would rather have it use an explicit parameter:\n\n    status_get_key_map(key_map_ext **map, char **key_buffer, int max_version);\n\nAlso the size is irrelevant since the function is doing the allocation by itself (I missed that in my previous comment).\n\nThe function is documented here: https://www.haiku-os.org/legacy-docs/bebook/TheInputServer_Functions.html\n\nSince it does the allocation, it means we have another option to avoid breaking ABI: add new fields at the end of the structure, like this:\n\n    struct key_map {\n\tuint32\tversion;\n\tuint32\tcaps_key;\n\tuint32\tscroll_key;\n\tuint32\tnum_key;\n\tuint32\tleft_shift_key;\n\tuint32\tright_shift_key;\n\tuint32\tleft_command_key;\n\tuint32\tright_command_key;\n\tuint32\tleft_control_key;\n\tuint32\tright_control_key;\n\tuint32\tleft_option_key;\n\tuint32\tright_option_key;\n\tuint32\tmenu_key;\n\tuint32\tlock_settings;\n\tint32\tcontrol_map[128];\n\tint32\toption_caps_shift_map[128];\n\tint32\toption_caps_map[128];\n\tint32\toption_shift_map[128];\n\tint32\toption_map[128];\n\tint32\tcaps_shift_map[128];\n\tint32\tcaps_map[128];\n\tint32\tshift_map[128];\n\tint32\tnormal_map[128];\n\tint32\tacute_dead_key[32];\n\tint32\tgrave_dead_key[32];\n\tint32\tcircumflex_dead_key[32];\n\tint32\tdieresis_dead_key[32];\n\tint32\ttilde_dead_key[32];\n\tuint32\tacute_tables;\n\tuint32\tgrave_tables;\n\tuint32\tcircumflex_tables;\n\tuint32\tdieresis_tables;\n\tuint32\ttilde_tables;\n\n\tint32\textended_control_map[128];\n\tint32\textended_option_caps_shift_map[128];\n\tint32\textended_option_caps_map[128];\n\tint32\textended_option_shift_map[128];\n\tint32\textended_option_map[128];\n\tint32\textended_caps_shift_map[128];\n\tint32\textended_caps_map[128];\n\tint32\textended_shift_map[128];\n\tint32\textended_normal_map[128];\n    };\n\nIn that case, old applications will not see any difference. They will just not be able to use any of the new keys. The downside of this is that accessing the keymap content is made even more confusing than it already was. The upside is that there is no ABI change: no new function needed, old apps find the data they need where they need it. For new apps we can even add a few methods to this confusing structure to make it easier to handle, for example something like this:\n\n    BUnicodeChar key_map::GetCharForKey(int32 key, int32 modifiers);\n\nI\u0027m not sure what problem you got with unions, they are allowed in C++. In that case we would instead do something like this:\n\n    struct key_map {\n        int32\tversion;\n\n        union {\n            struct {\n                uint32\tcaps_key;\n                uint32\tscroll_key;\n                uint32\tnum_key;\n                uint32\tleft_shift_key;\n                uint32\tright_shift_key;\n                uint32\tleft_command_key;\n                uint32\tright_command_key;\n                uint32\tleft_control_key;\n                uint32\tright_control_key;\n                uint32\tleft_option_key;\n                uint32\tright_option_key;\n                uint32\tmenu_key;\n                uint32\tlock_settings;\n                int32\tcontrol_map[128];\n                int32\toption_caps_shift_map[128];\n                int32\toption_caps_map[128];\n                int32\toption_shift_map[128];\n                int32\toption_map[128];\n                int32\tcaps_shift_map[128];\n                int32\tcaps_map[128];\n                int32\tshift_map[128];\n                int32\tnormal_map[128];\n                int32\tacute_dead_key[32];\n                int32\tgrave_dead_key[32];\n                int32\tcircumflex_dead_key[32];\n                int32\tdieresis_dead_key[32];\n                int32\ttilde_dead_key[32];\n                uint32\tacute_tables;\n                uint32\tgrave_tables;\n                uint32\tcircumflex_tables;\n                uint32\tdieresis_tables;\n                uint32\ttilde_tables;\n            } legacy;\n            struct {\n                uint32\tcaps_key;\n                uint32\tscroll_key;\n                uint32\tnum_key;\n                uint32\tleft_shift_key;\n                uint32\tright_shift_key;\n                uint32\tleft_command_key;\n                uint32\tright_command_key;\n                uint32\tleft_control_key;\n                uint32\tright_control_key;\n                uint32\tleft_option_key;\n                uint32\tright_option_key;\n                uint32\tmenu_key;\n                uint32\tlock_settings;\n                int32\tcontrol_map[256];\n                int32\toption_caps_shift_map[256];\n                int32\toption_caps_map[256];\n                int32\toption_shift_map[256];\n                int32\toption_map[256];\n                int32\tcaps_shift_map[256];\n                int32\tcaps_map[256];\n                int32\tshift_map[256];\n                int32\tnormal_map[256];\n                int32\tacute_dead_key[32];\n                int32\tgrave_dead_key[32];\n                int32\tcircumflex_dead_key[32];\n                int32\tdieresis_dead_key[32];\n                int32\ttilde_dead_key[32];\n                uint32\tacute_tables;\n                uint32\tgrave_tables;\n                uint32\tcircumflex_tables;\n                uint32\tdieresis_tables;\n                uint32\ttilde_tables;\n            };\n        };\n    };\n\nThen we need the following APIs:\n\n    status_t get_key_map(key_map_ext **map, char **key_buffer, int max_version);\n    status_t get_key_map(key_map_ext **map, char **key_buffer) {\n        // Legacy version, always returns v1 keymaps\n        return get key_map(map, key_buffer, 1);\n    }\n\nNew apps can use the new API:\n\n    get_key_map(map, keys, 2);\n\nProbably we want to go further than this, however. The keymap format is confusing with the separate keys array. So maybe for v2 we coud stop using that array and just set it to a NULL pointer instead, and do something like this:\n\n    struct key_map {\n        int32\tversion;\n\n        union {\n            struct {\n                uint32\tcaps_key;\n                uint32\tscroll_key;\n                uint32\tnum_key;\n                uint32\tleft_shift_key;\n                uint32\tright_shift_key;\n                uint32\tleft_command_key;\n                uint32\tright_command_key;\n                uint32\tleft_control_key;\n                uint32\tright_control_key;\n                uint32\tleft_option_key;\n                uint32\tright_option_key;\n                uint32\tmenu_key;\n                uint32\tlock_settings;\n                int32\tcontrol_map[128];\n                int32\toption_caps_shift_map[128];\n                int32\toption_caps_map[128];\n                int32\toption_shift_map[128];\n                int32\toption_map[128];\n                int32\tcaps_shift_map[128];\n                int32\tcaps_map[128];\n                int32\tshift_map[128];\n                int32\tnormal_map[128];\n                int32\tacute_dead_key[32];\n                int32\tgrave_dead_key[32];\n                int32\tcircumflex_dead_key[32];\n                int32\tdieresis_dead_key[32];\n                int32\ttilde_dead_key[32];\n                uint32\tacute_tables;\n                uint32\tgrave_tables;\n                uint32\tcircumflex_tables;\n                uint32\tdieresis_tables;\n                uint32\ttilde_tables;\n            } legacy;\n            struct {\n                uint32\tcaps_key;\n                uint32\tscroll_key;\n                uint32\tnum_key;\n                uint32\tleft_shift_key;\n                uint32\tright_shift_key;\n                uint32\tleft_command_key;\n                uint32\tright_command_key;\n                uint32\tleft_control_key;\n                uint32\tright_control_key;\n                uint32\tleft_option_key;\n                uint32\tright_option_key;\n                uint32\tmenu_key;\n                uint32\tlock_settings;\n                BUnicodeChar\tcontrol_map[256];\n                BUnicodeChar    option_caps_shift_map[256];\n                BUnicodeChar\toption_caps_map[256];\n                BUnicodeChar\toption_shift_map[256];\n                BUnicodeChar\toption_map[256];\n                BUnicodeChar\tcaps_shift_map[256];\n                BUnicodeChar\tcaps_map[256];\n                BUnicodeChar\tshift_map[256];\n                BUnicodeChar\tnormal_map[256];\n                BUnicodeChar\tacute_dead_key[32];\n                BUnicodeChar\tgrave_dead_key[32];\n                BUnicodeChar\tcircumflex_dead_key[32];\n                BUnicodeChar\tdieresis_dead_key[32];\n                BUnicodeChar\ttilde_dead_key[32];\n                uint32\tacute_tables;\n                uint32\tgrave_tables;\n                uint32\tcircumflex_tables;\n                uint32\tdieresis_tables;\n                uint32\ttilde_tables;\n            };\n        };\n    };\n\nSecondly, it is a bit annoying that all new apps would need to explicitly say which version of the keymap they want. We can workaround this with some extra tricks:\n\n\nSince we are not using the second argument, we can cheat and have only one function:\n\n    status_t get_key_map(key_map_ext **map, char **key_buffer \u003d NULL);\n\nNew apps expect the new keymap format and don\u0027t need the key_buffer at all, therefore they just do:\n\n    get_key_map(keymap);\n\nOld apps surely do need the key buffer because the keymap struct is completely useless without it. So they will never pass NULL as a second argument. We can detect this, and when an application does so, make sure to return a keymap in the legacy format.\n\nNote: I didn\u0027t check that any of this actually compiles, and I have not handled the needed changes for dead key tables either. But we can discuss that once we have the basic handling of the two different keymap formats in place.",
      "parentUuid": "16b6ef26_2e00134a",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5bc762f1_526e64be",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000214
      },
      "writtenOn": "2022-01-10T16:52:41Z",
      "side": 1,
      "message": "\u003e I\u0027m not sure what problem you got with unions, they are allowed in C++.\n\nAnonymous structs and unions?\n\nI had to double check that. Yes, the example we have in mind works. I\u0027ve been reading and It is not very clear to me. Some sites says there are supported by gcc but disallowed. I even had the impression of Microsoft doing lobby against it. Wikipedia says there are some limitations (on C++). Anyway, using this trick, wouldn\u0027t be better this:\n\nstruct key_map {\n    union {\n        struct {\n            ...\n        };\n        struct {\n            ...\n        } extended;\n    };\n};\n\nSo binary and legacy code access key_map members as usual and new one access through extended member.\n\nOk, so we have at least two approaches to solve keep a single key_map struct. Let me a pair of days and I will try to submit a proof of concept.",
      "parentUuid": "0fe76299_a01fba13",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fd8eb1e2_d468de32",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-01-10T17:32:48Z",
      "side": 1,
      "message": "I wrote it so that newly compiled code access the fields without any extra effort. Really the older version is there mainly for ABI compatibility, which is only for already compiled code. So it\u0027s ok if writing new code using that path is complicated (or even impossible), as long as already compiled apps continue to run.\n\nSo I tend to make the new version easier to use, as it helps ensuring newly written apps quickly migrate to it.\n\nYou are right that anonymous structs in unions was standardized only in C11 and not yet in C++. I think this is fine as long as gcc accepts it, and I think we already use it in other places. If it doesn\u0027t, we will have to name both inner structures and the union, making code using this a bit more verbose.",
      "parentUuid": "5bc762f1_526e64be",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dfc9bad0_eb1ebe7b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-12-23T13:06:01Z",
      "side": 1,
      "message": "Key codes are now defined by reusing HID constants, so if we want something here, it has to be updated to match that.",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}