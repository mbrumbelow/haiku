{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "46dc8260_d19e8005",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-01-04T21:16:56Z",
      "side": 1,
      "message": "\u003e Noob question here. keymap structure is the one found at InterfaceDefs.h?\n\nYes,\n\nAs you can see, the struct key_map starts with a \"version\" field so we need to increase that, and enlarge the tables.\n\nWe probably need to keep the previous version of the structure for old BeOS apps, and give them a truncated keymap? And have the new version only for new Haiku apps? There are several ways to do this, probably the easiest one is to add a get_key_map variant that takes a max_version as a parameter, and return a keympa of a version lower or equal.\n\nThe old get_key_map function can then be implemented by calling the new one and setting that parameter to 1 to ask for the old BeOS style keymap. And later on if we introduce more keymap versions, we will have a little less work to do.",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "525686a2_f3349d5a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000214
      },
      "writtenOn": "2022-01-05T17:47:34Z",
      "side": 1,
      "message": "The requirement is keeping binary and source compatibility with BeOS apps or just binary?\n\nIf binary only, we can safely grow arrays from 128 to... 256? And then, using version field control how many scancodes we copy. Am I right?",
      "parentUuid": "46dc8260_d19e8005",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d8b63db8_69857139",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2022-01-05T17:57:45Z",
      "side": 1,
      "message": "The requirement is keeping binary compatibility. To achieve this, a function must exist with this prototype:\n\n    void get_key_map(struct key_map*);\n\nThis function must fill the passed struct with the v1 keymap format, always.\n\nThe idea is to add a new function:\n\n    void get_key_map(int version, struct key_map*);\n\nThis function can return a keymap using up to the version passed as a parameter (but not a newer one).\n\nSo new apps would do:\n\n    struct key_map myKeymap;\n    get_key_map(2, \u0026myKeymap);\n\nWe can implement the old function as:\n\n\n    void get_key_map(struct key_map* map)\n    {\n        get_key_map(1, map);\n\n    }\n\n\nLater on if we ever introduce yet another keymap format, already compiled apps will all specifiy they expect version 1 or 2 so no new function needs to be introduced.\n\nWe can add a B_CURRENT_KEYMAP_VERSION define:\n\n    #define B_CURRENT_KEYMAP_VERSION 2\n\n\nAnd we could also decide to hide this from application developers, by having this in InterfaceDefs.h:\n\n\n    #define get_key_map(x) get_key_map(B_CURRENT_KEYMAP_VERSION, x)\n\nThis way, developers don\u0027t need to know what tricks we are doing. They just call get_key_map(myKeys) and get the latest keymap version at the time of compiling.",
      "parentUuid": "525686a2_f3349d5a",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16b6ef26_2e00134a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000214
      },
      "writtenOn": "2022-01-10T12:32:15Z",
      "side": 1,
      "message": "I did some research this days, and I really wanted to push a patch to have some code to speak about, but I am afraid it is not on a good shape yet. Anyway, I told you what we have:\n\n- Public prototype is this void get_key_map(key_map **map, char **key_buffer). Function is responsible of allocating the space (and I guess, client is to free them)\n- There is a private function prototyped as void _get_key_map(key_map **map, char **key_buffer, ssize_t *key_buffer_size). It returns also the key buffer size. Public one is wrapped on top of this one. This private function is already used at on the input kit.\n\nSo I understand api already diverged and initial prototype is only there for backwards compatibility. Will _get_key_map remain private forever? Will move to something public in the form of get_key_map_ext? or perhaps, being C++ we can just use overload feature and use the same function name (with different arguments).\n\nNow, the struct key_map. As the memory is allocated on function, I though about using some union trick to keep a single structure but that is not allowed on C++. I see no other solution but a new structure, key_map_ext with key arrays increased from 128 to 256 or whatever we need.\n\nIn summary:\n\nstruct key_map {...}\nstruct key_map_ext {...}\n\nget_key_map(key_map **map, char **key_buffer)\nget_key_map(key_map_ext **map, char **key_buffer, ssize_t *key_buffer_size)\n\nWhat do you think?",
      "parentUuid": "d8b63db8_69857139",
      "revId": "f66c32e30e9520764e1029f719ec1b3b63d1682f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}