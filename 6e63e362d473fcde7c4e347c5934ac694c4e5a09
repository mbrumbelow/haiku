{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1294c884_91b82f8f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-08-22T11:55:24Z",
      "side": 1,
      "message": "If I understand correctly, the virtual timer is not running when the OS is running in a VM and the VM is not actively using the CPU:\n\nhttps://developer.arm.com/documentation/102142/0100/Virtualizing-the-generic-timers\n\nSo this would drift away from the real \"wall clock\" time, and all timers would run too slowly or stop completely.\n\nAlso, this code is running from the kernel, so, shouldn\u0027t it be using the EL1 registers instead? (that\u0027s what I understand from https://krinkinmu.github.io/2021/01/04/aarch64-exception-levels.html : the kernel may configure things to disallow EL0 (userspace) to access the timers directly, but then it should use EL1 registers to access it)\n\n(I could be wrong, my knowledge of ARM is limited and not up to date with 64bit architectures).",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65aa4d7b_f1f4a199",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-22T20:38:57Z",
      "side": 1,
      "message": "\u003e If I understand correctly, the virtual timer is not running when the OS is running in a VM and the VM is not actively using the CPU:\n\u003e \n\u003e https://developer.arm.com/documentation/102142/0100/Virtualizing-the-generic-timers\n\u003e \n\u003e So this would drift away from the real \"wall clock\" time, and all timers would run too slowly or stop completely.\n\nOn my system, attempts to access the physical timers result in an exception and crash the kernel, presumably because the hypervisor blocks access to it.\n\nFor reference, Linux uses the virtual timers when not running in hypervisor mode:\nhttps://github.com/torvalds/linux/blob/872cf28b8df9c5c3a1e71a88ee750df7c2513971/drivers/clocksource/arm_arch_timer.c#L1405\n\n\u003e Also, this code is running from the kernel, so, shouldn\u0027t it be using the EL1 registers instead? (that\u0027s what I understand from https://krinkinmu.github.io/2021/01/04/aarch64-exception-levels.html : the kernel may configure things to disallow EL0 (userspace) to access the timers directly, but then it should use EL1 registers to access it)\n\u003e \n\u003e (I could be wrong, my knowledge of ARM is limited and not up to date with 64bit architectures).\n\nI can look into this, but it seems somewhat orthogonal.",
      "parentUuid": "1294c884_91b82f8f",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0402622_68fbd2df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-08-22T20:52:28Z",
      "side": 1,
      "message": "Hmm, sounds like we need a switch in this code for hypervisor vs. non-hypervisor then, like Linux does.\n\n(Also, FWIW, we generally try to look at the *BSDs first rather than Linux. Sometimes looking at Linux is a necessity, but in general since the BSDs are, well, BSD-licensed and Linux is GPL, that\u0027s the preference. But again, license/copyright concerns are probably a non-issue for this logic.)",
      "parentUuid": "65aa4d7b_f1f4a199",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73f9954c_b4464bb9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-22T21:03:06Z",
      "side": 1,
      "message": "AFAICT the Haiku kernel is always running in EL1 (the bootloader drops from EL2 to EL1 if we started there), so we’re never in hypervisor mode in the parlance of that logic. So the equivalent is just always using the virtual timers. \n\nTo be clear, they don’t drift on their own: the hypervisor can make them drift to do time slicing. So in the no-hypervisor case using virtual timers has no downside.",
      "parentUuid": "a0402622_68fbd2df",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e444dd2e_e161ebdc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-08-22T21:04:12Z",
      "side": 1,
      "message": "Ah, good to know.",
      "parentUuid": "73f9954c_b4464bb9",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a83eb842_2e5a6e4f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-22T22:19:27Z",
      "side": 1,
      "message": "I believe this is the equivalent part in FreeBSD: https://github.com/freebsd/freebsd-src/blob/6aee1dc48006445b6e062db86c5c3697b04b98f6/sys/arm/arm/generic_timer.c#L699\n\nTheir logic seems to be:\n* Use physical timers if VHE extension is enabled.\n* Otherwise, use virtual timers if not running in EL2, use physical timers if running in EL2",
      "parentUuid": "e444dd2e_e161ebdc",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab18ab58_9a582129",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-08-23T01:01:01Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a83eb842_2e5a6e4f",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "113f5542_1d378a0d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-23T07:05:17Z",
      "side": 1,
      "message": "\u003e Also, this code is running from the kernel, so, shouldn\u0027t it be using the EL1 registers instead?\n\nI looked into this. There are no EL1 versions of these registers. The EL0 version is intended to be used by EL1 and/or EL0 in this case.",
      "parentUuid": "ab18ab58_9a582129",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9500ae49_2e5978e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-08-23T10:00:11Z",
      "side": 1,
      "message": "Yes, when there is no hypervisor this will not cause a problem. What I don\u0027t understand is how things are expected to work when there is an hypervisor and it\u0027s slowing down the timer (if you run Haiku in a VM, this could happen).\n\nDepending on what the timer is used for exactly, we either want it to stop when the CPU is not running (maybe the VM has been paused and the guest OS should not notice), or we want it to continue running (so that when the VM is resumed, the OS can keep track of \"real\" time and, from a userspace viewpoint quite distant from this, expire DHCP leases, for example). That is one thing the system_time may be used for. If your VM gets a lease from a DHCP server, and then is put to sleep for a few hours, it may continue tothink it is allowed to use that IP address, while the DHCP server has long sicne attributed it to someone else. This is one example where system_time would need to reflect the physical world time, and should not be modified by the hypervisor.\n\nBut, on the other hand, it makes sense that the virtualizer/hypervisor would not let us write to the physical counters and timers and reconfigure them. And, for the timer interrupts, it may be fine to use the virtual one.\n\nSo, maybe the right thing to do is is implement system_time using the physical counter (read-only), with an initial read in arch_init_timer that will be subtracted from the current value in system_time, making sure we implement it correctly (timer value starts at 0 at computer boot). And the other operations, which need to write to the timers, could use the virtual one, since they don\u0027t have to be related to physical/outside world time.\n\nI also found https://events19.linuxfoundation.org/wp-content/uploads/2017/12/Christopher-Dall_Arm-Timers-and-Fire.pdf which gives a good overview of the timers, according to it, the OS should be able to use the physical timer, and this would be handled by the hypervisor (trapping and emulating the access). And indeed VHE extensions change how this works. In the case of VHE, the guest OS should have no problem using the physical timer and this is handled transparently. And this is an example with Linux, maybe if you use another host OS it is a bit different...",
      "parentUuid": "113f5542_1d378a0d",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab435267_fdbbc629",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-23T10:15:11Z",
      "side": 1,
      "message": "\u003e Yes, when there is no hypervisor this will not cause a problem. What I don\u0027t understand is how things are expected to work when there is an hypervisor and it\u0027s slowing down the timer (if you run Haiku in a VM, this could happen).\n\nIt somewhat *doesn\u0027t* work. That\u0027s the problem the talk you linked is addressing.\n\n\u003e Depending on what the timer is used for exactly, we either want it to stop when the CPU is not running (maybe the VM has been paused and the guest OS should not notice), or we want it to continue running (so that when the VM is resumed, the OS can keep track of \"real\" time and, from a userspace viewpoint quite distant from this, expire DHCP leases, for example). That is one thing the system_time may be used for. If your VM gets a lease from a DHCP server, and then is put to sleep for a few hours, it may continue tothink it is allowed to use that IP address, while the DHCP server has long sicne attributed it to someone else. This is one example where system_time would need to reflect the physical world time, and should not be modified by the hypervisor.\n\nThe general solution seems to be to use the PSCI interface to ask the hypervisor to report stolen time, which can then be taken into account.\n\n\u003e But, on the other hand, it makes sense that the virtualizer/hypervisor would not let us write to the physical counters and timers and reconfigure them. And, for the timer interrupts, it may be fine to use the virtual one.\n\u003e \n\u003e So, maybe the right thing to do is is implement system_time using the physical counter (read-only), with an initial read in arch_init_timer that will be subtracted from the current value in system_time, making sure we implement it correctly (timer value starts at 0 at computer boot). And the other operations, which need to write to the timers, could use the virtual one, since they don\u0027t have to be related to physical/outside world time.\n\nSure, we can do it. See updated patch momentarily.\n\n\u003e And this is an example with Linux, maybe if you use another host OS it is a bit different...\n\nI\u0027m testing with QEMU on MacOS on M1 Max hardware using virtualization.",
      "parentUuid": "9500ae49_2e5978e4",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c5db2e1_4e50dfe4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-23T10:19:03Z",
      "side": 1,
      "message": "Confirmed that I can access the physical timer read-only, so uploaded a new version that continues to use that for system_time().",
      "parentUuid": "ab435267_fdbbc629",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}