{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1294c884_91b82f8f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-08-22T11:55:24Z",
      "side": 1,
      "message": "If I understand correctly, the virtual timer is not running when the OS is running in a VM and the VM is not actively using the CPU:\n\nhttps://developer.arm.com/documentation/102142/0100/Virtualizing-the-generic-timers\n\nSo this would drift away from the real \"wall clock\" time, and all timers would run too slowly or stop completely.\n\nAlso, this code is running from the kernel, so, shouldn\u0027t it be using the EL1 registers instead? (that\u0027s what I understand from https://krinkinmu.github.io/2021/01/04/aarch64-exception-levels.html : the kernel may configure things to disallow EL0 (userspace) to access the timers directly, but then it should use EL1 registers to access it)\n\n(I could be wrong, my knowledge of ARM is limited and not up to date with 64bit architectures).",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65aa4d7b_f1f4a199",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-22T20:38:57Z",
      "side": 1,
      "message": "\u003e If I understand correctly, the virtual timer is not running when the OS is running in a VM and the VM is not actively using the CPU:\n\u003e \n\u003e https://developer.arm.com/documentation/102142/0100/Virtualizing-the-generic-timers\n\u003e \n\u003e So this would drift away from the real \"wall clock\" time, and all timers would run too slowly or stop completely.\n\nOn my system, attempts to access the physical timers result in an exception and crash the kernel, presumably because the hypervisor blocks access to it.\n\nFor reference, Linux uses the virtual timers when not running in hypervisor mode:\nhttps://github.com/torvalds/linux/blob/872cf28b8df9c5c3a1e71a88ee750df7c2513971/drivers/clocksource/arm_arch_timer.c#L1405\n\n\u003e Also, this code is running from the kernel, so, shouldn\u0027t it be using the EL1 registers instead? (that\u0027s what I understand from https://krinkinmu.github.io/2021/01/04/aarch64-exception-levels.html : the kernel may configure things to disallow EL0 (userspace) to access the timers directly, but then it should use EL1 registers to access it)\n\u003e \n\u003e (I could be wrong, my knowledge of ARM is limited and not up to date with 64bit architectures).\n\nI can look into this, but it seems somewhat orthogonal.",
      "parentUuid": "1294c884_91b82f8f",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0402622_68fbd2df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-08-22T20:52:28Z",
      "side": 1,
      "message": "Hmm, sounds like we need a switch in this code for hypervisor vs. non-hypervisor then, like Linux does.\n\n(Also, FWIW, we generally try to look at the *BSDs first rather than Linux. Sometimes looking at Linux is a necessity, but in general since the BSDs are, well, BSD-licensed and Linux is GPL, that\u0027s the preference. But again, license/copyright concerns are probably a non-issue for this logic.)",
      "parentUuid": "65aa4d7b_f1f4a199",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73f9954c_b4464bb9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000677
      },
      "writtenOn": "2024-08-22T21:03:06Z",
      "side": 1,
      "message": "AFAICT the Haiku kernel is always running in EL1 (the bootloader drops from EL2 to EL1 if we started there), so we’re never in hypervisor mode in the parlance of that logic. So the equivalent is just always using the virtual timers. \n\nTo be clear, they don’t drift on their own: the hypervisor can make them drift to do time slicing. So in the no-hypervisor case using virtual timers has no downside.",
      "parentUuid": "a0402622_68fbd2df",
      "revId": "6e63e362d473fcde7c4e347c5934ac694c4e5a09",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}