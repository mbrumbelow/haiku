{
  "comments": [
    {
      "key": {
        "uuid": "eeb1b9ea_ddfcf792",
        "filename": "src/system/kernel/arch/riscv64/arch_platform.cpp",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-04T22:23:58Z",
      "side": 1,
      "message": "What does kPlatform1Riscv even mean? Everything is RISC-V.",
      "revId": "36c6e7fd8bf4b541349a3673931e03d1bba3674f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b56226b6_c96c4d00",
        "filename": "src/system/kernel/arch/riscv64/arch_platform.cpp",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2021-08-04T23:52:24Z",
      "side": 1,
      "message": "\u003e What does kPlatform1Riscv even mean? Everything is RISC-V.\n\nIt means bare metal boot loader haiku_loader.riscv machine mode interface (MSyscall). It is currenly used only for CLINT timers. It is not SBI compatible. Kernel currently supports both SBI and MSyscall.",
      "parentUuid": "eeb1b9ea_ddfcf792",
      "revId": "36c6e7fd8bf4b541349a3673931e03d1bba3674f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51e06d2a_92c77f11",
        "filename": "src/system/kernel/arch/riscv64/arch_platform.cpp",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-08-13T17:06:57Z",
      "side": 1,
      "message": "This seems fine.  kPlatform1Riscv is an identifier that the system was booted via the native machine loader that X512 created to get this port going.  kPlatform1Sbi is the standard supervisor booted method.\n\nThese vary based on the (haiku) platform loader used.  The naming could be better, but overall it fills a need while the architecture port is maturing.",
      "parentUuid": "b56226b6_c96c4d00",
      "revId": "36c6e7fd8bf4b541349a3673931e03d1bba3674f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3023a9d8_32f5a88f",
        "filename": "src/system/kernel/arch/riscv64/arch_platform.cpp",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-04T22:23:58Z",
      "side": 1,
      "message": "HTIF makes no sense for a kernel. It\u0027s intended as a really crappy semihosting interface for bare-metal firmware. Haiku is not firmware. Depending on how your platform\u0027s HTIF support works (if it even exists), you may not even be able to use it from a kernel booted by firmware even if you wanted to, as some platforms (such as Spike) use the HTIF address specified by the tohost/fromhost symbols (or dot-prefixed sections?) in the firmware\u0027s ELF headers, which are completely unknown to an OS.",
      "revId": "36c6e7fd8bf4b541349a3673931e03d1bba3674f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b27c447_bcac6abc",
        "filename": "src/system/kernel/arch/riscv64/arch_platform.cpp",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2021-08-04T23:52:24Z",
      "side": 1,
      "message": "HTIF is the only way to shut down machine on TinyEMU. It is also used in my TinyEMU patch to access RTC clock.",
      "parentUuid": "3023a9d8_32f5a88f",
      "revId": "36c6e7fd8bf4b541349a3673931e03d1bba3674f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6334214_6deca47d",
        "filename": "src/system/kernel/arch/riscv64/arch_platform.cpp",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-04T23:58:49Z",
      "side": 1,
      "message": "Shutting down is done by calling the SBI shutdown function (if you want to support legacy SBI) or SBI system reset function with the type set to shutdown (if you are happy only supporting modern SBI, i.e. just OpenSBI and not BBL). Behind the scenes that will use the HTIF if needed, or a GPIO driver on some boards, or a write to a syscon-poweroff device in the case of QEMU. This is why SBI exists.\n\nHaving to patch TinyEMU isn\u0027t a good idea, but if you do want to upstream a patch to expose the RTC then I suggest emulating a normal RTC device, such as the Goldfish RTC as used by QEMU\u0027s RISC-V virt machine, which was designed for the purpose of virtual machines and is simple to both implement and use.",
      "parentUuid": "7b27c447_bcac6abc",
      "revId": "36c6e7fd8bf4b541349a3673931e03d1bba3674f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5a1e362_d214535f",
        "filename": "src/system/kernel/arch/riscv64/arch_platform.cpp",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-08-13T17:06:57Z",
      "side": 1,
      "message": "The riscv64 machine code was a tool X512 leveraged to mature the Haiku riscv port.   Ideally as the ecosystem stability matures (cough sbi -\u003e efi cough) these machine level platform loaders will no longer be needed.\n\nHaiku is not linux or FreeBSD.  We have zero functional non-x86 architecture ports. Thus lots of pointy bits.",
      "parentUuid": "f6334214_6deca47d",
      "revId": "36c6e7fd8bf4b541349a3673931e03d1bba3674f",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": false
    }
  ]
}