{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "83bbb66a_03b8e283",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-03-13T01:54:43Z",
      "side": 1,
      "message": "We shouldn\u0027t use bootservices in the kernel...",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c33f273_f9e2cacc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2023-03-13T11:06:52Z",
      "side": 1,
      "message": "I think it isn\u0027t. It is designed for boot loader, but located in the same directory as other DebugUART implementations.",
      "parentUuid": "83bbb66a_03b8e283",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c56b4785_45860e5f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-03-13T14:08:27Z",
      "side": 1,
      "message": "Good points.  Moved into efi loader-only code paths.  This one still a WIP since I need to actually use it in the code.\n\nI was originally thinking the kernel could use it, but yeah... I don\u0027t think Serial IO Protocol is available outside of boot services.",
      "parentUuid": "2c33f273_f9e2cacc",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9443638d_9bd47af0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-03-13T14:27:31Z",
      "side": 1,
      "message": "I don\u0027t get what the point of it is either way. Isn\u0027t the DebugUART system just used by the bootloader \"serial\" system?",
      "parentUuid": "c56b4785_45860e5f",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94506102_6874cb0a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-03-13T14:50:29Z",
      "side": 1,
      "message": "tqh was pushing for this to reduce the number of checks for the serial port on putc.  \n\nIf the EFI serial port follows the same design as the hardware UART drivers, then the logic and checks get a lot less complex.",
      "parentUuid": "9443638d_9bd47af0",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a5f45f7_cee310fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-03-15T17:13:26Z",
      "side": 1,
      "message": "The whole point was to have a serial struct with a putchar and puts that don\u0027t do checks for every char. \nThis seems more complex and still does the checks.\n\nSo a serial for UEFI to use inside uefi with \u0027\\r\\n\u0027, and then native or null serial that can be used during whole boot. You pick the right one at init in uefi, and another one if uefi on init outside uefi. No need to do checks except in init\u0027s.",
      "parentUuid": "94506102_6874cb0a",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c99038d_17e31bc6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-03-15T19:42:37Z",
      "side": 1,
      "message": "\u003e The whole point was to have a serial struct with a putchar and puts that don\u0027t do checks for every char. \n\nWasn\u0027t the whole point to not have to check for hardware serial vs efi serial I/O on every putc?  This accomplishes this.\n\nThe \\r\\n check wasn\u0027t mentioned as what you wanted to eliminate.",
      "parentUuid": "6a5f45f7_cee310fe",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93d6a1be_8e94ae64",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-03-15T21:25:38Z",
      "side": 1,
      "message": "Yes that is the idea so when you have native code moved out of the generic layer, you can have the correct line endings for different impls in them as well.\nI was more pointing to serial.h and serial.cpp where putc still does a lot if\u0027s and #ifdef instead of just \"impl-\u003eputc(c)\". \nWe should not have ifdefs for x86 and arm and riscv in the generic code. We should just do impl \u003d (pick correct impl) when \"init_efi()\" and \"init_native()\".",
      "parentUuid": "4c99038d_17e31bc6",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7eb6081_7c12e3b9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-03-18T07:25:40Z",
      "side": 1,
      "message": "I can see only a single #if in putc which is for sending the string on-screen instead of sending it to the serial port. This will normally remain disabled, but can be useful in debugging the implementation of serial output.\n\nThe other problem is, we do need to switch from one implementation to another here. At the start of the boot, we have not yet loaded the device tree, and so we use the EFI generic serial interface if available. But later in the boot, we exit the boot services, and we can\u0027t use the EFI generic serial interface anymore. So, if we were to use a single UART implementation, we would have to make a choice of missing either early boot logs (including device tree parsing) or late boot logs (including kernel startup).\n\nThen there is the special case in serial_init for x86. This is because x86 does not have an FDT and often doesn\u0027t have the EFI serial console available either. So in this case, we go with an hardcoded address for the \"well known\" serial port of the IBM PC, which is a reasnably safe choice to make. Again, this has to be done as early as possible in the boot, so we can see what we are doing.\n\nI think in this case, the slightly unclean architecture is necessary, because having logs for the whole boot process is really important, and I don\u0027t think there is a way to achieve that with a perfectly clean architecture. And if there is, this patch is clearly a move in the right direction anyway, so we can merge it, make sure things still work for everyone, and make further steps starting from there?",
      "parentUuid": "93d6a1be_8e94ae64",
      "revId": "8d0cbfbcb1f8ba556ec2018e8914faac00764923",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}