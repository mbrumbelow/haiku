{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d743eff5_6fe5673c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 22
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-03T09:11:41Z",
      "side": 1,
      "message": "Ok I think the code is starting to make sense now. There is one formatting problems and two places where small changes are needed.",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "907cba81_46841d28",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 22
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-05-03T16:43:06Z",
      "side": 1,
      "message": "I wonder: does it really make sense to store the auto-configure state as a flag? Probably it makes sense to have a CONFIGURING flag so that any application can easily detect when an address family \"exists\" but isn\u0027t \"configured\" yet (... or does that not make sense either, because any configured family will have an address set, while any unconfigured family won\u0027t?), but, do we really need a distinction at this level between \"auto-configured\" and \"configured\"? Why not have net_server keep track of that, too?",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ea86a06_a6eb7682",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 22
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-03T17:18:25Z",
      "side": 1,
      "message": "It needs to be exposed in some way to ifconfig and Network preferences, so they can display the state of the interface and where its addresses come from (DHCP or manual configuration).\n\nWould you have BNetworkInterfaceAddress communicate with net_server to get that information? How would that work when the net_server uses BNetworkInterfaceAddress? (it does that in two places, and we can\u0027t have it try to message itself I think).\n\nIn the end, just storing a flag on the kernel side is a simple way to get this information forwarded to all places that need it, and (in this version of the implementation at least), it does not have big consequences in terms of adding complexity to the kernel code. Just using a field that\u0027s already there.\n\nAlso, this is how FreeBSD exposes that information for IPv6 (the flag is called IN6_IFF_AUTOCONF there). So we may as well match what they do.",
      "parentUuid": "907cba81_46841d28",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c22b21a7_7f505d6a",
        "filename": "headers/posix/net/if.h",
        "patchSetId": 22
      },
      "lineNbr": 83,
      "author": {
        "id": 1000448
      },
      "writtenOn": "2024-05-07T18:50:55Z",
      "side": 1,
      "message": "Why the change of value here?",
      "range": {
        "startLine": 83,
        "startChar": 8,
        "endLine": 83,
        "endChar": 28
      },
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "337f5458_ffb8b5ba",
        "filename": "headers/posix/net/if.h",
        "patchSetId": 22
      },
      "lineNbr": 84,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-04-24T18:01:11Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n#define IFAF_AUTO_CONFIGURED 0x2000 /* has been automatically configured */\n#define IFAF_CONFIGURING 0x0002 /* auto configuration in progress */\n```",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 84,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b65e286a_87b53e15",
        "filename": "src/add-ons/kernel/network/stack/datalink.cpp",
        "patchSetId": 22
      },
      "lineNbr": 876,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2024-04-24T18:01:11Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t\t\t\tsizeof(uint32_t));\n```",
      "range": {
        "startLine": 876,
        "startChar": 0,
        "endLine": 876,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f769ad1_2c8f3ed7",
        "filename": "src/add-ons/kernel/network/stack/datalink.cpp",
        "patchSetId": 22
      },
      "lineNbr": 876,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-03T09:11:41Z",
      "side": 1,
      "message": "incorrect indentation",
      "parentUuid": "b65e286a_87b53e15",
      "range": {
        "startLine": 876,
        "startChar": 0,
        "endLine": 876,
        "endChar": 0
      },
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb165753_88acf104",
        "filename": "src/add-ons/kernel/network/stack/interfaces.cpp",
        "patchSetId": 22
      },
      "lineNbr": 830,
      "author": {
        "id": 1000448
      },
      "writtenOn": "2024-05-07T18:50:55Z",
      "side": 1,
      "message": "that seems to be mixing up interface alias flags and interface address flags\n\nbtw, I guess these alias requests are completely unused right now?",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67f9e37c_24a7e6fa",
        "filename": "src/preferences/network/InterfaceAddressView.cpp",
        "patchSetId": 22
      },
      "lineNbr": 250,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-03T09:11:41Z",
      "side": 1,
      "message": "This seems not correct, if the interface is not configuring anymore.\n\nHaving a local-only interface (connected to a network with no internet access), it\u0027s possible that there is simply no gateway to exit the network at all.\n\nI think the simplest way is to move the code inside the check for autoconfiguring.\n\nThere are basically 3 cases:\n\n    There is a GW address: display it\n    There is no GW address:\n        We are in autoconfiguring state: display \"Trying to get...\"\n        We are not in autoconfiguring state: set to NULL (likely a local-only network that doesn\u0027t have a gateway)",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e50cfddc_86fb6193",
        "filename": "src/servers/net/NetServer.cpp",
        "patchSetId": 22
      },
      "lineNbr": 431,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-03T09:11:41Z",
      "side": 1,
      "message": "this is mising up interface and address flags in the same \"flags\" variable, it would be better to track them in two separate variables (intefaceFlags and addressFlags for example) to avoid confusion",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "348f2b4e_a3cfd99c",
        "filename": "src/servers/net/NetServer.cpp",
        "patchSetId": 22
      },
      "lineNbr": 431,
      "author": {
        "id": 1000610
      },
      "writtenOn": "2024-05-07T18:19:24Z",
      "side": 1,
      "message": "Although I have used the new address level flag macro here , the flag variable is not being used in address scope but at interface scope in the current codebase.\nThis flag variable is used to decide whether IFF_CONFIGURING flag should be unset on the interface or not.\nI guess I will have to bring back IFF_AUTO_CONFIGURED alongside IFAF_AUTO_CONFIGURED and revert back to the original changes in this particular line of code highlighted so that the behaviour of the code remains unchanged.\nPlease let me know your opinion.",
      "parentUuid": "e50cfddc_86fb6193",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c40fab0_bb0adde6",
        "filename": "src/servers/net/NetServer.cpp",
        "patchSetId": 22
      },
      "lineNbr": 431,
      "author": {
        "id": 1000448
      },
      "writtenOn": "2024-05-07T18:50:55Z",
      "side": 1,
      "message": "the comment right above IFAF_AUTO_CONFIGURED says \"interface alias flags\" (not address level flags)\n\nThere is an IFAF_DIRECT_ADDRESS (additional address flags) used somewhere else, but I guess the common IFAF_ prefix is an unfortunate coincidence.",
      "parentUuid": "348f2b4e_a3cfd99c",
      "revId": "f01568f4924b7e50cf558538b856c1d7721d7367",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}