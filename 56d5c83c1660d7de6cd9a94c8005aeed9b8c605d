{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c52a6729_19bd7a7c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-05T22:38:48Z",
      "side": 1,
      "message": "korli: I\u0027m not sure what you were trying to solve in the commit this reverts, but this seems much more correct: we now preserve the FPU status words as set by applications or the kernel rather than clobbering them.",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0c2d39c_618a748a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-05T22:39:16Z",
      "side": 1,
      "message": "Using the default values from fenv.h alone fixes #19454 at least, but this seems more correct.",
      "parentUuid": "c52a6729_19bd7a7c",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "719c17a4_a20097e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-05T22:42:02Z",
      "side": 1,
      "message": "mmlr points out this may not be needed at all if FXRSTOR/FXSAVE/XSAVEC are in use?\n\nSo, can we drop this altogether then, and just use EMMS? Or is that not needed either?",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d335f35_fbb83909",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2025-03-06T05:40:15Z",
      "side": 1,
      "message": "Was trying to fix when using the debugger as described in #18656",
      "parentUuid": "d0c2d39c_618a748a",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a080a52_0c6829c4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2025-03-06T05:40:15Z",
      "side": 1,
      "message": "Restoring the state with the FP exception might trigger the FP exception again. It\u0027s difficult to know whether it is expected, meaning the user code should handle SIGFPE.",
      "parentUuid": "719c17a4_a20097e2",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74541023_244c0ac9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-06T13:03:34Z",
      "side": 1,
      "message": "Ah, OK.\n\nWhy does that happen before the context switch occurs, though? I.e. why do we see the stack of the previous thread and not the new thread? The FPU context switch happens after the the thread context switch, right?\n\nWould it help to invoke EMMS in int_user_bottom and other such places rather than here?\n\nActually I can\u0027t find any reference to EMMS in FreeBSD AMD64 sources. So how do they handle this case?",
      "parentUuid": "6d335f35_fbb83909",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6a7c002_3a419bdf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-06T13:16:42Z",
      "side": 1,
      "message": "Looks like FreeBSD just lets the FP exception happen again: https://github.com/freebsd/freebsd-src/blob/main/sys/amd64/amd64/fpu.c#L682\n\nSo can we delete the additions to x86_context_switch altogether, and just leave the EMMS? Or what else is needed to make this case work properly?\n\nThis also may be relevant? https://github.com/freebsd/freebsd-src/blob/main/sys/amd64/amd64/fpu.c#L1009",
      "parentUuid": "1a080a52_0c6829c4",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c82fbb6b_081352d0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2025-03-06T19:44:20Z",
      "side": 1,
      "message": "Well if it fixes the issues except the profile/strace/Debugger problems, I think it\u0027s better.\nDoes FreeBSD uses the FPU in the kernel BTW?",
      "parentUuid": "74541023_244c0ac9",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a09ba09_a52c76fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-06T20:09:27Z",
      "side": 1,
      "message": "This doesn\u0027t seem to fix the profile problem, no. I didn\u0027t investigate that further yet. And I didn\u0027t retest #18656 so it\u0027s possible this regresses that too, I need to check.\n\nFreeBSD does allow use of FPU in the kernel, but only inside fpu_kern_enter()/fpu_kern_leave() blocks, which manage a context separately.\n\nConsidering they don\u0027t invoke \"emms\", do we need to here? What about invoking it before the context switch instead of after?",
      "parentUuid": "c82fbb6b_081352d0",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d05edd3_8586cd81",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-07T18:18:03Z",
      "side": 1,
      "message": "Well, I investigated more, and I\u0027m still confused.\n\nI tried removing the LDMXCSR and FLDCW entirely, because as far as I can tell from the documentation, FXRSTOR and other like operations restore x87 status words and MXCSR (as long as OSFXSR is set, and I asserted it is), but I am seeing exception 19 happen in other threads with similar MXCSR states to the first faulting thread (this is with a dprintf in the exception handler to print the FCW/MXCSR state and then signal code):\n```\nFPU exception 19: 1, 26\ndebug_server: Thread 244 entered the debugger: Floating point exception\nFPU exception 19: 33, 26\ndebug_server: Thread 225 entered the debugger: Floating point exception\nFPU exception 19: 33, 26\ndebug_server: Thread 213 entered the debugger: Floating point exception\n```\n\nThe same happens with the x87 FPU:\n```\nFPU exception 16: 32897, 26\ndebug_server: Thread 249 entered the debugger: Floating point exception\nFPU exception 16: 32897, 26\ndebug_server: Thread 256 entered the debugger: Floating point exception\n```\n\nFreeBSD\u0027s fputrap_* methods don\u0027t clear this state (indeed a context switch might have happened by the time they are called.) Moreover I grepped through FreeBSD source and see no references to LDMXCSR except in amd64/fpu.c and include/ieeefp.h in their kernel (besides disassemblers and i386 code also of course.)\n\nI disabled XSAVE support, it made no difference the same faults still happen.\n\nSo what is supposed to happen here? I don\u0027t see anything in Intel documentation that indicates MXCSR and FLCW will be left unchanged by FXRSTOR if it contains exception bits. So what is going wrong?",
      "parentUuid": "3a09ba09_a52c76fe",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b781265b_1b78b724",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-07T18:46:43Z",
      "side": 1,
      "message": "Mh... we don\u0027t save or restore FPU state at syscall entry. That seems like a security hole actually, we need to clobber anything the kernel set on syscall exit. And we also need to preserve the control word and flags because the kernel may modify those too. So I guess that likely explains it.",
      "parentUuid": "7d05edd3_8586cd81",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6f03a67_17b6833e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2025-03-07T18:50:23Z",
      "side": 1,
      "message": "a bit of context on emms:\nhttps://github.com/cloudius-systems/osv/commit/25209d81f7b872111beb02ab9758f0d86898ec6b\nsyscalls are voluntary context switchs, right?",
      "parentUuid": "b781265b_1b78b724",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0a7668b_2879b579",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-07T19:09:05Z",
      "side": 1,
      "message": "Yes, I saw that. However, FreeBSD doesn\u0027t execute EMMS at all. Doesn\u0027t OSv execute everything inside ring 0, it doesn\u0027t use userspace? So that may make a difference.\n\nsyscalls are voluntary context switches, however, it seems MXCSR is callee-saved. So that explains why we need to save it specially here.\n\nAlso if we don\u0027t clobber XMM regs on return to userland, we might leak kernel data, or other threads\u0027 data. So that should probably be fixed too.",
      "parentUuid": "f6f03a67_17b6833e",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16d6868b_09a33894",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2025-03-07T20:10:31Z",
      "side": 1,
      "message": "we clobber XMM regs on return to userland, when they aren\u0027t restored:\nhttps://cgit.haiku-os.org/haiku/tree/src/system/kernel/arch/x86/64/interrupts.S#n481",
      "parentUuid": "c0a7668b_2879b579",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "260df1e1_2654a06e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-07T20:13:16Z",
      "side": 1,
      "message": "Ah, OK, seems I missed that then.",
      "parentUuid": "16d6868b_09a33894",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fd91931_dcff7ccd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-07T20:23:12Z",
      "side": 1,
      "message": "With more testing, it seems either FNCLEX or EMMS is needed to avoid exceptions indeed. I guess if OSv went with EMMS then we might as well use that. But I wonder why FreeBSD does not seem to have the same problem, and apparently stopped using EMMS? I did run the tests under FreeBSD.",
      "parentUuid": "260df1e1_2654a06e",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a900607_eec04721",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-07T20:24:48Z",
      "side": 1,
      "message": "Ah, I guess it\u0027s just because they don\u0027t allow FPU usage by default in the kernel. So they only change the control words with FXRSTOR or the like in general, which do not raise exceptions.",
      "parentUuid": "2fd91931_dcff7ccd",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92dbee55_5dfd40e5",
        "filename": "headers/private/kernel/arch/x86/64/cpu.h",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2025-03-05T22:40:54Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tasm volatile(\"fnstcw %0\" : \"\u003dm\"(fpuControl));\n```",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0683cfce_719aa923",
        "filename": "headers/private/kernel/arch/x86/64/cpu.h",
        "patchSetId": 2
      },
      "lineNbr": 18,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2025-03-05T22:40:54Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tasm volatile(\"stmxcsr %0\" : \"\u003dm\"(sseControl));\n```",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ee5a9379_83d04f01",
        "filename": "headers/private/kernel/arch/x86/64/cpu.h",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2025-03-05T22:40:54Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\tasm volatile(\"ldmxcsr %0\" : : \"m\"(sseControl));\n\tasm volatile(\"fldcw %0\" : : \"m\"(fpuControl));\n```",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 38,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "56d5c83c1660d7de6cd9a94c8005aeed9b8c605d",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}