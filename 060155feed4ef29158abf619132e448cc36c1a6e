{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4affa0a8_5c281a3e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T00:22:28Z",
      "side": 1,
      "message": "Wouldn\u0027t this be a kernel bug? If it returns B_OK without the unlock actually having occurred, that is? Or perhaps a bug in the other thread\u0027s invocation?\n\nThere are also a number of other usages of _kern_mutex_lock throughout the tree. Are all of those wrong, too? (It really feels like _kern_mutex_lock shouldn\u0027t return B_OK unless we really are the lock holder.)",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4aa6a7cb_fad6ebab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T00:28:47Z",
      "side": 1,
      "message": "Yes, looking at pthread_mutex_unlock, it only calls the kernel after it unsets mutex-\u003eowner. So, _kern_mutex_lock has no business returning B_OK here while we aren\u0027t the mutex\u0027s owner, that implies something else has gone wrong, and is probably a kernel bug. This is then not a proper fix but will cover up other issues.",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba729f87_8035b4c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T00:32:33Z",
      "side": 1,
      "message": "It appears the kernel can return B_OK spuriously when B_USER_MUTEX_UNBLOCK_ALL is set. I don\u0027t see anywhere that\u0027s done in here, though, but that should probably be fixed.",
      "parentUuid": "4aa6a7cb_fad6ebab",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20a5f966_c1f83b39",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-06-06T01:19:46Z",
      "side": 1,
      "message": "From what I can tell, it never calls into the kernel, none of the debug statements within `if ((oldValue \u0026 (B_USER_MUTEX_LOCKED | B_USER_MUTEX_WAITING)) !\u003d 0)` is output.\n\nThe commit implementing the debug output below: https://github.com/jessicah/haiku/commit/0985166506047eeb559c1f326e78be91d8e3cd9d\n\nExcerpt of when the double lock happens:\n\nThread A holds lock\nThread B: lock: ENTER\nThread A: unlock: unset owner\nThread A: unlock: EXIT: released mutex\nThread B: lock: acquiring uncontested mutex\nThread B: lock: EXIT: acquired mutex: new owner: B\nThread C: lock: ENTER\nThread C: lock: acquiring mutex: previous owner: B\nThread C: lock: EXIT: acquired mutex: new owner: C\n\nThe full debugging log: https://1drv.ms/x/s!AjlXG9ChB73fvLZN6ngzmtOIh2MNuA?e\u003d863937",
      "parentUuid": "4affa0a8_5c281a3e",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dff616da_c124a2b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T01:48:30Z",
      "side": 1,
      "message": "I have published https://review.haiku-os.org/c/haiku/+/6490 cleaning up the kernel side of things and fixing some problems I see there.",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbe60750_882a8123",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T02:16:41Z",
      "side": 1,
      "message": "Reading the code, I don\u0027t understand how this is possible. Thread B acquires the lock, this means B_USER_MUTEX_LOCKED is now set. Thread C starts *after* Thread B EXITs from the lock routine, so even if we had some kind of atomic ordering problem, there is no way Thread C should see a lock state without B_USER_MUTEX_LOCKED set.",
      "parentUuid": "20a5f966_c1f83b39",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}