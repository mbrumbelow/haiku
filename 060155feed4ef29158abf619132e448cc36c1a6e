{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4affa0a8_5c281a3e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T00:22:28Z",
      "side": 1,
      "message": "Wouldn\u0027t this be a kernel bug? If it returns B_OK without the unlock actually having occurred, that is? Or perhaps a bug in the other thread\u0027s invocation?\n\nThere are also a number of other usages of _kern_mutex_lock throughout the tree. Are all of those wrong, too? (It really feels like _kern_mutex_lock shouldn\u0027t return B_OK unless we really are the lock holder.)",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4aa6a7cb_fad6ebab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T00:28:47Z",
      "side": 1,
      "message": "Yes, looking at pthread_mutex_unlock, it only calls the kernel after it unsets mutex-\u003eowner. So, _kern_mutex_lock has no business returning B_OK here while we aren\u0027t the mutex\u0027s owner, that implies something else has gone wrong, and is probably a kernel bug. This is then not a proper fix but will cover up other issues.",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba729f87_8035b4c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T00:32:33Z",
      "side": 1,
      "message": "It appears the kernel can return B_OK spuriously when B_USER_MUTEX_UNBLOCK_ALL is set. I don\u0027t see anywhere that\u0027s done in here, though, but that should probably be fixed.",
      "parentUuid": "4aa6a7cb_fad6ebab",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20a5f966_c1f83b39",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-06-06T01:19:46Z",
      "side": 1,
      "message": "From what I can tell, it never calls into the kernel, none of the debug statements within `if ((oldValue \u0026 (B_USER_MUTEX_LOCKED | B_USER_MUTEX_WAITING)) !\u003d 0)` is output.\n\nThe commit implementing the debug output below: https://github.com/jessicah/haiku/commit/0985166506047eeb559c1f326e78be91d8e3cd9d\n\nExcerpt of when the double lock happens:\n\nThread A holds lock\nThread B: lock: ENTER\nThread A: unlock: unset owner\nThread A: unlock: EXIT: released mutex\nThread B: lock: acquiring uncontested mutex\nThread B: lock: EXIT: acquired mutex: new owner: B\nThread C: lock: ENTER\nThread C: lock: acquiring mutex: previous owner: B\nThread C: lock: EXIT: acquired mutex: new owner: C\n\nThe full debugging log: https://1drv.ms/x/s!AjlXG9ChB73fvLZN6ngzmtOIh2MNuA?e\u003d863937",
      "parentUuid": "4affa0a8_5c281a3e",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dff616da_c124a2b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T01:48:30Z",
      "side": 1,
      "message": "I have published https://review.haiku-os.org/c/haiku/+/6490 cleaning up the kernel side of things and fixing some problems I see there.",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbe60750_882a8123",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T02:16:41Z",
      "side": 1,
      "message": "Reading the code, I don\u0027t understand how this is possible. Thread B acquires the lock, this means B_USER_MUTEX_LOCKED is now set. Thread C starts *after* Thread B EXITs from the lock routine, so even if we had some kind of atomic ordering problem, there is no way Thread C should see a lock state without B_USER_MUTEX_LOCKED set.",
      "parentUuid": "20a5f966_c1f83b39",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f22a83c4_7c3a2119",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T02:47:40Z",
      "side": 1,
      "message": "OK, I realized that if we assume things start out in that excerpt an invalid state, then everything falls into place:\n\nThread A holds lock // HOWEVER, the LOCKED flag is not set for some reason!\nThread B lock: ENTER // and then it quickly sets the LOCKED flag\nThread A: unlock: unset owner // and also unsets the LOCKED flag set by thread B!\n...\nThread B: lock: EXIT: acquired mutex: new owner: B // but LOCKED is still unset!",
      "parentUuid": "fbe60750_882a8123",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f94b2169_1f61f51d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T03:07:03Z",
      "side": 1,
      "message": "I think I figured out how we can wind up in a state where thread A holds the lock but the LOCKED flag is not set:\n\n1. Thread 1 holds lock.\n2. Thread 2 goes to acquire lock, winds up in kernel waiting.\n3. Thread 1 unlocks; first unsets the LOCKED flag, then sees WAITING is set and calls kernel.\n4. Thread 2 times out, unsets WAITING flag.\n5. Thread 3 goes to acquire lock. Sets LOCKED flag. Sees WAITING flag is not set. Returns at once having acquired the lock.\n6. Thread 1 sees no threads are waiting in the kernel. Unsets LOCKED flag, despite it having already been re-set by thread 3.\n\nWe now have the situation first described: a locked mutex without the lock flag set. The scenario I described above will then transpire.",
      "parentUuid": "f22a83c4_7c3a2119",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6848e206_57993aaa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-06T04:27:42Z",
      "side": 1,
      "message": "Experimental commits (untested) at https://github.com/waddlesplash/haiku/tree/lock-fix which should fix this. Will complete commit messages and push once jessicah confirms they fix the problem.",
      "parentUuid": "f94b2169_1f61f51d",
      "revId": "060155feed4ef29158abf619132e448cc36c1a6e",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}