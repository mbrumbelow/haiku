{
  "comments": [
    {
      "key": {
        "uuid": "6ec14885_2d7cada5",
        "filename": "headers/private/kernel/arch/riscv64/arch_int.h",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-05T00:24:36Z",
      "side": 1,
      "message": "CSRRS instruction",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e2177ee_f5bceae8",
        "filename": "headers/private/kernel/arch/riscv64/arch_int.h",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-05T00:24:36Z",
      "side": 1,
      "message": "CSRRC instruction",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1a04dcd_6016a0e0",
        "filename": "src/system/kernel/arch/riscv64/arch_int.cpp",
        "patchSetId": 4
      },
      "lineNbr": 293,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-05T00:24:36Z",
      "side": 1,
      "message": "Surely this belongs in a machine-independent library header somewhere?",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cf7c274_ae231db7",
        "filename": "src/system/kernel/arch/riscv64/arch_int.cpp",
        "patchSetId": 4
      },
      "lineNbr": 293,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2021-08-05T00:36:20Z",
      "side": 1,
      "message": "Yes, it should be moved. But maybe it is better to just move SSTATUS save to asm code and trap frame.",
      "parentUuid": "c1a04dcd_6016a0e0",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67f0f116_8f8532a2",
        "filename": "src/system/kernel/arch/riscv64/arch_int.cpp",
        "patchSetId": 4
      },
      "lineNbr": 437,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-05T00:24:36Z",
      "side": 1,
      "message": "This layout is not at all guaranteed. You have to read the interrupts-extended property of the PLIC\u0027s device tree node to find which indices are supervisor external interrupts and which harts they map to. The PLIC should also be separated out of here as its own driver that this calls (indirectly, so it can be swapped out transparently), as a new interrupt controller is being worked on.",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2bb020c3_1801fc11",
        "filename": "src/system/kernel/arch/riscv64/arch_int.cpp",
        "patchSetId": 4
      },
      "lineNbr": 437,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2021-08-05T00:36:20Z",
      "side": 1,
      "message": "Yes, I know. I already understand how to get PLIC context id mapping for HART id from FDT, but it is currently not implemented.",
      "parentUuid": "67f0f116_8f8532a2",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dfa089fd_dca04d92",
        "filename": "src/system/kernel/arch/riscv64/arch_int.cpp",
        "patchSetId": 4
      },
      "lineNbr": 494,
      "author": {
        "id": 1000281
      },
      "writtenOn": "2021-08-05T00:24:36Z",
      "side": 1,
      "message": "FPU in the kernel? And what about userspace? I don\u0027t see floating-point registers in the trap frame, how are you making sure those get context switched as needed if you\u0027re not trapping on them being accessed?",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e794749_c6c2f0ce",
        "filename": "src/system/kernel/arch/riscv64/arch_int.cpp",
        "patchSetId": 4
      },
      "lineNbr": 494,
      "author": {
        "id": 1000172
      },
      "writtenOn": "2021-08-05T00:36:20Z",
      "side": 1,
      "message": "Yes, FPU is used in Haiku kernel and boot loader, but rarely. Kernel mode FPU handling is not correct for now. I am currently considering how to efficiently implement it, saving FPU registers on each trap would be inefficient. Probably FPU should be initially disabled and re-enabled on illegal instruction trap handler.",
      "parentUuid": "dfa089fd_dca04d92",
      "revId": "8161c76c60e8024febe00ef54581d35f63528317",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5",
      "unresolved": true
    }
  ]
}