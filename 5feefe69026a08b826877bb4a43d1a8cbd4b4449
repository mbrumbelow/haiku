{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e7a1f57f_9f754459",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-03-11T14:12:41Z",
      "side": 1,
      "message": "Won\u0027t this generate warnings?",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "946c34cb_5f69441e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-03-11T14:20:02Z",
      "side": 1,
      "message": "Warnings are compiler dependent. Is there something you think is wrong with this code?",
      "parentUuid": "e7a1f57f_9f754459",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e5e7f7d_bf5e74fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-03-11T14:22:42Z",
      "side": 1,
      "message": "Yes: the precise type of \"int32\" changes with architecture and pointer bit depth. There are differences even on 32-bit x86 between gcc2 and gcc8+ for BeOS ABI reasons. Sometimes int32 is just an int (%d), sometimes it\u0027s a long int (%ld), and when it\u0027s one and not the other, we\u0027ll get compiler warnings and maybe errors. That\u0027s the entire reason for the use of the PRI macros rather than just writing %ld or %d in the first place.",
      "parentUuid": "946c34cb_5f69441e",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fc430bd_f787e155",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-03-11T14:27:14Z",
      "side": 1,
      "message": "This macro cannot be used directly in translated strings because of it changing creating a different string.\n\nI am a bit baffled why int32 would be redefined. Why define it based on platform-dependant types at all? the 32 already makes it clear what is expected.\n\nOr is the problem that the string sequences only work for platform-dependant types?\n\nSo either: I do a string substition with this string later, or we just ignore the warning if it isn‘t relevant.",
      "parentUuid": "7e5e7f7d_bf5e74fe",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e0645c0_24164f38",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-03-11T14:28:53Z",
      "side": 1,
      "message": "In this code I don‘t get a warning on amd64. While the same string is generated with the macro on intel x86. So as it is written this is warning free currently.",
      "parentUuid": "0fc430bd_f787e155",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b61e7675_6507778d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2024-03-11T14:41:36Z",
      "side": 1,
      "message": "\u003e I am a bit baffled why int32 would be redefined. Why define it based on platform-dependant types at all? the 32 already makes it clear what is expected.\n\nThere is no such type as \"int32\" in C/C++. It has to be defined using platform-dependent types because there\u0027s nothing else to define it in terms of. The type is always a 32-bit signed integer, but what C type is used to represent that 32-bit signed integer varies.\n\n\u003e Or is the problem that the string sequences only work for platform-dependant types?\n\nprintf works with the platform-dependent types, yes. It doesn\u0027t know what an \"int32\" is. So we have to represent things in terms of whatever the actual type is.\n\n\u003e So either: I do a string substition with this string later, or we just ignore the warning if it isn‘t relevant.\n\nWe should not ignore the warning, printf can behave differently if the wrong string is passed to it. The portable way to handle this is to put something else in the string and use .Replace.",
      "parentUuid": "9e0645c0_24164f38",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d48fcc3_a629e313",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-03-11T14:42:17Z",
      "side": 1,
      "message": "\u003e Why define it based on platform-dependant types at all? the 32 already makes it clear what is expected.\n\nHow else would you define it? At the time BeOS engineers did this, there wasn\u0027t an int32_t type in the C standard yet.\n\nThey defined it as \"long int\" because that\u0027s how it used to be done on the Motorola 68000 (where \"int\" could be 16 bits, depending on the compiler).\n\nWe are stuck with this legacy, and changing it for gcc2 would break a lot of things (through changes in C++ mangling). But for 64bit we had to remove the \"long\".\n\nA fully safe solution is to use BMessageFormat or other methods that completely remove the format string from the translation (for example based on BString::ReplaceAll).\n\nThe reason there are no warning is probably because SetToFormat is not currently declared as printflike, so the compiler doesn\u0027t know how to check the format string matches the parameters. We should fix that. It compiles without warnings now, but on 64bit systems it will try to get 64 bits from the parameters, where there are only 32. It may crash, or it may print a wrong value, or maybe it will work by luck if the next 4 bytes are all 0.",
      "parentUuid": "9e0645c0_24164f38",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1d972e8_0acb0cec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-03-11T14:47:34Z",
      "side": 1,
      "message": "I don‘t see how for this code it would be relevant for gcc2.\n\nThis seems to be a big oversight in printf.\n\nI will replace it with a BString equivalent.",
      "parentUuid": "5d48fcc3_a629e313",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c3007a3_68272697",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-03-17T22:01:34Z",
      "side": 1,
      "message": "You can bring your complaints to the designers of the C language. They have reasons for doing it this way: the goal is to minimize the number of cases that printf has to handle at runtime, and so, a wide variety of types are reduced to just a few that actually matter in terms of how the parameter is passed to the function.\n\nAnyways, one solution in tqis specific case is casting the delây argument to int, and always using %d in the format string.",
      "parentUuid": "a1d972e8_0acb0cec",
      "revId": "5feefe69026a08b826877bb4a43d1a8cbd4b4449",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}