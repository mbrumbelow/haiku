{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7f4192b8_ec5cfa26",
        "filename": "src/system/kernel/vm/VMAnonymousCache.h",
        "patchSetId": 10
      },
      "lineNbr": 52,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-20T03:12:34Z",
      "side": 1,
      "message": "Exactly what `force` does should probably be documented or explained somewhere. (Is it really needed? It looks like this just bypasses the \"precommit\" features. What\u0027s the reason for doing that?)",
      "revId": "12794e9bccc61cbb41c5198b712966fdcebea1e5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7ddebda_21386aea",
        "filename": "src/system/kernel/vm/VMAnonymousCache.h",
        "patchSetId": 10
      },
      "lineNbr": 52,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-06-20T03:15:05Z",
      "side": 1,
      "message": "For overcommitting anonymous caches, `Commit` does nothing (except precommitting a small number of pages). It waits until a page fault actually happens.\n\n`force` forces these caches to bypass the overcommitting check and commits the required pages.",
      "parentUuid": "7f4192b8_ec5cfa26",
      "revId": "12794e9bccc61cbb41c5198b712966fdcebea1e5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a077140_af5928db",
        "filename": "src/system/kernel/vm/VMAnonymousCache.h",
        "patchSetId": 10
      },
      "lineNbr": 52,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-20T03:17:28Z",
      "side": 1,
      "message": "OK, that makes some sense, but I\u0027m still not quite understanding -- why is that needed here? Why not just let the overcommitting happen as usual?",
      "parentUuid": "f7ddebda_21386aea",
      "revId": "12794e9bccc61cbb41c5198b712966fdcebea1e5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f511e4e3_687697ef",
        "filename": "src/system/kernel/vm/VMAnonymousCache.h",
        "patchSetId": 10
      },
      "lineNbr": 52,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-06-20T03:26:11Z",
      "side": 1,
      "message": "If that\u0027s the case, on low-memory scenarios, the program will think that the mapping succeeded, but then it could segfault any time when accessing the newly mapped pages.\n\nIn my use case, the program needs to have a way to actively commit memory to avoid such a segfault.",
      "parentUuid": "9a077140_af5928db",
      "revId": "12794e9bccc61cbb41c5198b712966fdcebea1e5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "937e1f60_802055de",
        "filename": "src/system/libroot/posix/sys/mman.cpp",
        "patchSetId": 10
      },
      "lineNbr": 138,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-20T03:09:52Z",
      "side": 1,
      "message": "I very much don\u0027t think we should expose this API through a mmap extension flag. Instead we should just add an entirely new method, `clone_memory` probably. Adding Haiku-specific extensions to POSIX routines should only be done when there is a very, very good reason for it. We have `MAP_NORESERVE`, yes, but that\u0027s not Haiku-specific.",
      "revId": "12794e9bccc61cbb41c5198b712966fdcebea1e5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcbcc865_ec382df9",
        "filename": "src/system/libroot/posix/sys/mman.cpp",
        "patchSetId": 10
      },
      "lineNbr": 138,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2023-06-20T03:13:14Z",
      "side": 1,
      "message": "Where should I place this API then?\n\nThere are currently no non-area Haiku-specific APIs currently exposed to the public.\n\nAlso, this syscall currently requires the private `REGION_[NO_]PRIVATE_MAP` enum. What should we do with that?",
      "parentUuid": "937e1f60_802055de",
      "revId": "12794e9bccc61cbb41c5198b712966fdcebea1e5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc94d38c_47f29162",
        "filename": "src/system/libroot/posix/sys/mman.cpp",
        "patchSetId": 10
      },
      "lineNbr": 138,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-06-20T03:16:15Z",
      "side": 1,
      "message": "Adding a `clone_memory` function right alongside `clone_area` in the headers seems fine to me. Or, maybe place it in private headers for now, and expose it as a C++ symbol so we can more easily version it later on -- I think I like that idea better.\n\nHave private/shared be passed either as a boolean, or accept the MAP_SHARED/MAP_PRIVATE flags as mmap does.",
      "parentUuid": "dcbcc865_ec382df9",
      "revId": "12794e9bccc61cbb41c5198b712966fdcebea1e5",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}