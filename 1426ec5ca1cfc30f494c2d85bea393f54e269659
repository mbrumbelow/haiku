{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "01b3a4da_c3528d27",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2024-05-22T12:24:53Z",
      "side": 1,
      "message": "this bug could lead to memory corruption obviously. But I couldn\u0027t find possible candidates.",
      "revId": "1426ec5ca1cfc30f494c2d85bea393f54e269659",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47626ef5_6db74c6b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-22T13:10:27Z",
      "side": 1,
      "message": "I\u0027m not sure there were any problems here. It\u0027s just that the previous code filled the first bit of each word first, and then the second bit of each word, and so on.\n\nThe new code fills all bits of the first word before moving to the second one instead. I agree that this is more usual and how I would \"naturally\" do it.\n\nTo convince yourself that they are both valid ways to do it, think if a 16x16 bit matrix for a simple case (in other words, 16 words of 16 bits). You can select one of the 256 bits using its 8-bit \"address\". It does not matter if you select a line (16-bit word) by address \u0026 0xF and a column (bit in the 16-bit word) by (address \u0026 0xF0) \u003e\u003e 8, or if you do the opposite. This works the same with arbitrary sizes (in the case here, a 32x2 matrix), and if you write it with division and modulo instead of bit shifts and masks. As long as all functions agree with each other on how to number the bits, there\u0027s no problem.\n\nIt\u0027s possible that the original design was intentional to reduce contention: if you have only two CPUs, they will each use a separate word, reducing the concurrent access of the atomic operation (since each CPU will have its own word to work with).\n\nIt\u0027s also possible that there is some place that addresses the bits in the other direction, and in that case, yes, we would have a bug. I only checked the code in the patchset, but I don\u0027t think this is accessed directly by anything not using the methods that are modified here?",
      "parentUuid": "01b3a4da_c3528d27",
      "revId": "1426ec5ca1cfc30f494c2d85bea393f54e269659",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52de6916_49aca763",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-05-22T13:10:59Z",
      "side": 1,
      "message": "For reference, the commit that introduced this class: https://cgit.haiku-os.org/haiku/commit/?id\u003d7629d527c5ee0f402c5a16d0f42c2b79a5571b07 unfortunately does not explain why it was done this way.",
      "parentUuid": "47626ef5_6db74c6b",
      "revId": "1426ec5ca1cfc30f494c2d85bea393f54e269659",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a475d2c2_faba39d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2024-05-22T13:46:10Z",
      "side": 1,
      "message": "Right, I\u0027m trying to implement thread affinity, the cpu mask from userland has to be this way. I didn\u0027t think someone would do otherwise.",
      "parentUuid": "52de6916_49aca763",
      "revId": "1426ec5ca1cfc30f494c2d85bea393f54e269659",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44eb0fea_a5adedd5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000223
      },
      "writtenOn": "2024-05-22T14:43:41Z",
      "side": 1,
      "message": "\u003e It\u0027s possible that the original design was intentional to reduce contention: if you have only two CPUs, they will each use a separate word, reducing the concurrent access of the atomic operation\n\nEven if you have more than two, still half of them would use fBitmap[0] and the other half fBitmap[1] (with SMP_MAX_CPUS \u003d 64).\n\n\u003e It\u0027s also possible that there is some place that addresses the bits in the other direction, and in that case, yes, we would have a bug.\n\nCan\u0027t happen with the bitmap being private? The new version does make that available through Bits(), so those users now do have knowledge of the internal data and need to be kept in sync.\n\nWhat would be possible is that some place uses a negative or greater than kArraySize * 32 - 1 cpu value. For the negative values we have memory access errors both before and after the change, maybe we should make them uint32. For the big values we had UB before due to the left shifts, probably just accessing whatever modulo 32, while we have out of bounds access with the change.",
      "parentUuid": "a475d2c2_faba39d4",
      "revId": "1426ec5ca1cfc30f494c2d85bea393f54e269659",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}