{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7b813929_f220ed28",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2025-03-09T10:37:35Z",
      "side": 1,
      "message": "Note: this might introduce regressions in apps which handle only one color per message and then return.",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc1b0a2b_8e141708",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-09T23:37:19Z",
      "side": 1,
      "message": "I just looked into the implementation of these methods in app_server, and if I understand the code correctly, this change won\u0027t make any difference: app_server already coalesces multiple color change requests received in a short window into one update, but it always sends out multiple \"color changed\" messages to applications, no matter whether set_ui_color or set_ui_colors was the invoking method. So this doesn\u0027t make a difference and is just extra code for no reason.\n\nNow, that being said, I don\u0027t think we should change how this API/ABI works in app_server to send out one message for multiple color changes, either, because:\n\n1: It won\u0027t just \"possibly\" break existing applications, it *will* break them. And it\u0027s the worst kind of API/ABI break: a totally silent one. Broken applications won\u0027t fail to start and won\u0027t fail to build, and depending on how they are written will probably not throw any errors at runtime either, they will just fail to behave as expected.\n\nThe `B_COLORS_CHANGED` message does not come from BeOS, so technically we are free to break it, but for user-facing APIs we try to keep at least binary compatibility if we can. And we certainly could here ... by just continuing to send the existing multiple messages per color.\n\n2: I don\u0027t really see what benefit it would provide anyway. As an \"efficiency\" gain it\u0027s negligible to meaningless (on a mostly idle system there will still be dozens or more BMessages sent per second anyway, such as mouse movements and B_PULSE, so a few dozen more sent rarely doesn\u0027t make much difference if any.) So then it\u0027s only applications that would want to update colors in batches that get any benefit; but what applications actually want to do this? Meanwhile all other applications that don\u0027t care whether color updates are sent all at once or in multiple messages would have to have much more complicated logic to process the messages.\n\n3: Introducing something which does require applications to store the color name and not just the constant color_which sounds fragile: changing the constant name will now break ABI rather than just source compatibility (and moreover it *won\u0027t* break source compatibility, so tracking down that brokenness will be annoying). The existing set_ui_colors seems like a strange API to me as a result and I find it questionable, but at least it\u0027s not commonly used and applications don\u0027t have to call it at present.\n\nSo I don\u0027t think there\u0027s much reason for this change, and many reasons not to go with it.",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d0846b0_5727c1fa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2025-03-10T10:36:36Z",
      "side": 1,
      "message": "This is really stupid. There is no ABI broken here, and my change documenting this, already present, behaviour has been unreviewed for months.\n\nIf app_server behaves in a dumb way if colors is used it should be fixed.\n\nThe color message spam causes useless redraws and flickering applications, to properly fix this the message has to contain all colors and the redraws can be minimized for their components.\n\nProperly processing a message with multiple colors is trivial, pretty much all Code in Haiku I checked already does this.\n\nThat beeing said, I don\u0027t really want to contribute anymore. I\u0027ve already talked with you on irc about this, and at this point It seems you are just vetoing all my changes put of spite.",
      "parentUuid": "bc1b0a2b_8e141708",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9055d683_cbfd4b91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-10T10:59:09Z",
      "side": 1,
      "message": "\u003e and at this point It seems you are just vetoing all my changes put of spite.\n\nI do not have much time right now and will respond to the technical details later, but whatever else is true, I promise you this is not the case. I am sorry that due to our present disagreement about the deprecation warnings it may seem otherwise, and I will certainly admit to being frustrated about that, but my comments here were not made \"looking for a fight\".",
      "parentUuid": "8d0846b0_5727c1fa",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90541209_0def6b2d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2025-03-10T12:02:19Z",
      "side": 1,
      "message": "I have investigated the problem further, and it seems my analysis yesterday was too hasty and partially incorrect on multiple counts, for which I apologize.\n\nIn my defense, it was incorrect partly because I genuinely trusted (1) your claims that we currently send multiple messages for multiple color updates here, and thus sending more than one per message would break existing applications, and (2) that copying `kColorNames` was necessary because there wasn\u0027t another way to turn a `ui_color` into a string (well, besides preprocessor macros), and thus that applications would have to hard-code the color constant names; and changing either of these would implicitly break ABI.\n\nBoth of these assumptions are wrong. As regards the first, I just tested with the existing setup by adding a `message-\u003ePrintToStream()` inside a `B_COLORS_UPDATED` block, and then changing the panel color in Appearance in automatic colors mode. And this is the message that results:\n```\nBMessage(\u0027_CLU\u0027) {\n        B_PANEL_BACKGROUND_COLOR \u003d rgb_color(138, 138, 138, 255)\n        B_MENU_BACKGROUND_COLOR \u003d rgb_color(138, 138, 138, 255)\n        B_SCROLL_BAR_THUMB_COLOR \u003d rgb_color(138, 138, 138, 255)\n        B_MENU_SELECTED_BACKGROUND_COLOR \u003d rgb_color(97, 97, 97, 255)\n        B_CONTROL_BACKGROUND_COLOR \u003d rgb_color(225, 225, 225, 255)\n        B_CONTROL_BORDER_COLOR \u003d rgb_color(110, 110, 110, 255)\n        B_WINDOW_BORDER_COLOR \u003d rgb_color(167, 167, 167, 255)\n        B_WINDOW_INACTIVE_TAB_COLOR \u003d rgb_color(185, 185, 185, 255)\n        B_WINDOW_INACTIVE_BORDER_COLOR \u003d rgb_color(185, 185, 185, 255)\n        B_LIST_SELECTED_BACKGROUND_COLOR \u003d rgb_color(121, 121, 121, 255)\n}\n```\nSo, we already do send multiple colors per message.\n\nAs regards the second, I had forgotten how `B_COLORS_UPDATED` already worked, indeed it uses the names already as keys; and this doesn\u0027t require applications to hardcode the names because there is the `ui_color_name` method. Had I read the code around your changes and not just your changes, I would have noticed that indeed `ui_color_name` is already used in this file.\n\nSo it turns out that my analysis yesterday was mostly wrong because of those two facts. (But then that also means your original analysis of the problem was wrong, also.)\n\nThe code to handle set_ui_color in app_server is here: https://grok.nikisoft.one/opengrok/xref/haiku/src/servers/app/Desktop.cpp?r\u003d2b7da773ed7efb95d2c4d16ec116ecb4c8ae33ac#2804\n\nThis uses DelayedMessage to coalesce all requests received within 16ms of the first into a single message, which is how we get only one color update message sent already. Meanwhile, in _FlushPendingColors(), we check if the colors actually changed (as korli noted), and if not, we don\u0027t send out the change notification. So, it seems your claim that there is \"color message spam\" is also wrong, we only send out messages when they are actually needed.\n\n\u003e useless redraws and flickering applications\n\nThank you, it\u0027s helpful to know the problem you are trying to solve.\n\nI agree that flickering is bad and we should fix it. However, even if my original mistaken analysis had been correct, there is no reason why multiple color update messages should cause flickering. They would all be sent out and processed in a much shorter window than 16ms, and so even if Invalidate() was called once for each color, we should still only redraw the view once because app_server coalesces updates, too, regardless. Furthermore, redraws after calling Invalidate() should never result in flickering (but it sometimes does, and there are open tickets about this problem.)\n\nNow, having said all that, my -2 for this change remains, but now for different reasons. The first is that, since we already send multiple color updates per message and coalesce in app_server, it just adds needless complexity to Appearance for no real benefit. The second is that the `set_ui_colors` actually *doesn\u0027t* use a delay when sending out color updates, and if for any reason is called twice in a short window, then two color update messages will be sent out; whereas no matter how many times `set_ui_color` is called in a 16ms window, only one message will be sent out. We should thus keep the existing code that just lets app_server do the coalescing here.",
      "parentUuid": "9055d683_cbfd4b91",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a92f823_39f9506e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2025-03-10T12:28:35Z",
      "side": 1,
      "message": "\u003eThis uses DelayedMessage to coalesce all requests received within 16m\n\nI don\u0027t think this is a good idea.\nTo explain a bit why I am going to this, is that I want to cut down the end-to-end latency of the system to the absolute minimum we can With my current monitor 16ms is already 4 frames (screen refreshes) as extra latency. And the \"flickering\" also likely comes from applications not receiving the messages at the same time, or not processing it in a timely manner.\n\nI had assumed that explicitly using set_ui_colors would immidiently broadcast the colors, and I still think it should do this, since here, we semantically explicitly commit to this beeing one batch of colors.\n\n\u003e As regards the second, I had forgotten how B_COLORS_UPDATED already worked, indeed it uses the names already as keys; and this doesn\u0027t require applications to hardcode the names because there is the ui_color_name method. Had I read the code around your changes and not just your changes, I would have noticed that indeed ui_color_name is already used in this file.\n\nCopying the table into the file certainly seemed like the wrong thing to do, hence the comment and also me uploading this for code review, to see if someone has a better idea on how to do this.\n\nWe should pack all of these into one message in set_ui_colors. 16ms is a racy window aswell, because if you update the colors, the way appearence works now you will slide on the slider, and this action itself takes much longer than just 16ms. So it is bound to happen that in such a race condition the app_server may decide that the 16ms window is over and not include one batch completely in the message. Though maybe it makes sure the batch is in \"completely\", I\u0027ve not checked the code for that yet.\n\n\nIf we can\u0027t batch the message here we will just delay the UI redrawing for 16ms + whatever drawing time apps need for no reason. This is 2 frames for how Haiku can *currently* drive my display, 4 frames for how it should drive it, 8 frames for the newerish 480/500hz monitors and 16 frames for \"ideal\" 1khz monitors. (With an possible setup, in the future, with adaptive sync where the worst case input latency is up to 1ms(monitor)+0,125ms(usb2)+whateverNS we need to process it. USB3 could in theory go even quicker)\n\nSure, I have other problems aswell, like making sure mice use a high usb rate if available (currently the energy save vs low latency stuff in processcontroller doesn\u0027t effect this). But I really don\u0027t see why we should delay messages needlesly, especially if we know this is a batch that is ready to be used and processes.\n\nAnyhow. This is not what a -2 is for. I can understand if you want to keep it untill we discuss this change, sure. But not to just block it because you think this delay is acceptable. This is not really a hill we should have to fight over. Thanks for looking into the app_server side more closely.\n\n\nApart from all of this, The code complexity here (assuming the table is gone) is minimal. The only real addition is the \"commiting\" call, but as korli pointed out we can use  set_ui_colors(\u0026fCurrentColors) to commit the changes at the end of the function, only having to split _SetOne_color into a variant that does not send the update immidiently, and one that does.",
      "parentUuid": "90541209_0def6b2d",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d17f7e4_1a7a0255",
        "filename": "src/preferences/appearance/ColorsView.cpp",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2025-03-09T10:55:32Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\nstatic const char* kColorNames[kColorWhichCount]\n\t\u003d {\"B_PANEL_BACKGROUND_COLOR\", \"B_MENU_BACKGROUND_COLOR\", \"B_WINDOW_TAB_COLOR\",\n\t\t\"B_KEYBOARD_NAVIGATION_COLOR\", \"B_DESKTOP_COLOR\", \"B_MENU_SELECTED_BACKGROUND_COLOR\",\n\t\t\"B_MENU_ITEM_TEXT_COLOR\", \"B_MENU_SELECTED_ITEM_TEXT_COLOR\", \"B_MENU_SELECTED_BORDER_COLOR\",\n\t\t\"B_PANEL_TEXT_COLOR\", \"B_DOCUMENT_BACKGROUND_COLOR\", \"B_DOCUMENT_TEXT_COLOR\",\n\t\t\"B_CONTROL_BACKGROUND_COLOR\", \"B_CONTROL_TEXT_COLOR\", \"B_CONTROL_BORDER_COLOR\",\n\t\t\"B_CONTROL_HIGHLIGHT_COLOR\", \"B_NAVIGATION_PULSE_COLOR\", \"B_SHINE_COLOR\", \"B_SHADOW_COLOR\",\n\t\t\"B_TOOLTIP_BACKGROUND_COLOR\", \"B_TOOLTIP_TEXT_COLOR\", \"B_WINDOW_TEXT_COLOR\",\n\t\t\"B_WINDOW_INACTIVE_TAB_COLOR\", \"B_WINDOW_INACTIVE_TEXT_COLOR\", \"B_WINDOW_BORDER_COLOR\",\n\t\t\"B_WINDOW_INACTIVE_BORDER_COLOR\", \"B_CONTROL_MARK_COLOR\", \"B_LIST_BACKGROUND_COLOR\",\n\t\t\"B_LIST_SELECTED_BACKGROUND_COLOR\", \"B_LIST_ITEM_TEXT_COLOR\",\n\t\t\"B_LIST_SELECTED_ITEM_TEXT_COLOR\", \"B_SCROLL_BAR_THUMB_COLOR\", \"B_LINK_TEXT_COLOR\",\n\t\t\"B_LINK_HOVER_COLOR\", \"B_LINK_VISITED_COLOR\", \"B_LINK_ACTIVE_COLOR\", \"B_STATUS_BAR_COLOR\",\n\t\t// 100...\n\t\t\"B_SUCCESS_COLOR\", \"B_FAILURE_COLOR\", NULL};\n\n```",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 95,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2839c2e8_52571993",
        "filename": "src/preferences/appearance/ColorsView.cpp",
        "patchSetId": 2
      },
      "lineNbr": 471,
      "author": {
        "id": 1000630
      },
      "writtenOn": "2025-03-09T10:55:32Z",
      "side": 1,
      "message": "Suggestion from `haiku-format` (change):\n```c++\n\t\t_QueOneColor(B_WINDOW_TEXT_COLOR, BPrivate::GetSystemColor(B_WINDOW_TEXT_COLOR, isDark));\n```",
      "range": {
        "startLine": 470,
        "startChar": 0,
        "endLine": 471,
        "endChar": 0
      },
      "tag": "autogenerated:experimental-formatting-bot",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84775087_323aa9c8",
        "filename": "src/preferences/appearance/ColorsView.cpp",
        "patchSetId": 2
      },
      "lineNbr": 517,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2025-03-10T08:46:12Z",
      "side": 1,
      "message": "I don\u0027t follow why set_ui_colors(\u0026fCurrentColors) wouldn\u0027t work as is. It should send only actual changes to clients.",
      "revId": "e6e24934c9e400d486b864e9f9860f3558080b68",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}