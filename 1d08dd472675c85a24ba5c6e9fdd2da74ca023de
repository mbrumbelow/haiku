{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a3fb8517_18783609",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-01-24T07:49:15Z",
      "side": 1,
      "message": "This is a bit strange, I would have expected we don\u0027t need the EFI_BOOT_SERVICES_* ones after exiting boot services (which is when the data created by these functions should start being used).\n\nWe would however need to preserve the EFI_RUNTIME_SERVICES_DATA or _CODE ones.\n\nIt\u0027s OK to do it this way for now if it gets us booting, but it means the \"boot services\" memory is never released even when the OS is running, right? Or where does that happen?",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d161e48_c8d3c88c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-01-24T14:20:50Z",
      "side": 1,
      "message": "We map runtime services right below this code block by attribute.\n\nLooking over the flow:\n\n* We generate arch_mmu_generate_post_efi_page_tables\n* We disable serial\n* We ExitBootServices\n* We get the memory map from kBootServices\n* arch_traps_init\n* arch_mmu_post_efi_setup\n* serial_enable\n* arch stuff for Satp, flush tlb\n* boot other cpus\n* enter kernel\n\nLooking at the above, we\u0027re calling kBootServices *after* ExitBootServices (by design).  Maybe that\u0027s what needs the area mapping?",
      "parentUuid": "a3fb8517_18783609",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a36c5575_16d467f8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-01-31T02:33:29Z",
      "side": 1,
      "message": "That looks bad. We should call ExitBootServices later, then; it\u0027s undefined behavior to call bootservices after ExitBootServices!",
      "parentUuid": "4d161e48_c8d3c88c",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9819479_b7a9a345",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-01-31T03:25:27Z",
      "side": 1,
      "message": "We don\u0027t actually.. i missed the break in that ExitBootServices loop.\n\nSo, did some digging (and disabled kBootServices which made this clearer).  satp allocated by arch_mmu_generate_post_efi_page_tables is where the frame pointer is for the trap:\n\n```\nNotice the address:\nSATP: 0x80000000000fbfe6\n.\n\nCalling ExitBootServices. So long, EFI!\n[PRE] SetSatp()\nSTrap(exception storePageFault)\n  sstatus: 0x8000000200006100 (ie: {}, pie: {}, spp: s, fs: dirty, xs: off, sum: 0, mxr: 0, uxl: 2, sd: 1)\n  sie: {}\n  sip: {}\n  sepc: 0xfe6c80ce\n  stval: 0xfe727000\n  sscratch: 0x0\nStack:\nFP: 0xfe726fc8, PC: 0xfe6c80ce\nFP: 0x80000000000fbfe6, PC: 0xfe6c80ce\n    ^^^^^^^^^^^^^^^^^^ Frame Pointer\n```\n\n\nSo is satp getting incorrectly allocated in EfiBootServicesCode or EfiBootServicesData?",
      "parentUuid": "a36c5575_16d467f8",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69e07b70_52561289",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-23T22:56:14Z",
      "side": 1,
      "message": "I found an alternative fix here:\nhttps://gist.github.com/kallisti5/7664431a4870e05f14d3e2dea3d07340\n\nI feel like leaving memory unallocated though that the loader is using is bad?  Maybe we should be freeing or un-allocating all the BootService memory types on exit... but that kinda sucks.",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1448ce42_bc7c023f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-23T22:56:46Z",
      "side": 1,
      "message": "context: https://cgit.haiku-os.org/haiku/tree/src/system/boot/platform/efi/arch/generic/generic_mmu.cpp#n21",
      "parentUuid": "69e07b70_52561289",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d97a4bcd_61b562fc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-02-24T14:15:53Z",
      "side": 1,
      "message": "That\u0027s rather strange. At least on the arm64 I actually wanted to unmap EfiLoaderCode/Data as well, similarly to the 32-bit ARM and x86 - which would leave us with a really lean and generic memory map containing the EFI runtime services, \"mmu_next\" regions and anything architecture-specific (e.g. lower 1M on 32-bit x86, UART on the arm, physical memory on 64-bit architectures).\n\nDo we know which structure is the problematic one? Is it one of the kernel arguments?",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26debedd_f6d3aead",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-24T14:46:08Z",
      "side": 1,
      "message": "We don\u0027t know yet.  It doesn\u0027t appear to be EFI serial related.  (accessing EFI services after Efi exit, especially after the EFI serial rework, it\u0027s pretty clearly guarded now)\n\nThe issue happens when activating the kernel page tables.  I thought about explicitly unmapping EfiBootService* memory areas when exiting EFI, however Puck pointed out:\n\n\"btw the spec says that you can treat all memory marked as EfiBootServices* as available free memory\"",
      "parentUuid": "d97a4bcd_61b562fc",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7acd2e29_c5a7337e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-02-24T14:59:48Z",
      "side": 1,
      "message": "Does this happen only on the Unmatched or also on qemu?",
      "parentUuid": "26debedd_f6d3aead",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "304ff287_b9c6640e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-24T16:57:42Z",
      "side": 1,
      "message": "Happens on qemu and unmatched",
      "parentUuid": "7acd2e29_c5a7337e",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1af55450_a00bc1c9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-03T15:51:41Z",
      "side": 1,
      "message": "I tried the arm64 at least to see where we are nowadays... unfortunately it seems that the arm64 port went stale i.e. it doesn\u0027t reach the rocket icon any more, neither on TianoCore nor older u-boot version where it used to work. \n\nSo for the time being I\u0027d leave the arm64 loader out of this patch as we have more fundamental issues on the arm64 port and the effect of this change could not be really tested.",
      "parentUuid": "304ff287_b9c6640e",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a0a34c94_4e42151a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-03T16:17:11Z",
      "side": 1,
      "message": "on the other hand I was able to reproduce the issue on qemu-system-riscv64, hrev56804:\n* successful boot to desktop with u-boot 2022.10\n* crash after [PRE] SetSatp() with u-boot 2023.01",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}