{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a3fb8517_18783609",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2023-01-24T07:49:15Z",
      "side": 1,
      "message": "This is a bit strange, I would have expected we don\u0027t need the EFI_BOOT_SERVICES_* ones after exiting boot services (which is when the data created by these functions should start being used).\n\nWe would however need to preserve the EFI_RUNTIME_SERVICES_DATA or _CODE ones.\n\nIt\u0027s OK to do it this way for now if it gets us booting, but it means the \"boot services\" memory is never released even when the OS is running, right? Or where does that happen?",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d161e48_c8d3c88c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-01-24T14:20:50Z",
      "side": 1,
      "message": "We map runtime services right below this code block by attribute.\n\nLooking over the flow:\n\n* We generate arch_mmu_generate_post_efi_page_tables\n* We disable serial\n* We ExitBootServices\n* We get the memory map from kBootServices\n* arch_traps_init\n* arch_mmu_post_efi_setup\n* serial_enable\n* arch stuff for Satp, flush tlb\n* boot other cpus\n* enter kernel\n\nLooking at the above, we\u0027re calling kBootServices *after* ExitBootServices (by design).  Maybe that\u0027s what needs the area mapping?",
      "parentUuid": "a3fb8517_18783609",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a36c5575_16d467f8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000011
      },
      "writtenOn": "2023-01-31T02:33:29Z",
      "side": 1,
      "message": "That looks bad. We should call ExitBootServices later, then; it\u0027s undefined behavior to call bootservices after ExitBootServices!",
      "parentUuid": "4d161e48_c8d3c88c",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9819479_b7a9a345",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-01-31T03:25:27Z",
      "side": 1,
      "message": "We don\u0027t actually.. i missed the break in that ExitBootServices loop.\n\nSo, did some digging (and disabled kBootServices which made this clearer).  satp allocated by arch_mmu_generate_post_efi_page_tables is where the frame pointer is for the trap:\n\n```\nNotice the address:\nSATP: 0x80000000000fbfe6\n.\n\nCalling ExitBootServices. So long, EFI!\n[PRE] SetSatp()\nSTrap(exception storePageFault)\n  sstatus: 0x8000000200006100 (ie: {}, pie: {}, spp: s, fs: dirty, xs: off, sum: 0, mxr: 0, uxl: 2, sd: 1)\n  sie: {}\n  sip: {}\n  sepc: 0xfe6c80ce\n  stval: 0xfe727000\n  sscratch: 0x0\nStack:\nFP: 0xfe726fc8, PC: 0xfe6c80ce\nFP: 0x80000000000fbfe6, PC: 0xfe6c80ce\n    ^^^^^^^^^^^^^^^^^^ Frame Pointer\n```\n\n\nSo is satp getting incorrectly allocated in EfiBootServicesCode or EfiBootServicesData?",
      "parentUuid": "a36c5575_16d467f8",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69e07b70_52561289",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-23T22:56:14Z",
      "side": 1,
      "message": "I found an alternative fix here:\nhttps://gist.github.com/kallisti5/7664431a4870e05f14d3e2dea3d07340\n\nI feel like leaving memory unallocated though that the loader is using is bad?  Maybe we should be freeing or un-allocating all the BootService memory types on exit... but that kinda sucks.",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1448ce42_bc7c023f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-23T22:56:46Z",
      "side": 1,
      "message": "context: https://cgit.haiku-os.org/haiku/tree/src/system/boot/platform/efi/arch/generic/generic_mmu.cpp#n21",
      "parentUuid": "69e07b70_52561289",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d97a4bcd_61b562fc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-02-24T14:15:53Z",
      "side": 1,
      "message": "That\u0027s rather strange. At least on the arm64 I actually wanted to unmap EfiLoaderCode/Data as well, similarly to the 32-bit ARM and x86 - which would leave us with a really lean and generic memory map containing the EFI runtime services, \"mmu_next\" regions and anything architecture-specific (e.g. lower 1M on 32-bit x86, UART on the arm, physical memory on 64-bit architectures).\n\nDo we know which structure is the problematic one? Is it one of the kernel arguments?",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26debedd_f6d3aead",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-24T14:46:08Z",
      "side": 1,
      "message": "We don\u0027t know yet.  It doesn\u0027t appear to be EFI serial related.  (accessing EFI services after Efi exit, especially after the EFI serial rework, it\u0027s pretty clearly guarded now)\n\nThe issue happens when activating the kernel page tables.  I thought about explicitly unmapping EfiBootService* memory areas when exiting EFI, however Puck pointed out:\n\n\"btw the spec says that you can treat all memory marked as EfiBootServices* as available free memory\"",
      "parentUuid": "d97a4bcd_61b562fc",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7acd2e29_c5a7337e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-02-24T14:59:48Z",
      "side": 1,
      "message": "Does this happen only on the Unmatched or also on qemu?",
      "parentUuid": "26debedd_f6d3aead",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "304ff287_b9c6640e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-02-24T16:57:42Z",
      "side": 1,
      "message": "Happens on qemu and unmatched",
      "parentUuid": "7acd2e29_c5a7337e",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1af55450_a00bc1c9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-03T15:51:41Z",
      "side": 1,
      "message": "I tried the arm64 at least to see where we are nowadays... unfortunately it seems that the arm64 port went stale i.e. it doesn\u0027t reach the rocket icon any more, neither on TianoCore nor older u-boot version where it used to work. \n\nSo for the time being I\u0027d leave the arm64 loader out of this patch as we have more fundamental issues on the arm64 port and the effect of this change could not be really tested.",
      "parentUuid": "304ff287_b9c6640e",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a0a34c94_4e42151a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-03T16:17:11Z",
      "side": 1,
      "message": "on the other hand I was able to reproduce the issue on qemu-system-riscv64, hrev56804:\n* successful boot to desktop with u-boot 2022.10\n* crash after [PRE] SetSatp() with u-boot 2023.01",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a61c07a2_2f09aec8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-03-03T19:28:55Z",
      "side": 1,
      "message": "David, did you try the standard qemu test script?\n\n../src/tests/qemu-boot-test arm64 bios:~/Code/firmware/u-boot/arm64/qemu/u-boot.bin haiku-mmc.image\n\nSerial shows a permission issue with the zstd infiltrator accessing something it shouldn\u0027t",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e9b0a18_f5ea47e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-03-03T22:22:44Z",
      "side": 1,
      "message": "So.  I had a think on this.\n\n* We map these ranges in generic_mmu as we map out physical memory\n* We then don\u0027t map them in arch_mmu.\n\nThe mapping in arch_mmu reserves these areas to prevent general usage.  By not mapping the areas, we\u0027re allowing the system to use EfiServices* areas for general memory allocation.\n\nThat\u0027s why when we kick on the new sv39 memory map, things go badly.  Our loader potentially starts mapping over EFI services which are still half-owned / active by EFI.\n\nThat\u0027s the only theory I can come up with.  It also explains why the alternative fix works... it doesn\u0027t physically map those areas in the first place, so they\u0027re not in the available memory pool.\n\nWith the above, i\u0027m +1\u0027ing this one.  Feel free to come up with alternative arm-chair analysis.",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5cdea31f_c17c977e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-05T18:10:27Z",
      "side": 1,
      "message": "It surely fixes the bootup on riscv64 so that part of the change is fine. However, the arm64 has a completely different symptom that was there on earlier bootloaders as well (e.g. u-boot 2022.07 or TianoCore) so I believe that arm64 will need to be handled separately.",
      "parentUuid": "2e9b0a18_f5ea47e4",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c1c10a8f_ca52ab75",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-07T20:29:48Z",
      "side": 1,
      "message": "I used my own qemu command line which is almost the same as the script, except that it does not have any virtio-net and force-legacy. The symptom is the same: page fault in inflate_fast()\n\nPrevious behavior when I last looked at arm64 port a few months ago\n* latest hrev at that time gave me a page fault, I don\u0027t know if I had any meaningful backtrace that time\n* if I comment out the timer interrupt then I was able to reach the rocket icon\n\nCurrent behavior:\n* latest hrev gives a page fault in inflate() or inflate_fast() but sometimes the fault happens at a completely invalid address\n* if I comment out the timer interrupt then the bootup sequence gets blocked at 3rd icon (before the point the page fault could occur)\n\nMaybe a context switch issue?",
      "parentUuid": "a61c07a2_2f09aec8",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd62a799_c2a05288",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-03-07T21:51:03Z",
      "side": 1,
      "message": "You are not allowed to call any UEFI services after exiting UEFI, except for runtime services. The problem here seems to me to that something violates that contract.",
      "parentUuid": "5cdea31f_c17c977e",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7b78783_8f1c927f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-03-07T21:55:23Z",
      "side": 1,
      "message": "There could also be an other reason: the initialization code might rely on some structures being identity-mapped. (e.g. kernel_args)",
      "parentUuid": "dd62a799_c2a05288",
      "revId": "1d08dd472675c85a24ba5c6e9fdd2da74ca023de",
      "serverId": "40b9299a-d8a8-485d-9b01-e6d3f45eefb5"
    }
  ]
}